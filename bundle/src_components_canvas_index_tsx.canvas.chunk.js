/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["flowcanvaswebpackJsonpPlugin"] = self["flowcanvaswebpackJsonpPlugin"] || []).push([["src_components_canvas_index_tsx"],{

/***/ "./src/components/Taskbar/draggable.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draggable\": () => (/* binding */ Draggable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/@dnd-kit/core/dist/core.esm.js\");\n\n\nconst Draggable = (props) => {\n    const { isDragging, attributes, listeners, setNodeRef, transform } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({\n        id: props.id,\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", Object.assign({ ref: setNodeRef, className: \"taskbar-draggable\" }, listeners, attributes), props.children));\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/Taskbar/draggable.tsx?");

/***/ }),

/***/ "./src/components/Taskbar/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TaskMenuMode\": () => (/* binding */ TaskMenuMode),\n/* harmony export */   \"Taskbar\": () => (/* binding */ Taskbar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/Taskbar/draggable.tsx\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/state/canvas-mode-state.ts\");\n/* harmony import */ var _state_modules_menu_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/state/modules-menu-state.ts\");\n\n\n\n\n\n\n\nvar TaskMenuMode;\n(function (TaskMenuMode) {\n    TaskMenuMode[TaskMenuMode[\"tasks\"] = 0] = \"tasks\";\n    TaskMenuMode[TaskMenuMode[\"modules\"] = 1] = \"modules\";\n})(TaskMenuMode || (TaskMenuMode = {}));\nconst Taskbar = (props) => {\n    const [metaDataInfo, setMetaDataInfo] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [menuMode, setMenuMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(TaskMenuMode.tasks);\n    const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const canvasMode = (0,_state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_4__.useCanvasModeStateStore)();\n    const modulesMenu = (0,_state_modules_menu_state__WEBPACK_IMPORTED_MODULE_5__.useModulesStateStore)();\n    const setupTasks = (metaDataInfo) => {\n        const taskPluginsSortedList = metaDataInfo.sort((a, b) => {\n            if (a.fullName < b.fullName) {\n                return -1;\n            }\n            if (a.fullName > b.fullName) {\n                return 1;\n            }\n            return 0;\n        });\n        const tasks = taskPluginsSortedList.filter((task) => {\n            return task.flowType == canvasMode.flowType;\n        }).map((task) => {\n            const taskSettings = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_3__.FlowToCanvas.getTaskSettings(task.className);\n            return { ...task,\n                icon: taskSettings.icon || task.icon || \"\"\n            };\n        });\n        setMetaDataInfo(tasks);\n    };\n    const loadTasks = () => {\n        var _a;\n        if (props.flowrunnerConnector.hasStorageProvider) {\n            let tasks = ((_a = props.flowrunnerConnector.storageProvider) === null || _a === void 0 ? void 0 : _a.getTasks()) || [];\n            setupTasks([...tasks, ...props.flowrunnerConnector.getTasksFromPluginRegistry()]);\n            return;\n        }\n        cross_fetch__WEBPACK_IMPORTED_MODULE_2___default()('/tasks')\n            .then(res => {\n            if (res.status >= 400) {\n                throw new Error(\"Bad response from server\");\n            }\n            return res.json();\n        })\n            .then(metaDataInfo => {\n            setupTasks([...metaDataInfo, ...props.flowrunnerConnector.getTasksFromPluginRegistry()]);\n        })\n            .catch(err => {\n            console.error(err);\n        });\n    };\n    const loadModules = () => {\n        cross_fetch__WEBPACK_IMPORTED_MODULE_2___default()('/api/modules')\n            .then(res => {\n            if (res.status >= 400) {\n                throw new Error(\"Bad response from server\");\n            }\n            return res.json();\n        })\n            .then(modules => {\n            console.log(\"modules\", modules);\n            setModules(modules);\n        })\n            .catch(err => {\n            console.error(err);\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        loadTasks();\n    }, [canvasMode]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (modulesMenu.isOpen) {\n            setMenuMode(TaskMenuMode.modules);\n            loadModules();\n        }\n        else {\n            setMenuMode(TaskMenuMode.tasks);\n        }\n    }, [modulesMenu.isOpen]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (metaDataInfo.length > 0) {\n            let loadingElement = document.getElementById(\"loading\");\n            if (loadingElement && !loadingElement.classList.contains(\"loaded\")) {\n                loadingElement.classList.add(\"loaded\");\n                setTimeout(() => {\n                    let loadingElement = document.getElementById(\"loading\");\n                    if (loadingElement) {\n                        loadingElement.classList.add(\"hidden\");\n                    }\n                }, 350);\n            }\n        }\n    }, [metaDataInfo]);\n    const onShowTests = (event) => {\n        event.preventDefault();\n        modulesMenu.showModule(\"tests\");\n        return false;\n    };\n    const onShowModule = (module, event) => {\n        event.preventDefault();\n        modulesMenu.showModule(module.name, module.id, module.moduleType);\n        return false;\n    };\n    const onDragStart = (event) => {\n        event.dataTransfer.setData(\"data-task\", event.target.getAttribute(\"data-task\"));\n    };\n    const renderRect = (className, taskMetaData) => {\n        let html5DragAndDrop = false;\n        const shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_3__.FlowToCanvas.getShapeType(\"Rect\", className, false);\n        if (shapeType == \"Circle\") {\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className));\n        }\n        if (shapeType == \"Ellipse\") {\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className));\n        }\n        if (shapeType == \"Diamond\") {\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"16\", height: \"16\" },\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polygon\", { points: \"8,2,14,8,8,14,2,8\", className: \"taskbar__task-circle\" })));\n        }\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className),\n            taskMetaData.icon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"taskbar__task-icon fas \" + taskMetaData.icon }));\n    };\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar\", style: { pointerEvents: props.isDragging ? \"none\" : \"auto\" } }, menuMode == TaskMenuMode.tasks ?\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__ribbon\" }, metaDataInfo.map((taskMetaData, index) => {\n                return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_draggable__WEBPACK_IMPORTED_MODULE_1__.Draggable, { id: taskMetaData.className, key: taskMetaData.className }, renderRect(taskMetaData.className, taskMetaData));\n            })) :\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                modules.map((module, index) => {\n                    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"module-\" + index, onClick: (event) => onShowModule(module, event), className: \"btn btn-outline-primary w-100 mb-2\" }, module.name);\n                }),\n                canvasMode.flowType == \"playground\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: onShowTests, className: \"btn btn-outline-primary w-100\" }, \"Tests\"))));\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/Taskbar/index.tsx?");

/***/ }),

/***/ "./src/components/canvas/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/index.tsx\");\n/* harmony import */ var _shapes_lines_for_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/lines-for-shape.tsx\");\n/* harmony import */ var _shapes_thumbs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/components/canvas/shapes/thumbs.tsx\");\n/* harmony import */ var _shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/components/canvas/shapes/thumbsstart.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./src/config.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"./node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _dragging_task__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"./src/dragging-task.tsx\");\n/* harmony import */ var _helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"./src/helpers/flow-methods.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"./src/components/flow/index.tsx\");\n/* harmony import */ var _helpers_line_points__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(\"./src/helpers/line-points.ts\");\n/* harmony import */ var _edit_node_settings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(\"./src/components/edit-node-settings/index.tsx\");\n/* harmony import */ var _services_position_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(\"./src/services/position-service.ts\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(\"./src/state/canvas-mode-state.ts\");\n/* harmony import */ var _state_selected_node_state__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(\"./src/state/selected-node-state.ts\");\n/* harmony import */ var _state_nodes_touched__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(\"./src/state/nodes-touched.ts\");\n/* harmony import */ var _html_plugins_form_controls_helpers_focus__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(\"./src/components/html-plugins/form-controls/helpers/focus.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(\"./node_modules/uuid/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_23__);\n/* harmony import */ var _use_flows__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(\"./src/use-flows.ts\");\n/* harmony import */ var _Taskbar__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(\"./src/components/Taskbar/index.tsx\");\n/* harmony import */ var _dnd_kit_modifiers__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(\"./node_modules/@dnd-kit/modifiers/dist/modifiers.esm.js\");\n/* harmony import */ var _helpers_error__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(\"./src/helpers/error.tsx\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst uuidV4 = uuid__WEBPACK_IMPORTED_MODULE_23__.v4;\nconst Canvas = (props) => {\n    const [stageWidth, setStageWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [stageHeight, setStageHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [canvasOpacity, setCanvasOpacity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [canvasKey, setCanvasKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [showNodeSettings, setShowNodeSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [editNode, setEditNode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const [editNodeSettings, setEditNodeSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const [isConnectingNodesByDragging, setIsConnectingNodesByDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [connectionX, setConnectionX] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [connectionY, setConnectionY] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [updateNodeTouchedState, setUpdateNodeTouchedState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [activeId, setActiveId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const { isOver, setNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_9__.useDroppable)({ id: 'droppable' });\n    const flowStore = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_18__.useFlowStore)();\n    const canvasMode = (0,_state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_19__.useCanvasModeStateStore)();\n    const selectedNode = (0,_state_selected_node_state__WEBPACK_IMPORTED_MODULE_20__.useSelectedNodeStore)();\n    const touchedNodesStore = (0,_state_nodes_touched__WEBPACK_IMPORTED_MODULE_21__.useNodesTouchedStateStore)();\n    let stage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let canvasWrapper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let htmlWrapper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let layer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let flowIsLoading = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    let flowIsFittedStageForSingleNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let closestNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    let orientationClosestNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let nodeOrientationClosestNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n    let shapeRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    let elementRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const connectionForDraggingName = \"_connection-dragging\";\n    let oldwheeltime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    let nodesStateLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    let touchedNodesLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    let dragTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let touching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let touchNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let touchNodeGroup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    let isConnectingNodesByDraggingLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let mouseStartX = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    let mouseStartY = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    let stageScale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(1.0);\n    let stageX = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0.0);\n    let stageY = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0.0);\n    let mouseDragging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let isPinching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let pinchStartPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ x: 0, y: 0 });\n    let startDistance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    let unmounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let connectionXStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    let connectionYStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    let connectionNodeEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((false));\n    let connectionNodeEventName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    let connectionNodeThumbPositionRelativeToNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n    let connectionNodeThumbPositionRelativeToEndNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n    let connectionNodeFollowFlow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default);\n    let shiftDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let ctrlDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const droppableStyle = { color: isOver ? 'green' : undefined };\n    const ctrlKey = 17;\n    const shiftKey = 16;\n    const cmdKey = 91;\n    const pasteKey = 86;\n    const backspaceKey = 8;\n    const fKeyCapt = 70;\n    const fKey = 102;\n    let wheelTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const wheelEnableLayoutOnTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (layer && layer.current) {\n            layer.current.listening(true);\n            layer.current.batchDraw();\n        }\n    }, [flowStore.flow]);\n    const wheelEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, touchPosition) => {\n        if (wheelTimeout.current) {\n            clearTimeout(wheelTimeout.current);\n            wheelTimeout.current = undefined;\n        }\n        if (e.toElement && e.toElement.closest) {\n            let element = e.toElement.closest(\".no-wheel\");\n            if (element) {\n                return true;\n            }\n        }\n        if (layer && layer.current) {\n            layer.current.listening(false);\n        }\n        wheelTimeout.current = setTimeout(wheelEnableLayoutOnTimeout, 60);\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            let scaleBy = 1.23;\n            scaleBy = 1.13;\n            if (stageInstance !== undefined && stageInstance.getPointerPosition() !== undefined) {\n                const oldScale = stageInstance.scaleX();\n                let xPos = stageInstance.getPointerPosition().x;\n                let yPos = stageInstance.getPointerPosition().y;\n                if (isPinching.current && touchPosition) {\n                    xPos = touchPosition.x;\n                    yPos = touchPosition.y;\n                }\n                const mousePointTo = {\n                    x: xPos / oldScale - stageInstance.x() / oldScale,\n                    y: yPos / oldScale - stageInstance.y() / oldScale,\n                };\n                const newScale = e.deltaY > 0 ? oldScale * scaleBy : oldScale / scaleBy;\n                const startPerf = performance.now();\n                stageInstance.scale({ x: newScale, y: newScale });\n                console.log(\"WheelEvent performance\", performance.now() - startPerf);\n                const newPos = {\n                    x: -(mousePointTo.x - xPos / newScale) * newScale,\n                    y: -(mousePointTo.y - yPos / newScale) * newScale\n                };\n                const newPosHtml = {\n                    x: -(mousePointTo.x - xPos / newScale),\n                    y: -(mousePointTo.y - yPos / newScale)\n                };\n                stageInstance.position(newPos);\n                stageInstance.batchDraw();\n                stageX.current = newPos.x;\n                stageY.current = newPos.y;\n                stageScale.current = newScale;\n                setHtmlElementsPositionAndScale(newPos.x, newPos.y, newScale);\n                console.log(\"WheelEvent performance setHtmlElementsPositionAndScale\", performance.now() - startPerf);\n            }\n            oldwheeltime.current = performance.now();\n        }\n        return false;\n    }, [flowStore.flow]);\n    const updateDimensions = () => {\n        const stageContainerElement = document.querySelector(\".stage-container\");\n        const bodyElement = document.querySelector(\"body\");\n        if (stageContainerElement !== null && bodyElement !== null) {\n            let widthCanvas = stageContainerElement.clientWidth;\n            let heightCanvas = bodyElement.clientHeight;\n            if (heightCanvas < 500) {\n                heightCanvas = 500;\n            }\n            setStageWidth(widthCanvas);\n            setStageHeight(heightCanvas);\n        }\n    };\n    const onPaste = async (event) => {\n        let text;\n        if (navigator.clipboard) {\n            text = await navigator.clipboard.readText();\n        }\n        else {\n            text = event.clipboardData.getData('text/plain');\n        }\n        if (event && event.target && event.target.tagName !== \"BODY\") {\n            return;\n        }\n        let pastedData;\n        event.stopPropagation();\n        event.preventDefault();\n        pastedData = text;\n        let columnCount = 0;\n        let rowCount = 0;\n        let values = [];\n        let lines = pastedData.split(/\\r?\\n/);\n        lines.map((line, index) => {\n            let insertValues = [];\n            line.split(/\\t/).map((value, index) => {\n                if (lines.length == 1) {\n                    const numericValue = parseInt(value);\n                    if (!isNaN(numericValue)) {\n                        values.push(numericValue);\n                    }\n                    else {\n                        values.push((value || \"\").toString());\n                    }\n                }\n                else {\n                    const numericValue = parseInt(value);\n                    if (!isNaN(numericValue)) {\n                        insertValues.push(numericValue);\n                    }\n                    else {\n                        insertValues.push((value || \"\").toString());\n                    }\n                }\n            });\n            if (lines.length > 1) {\n                values.push(insertValues);\n                if (insertValues.length > columnCount) {\n                    columnCount = insertValues.length;\n                }\n            }\n            else {\n                columnCount = values.length;\n            }\n        });\n        rowCount = lines.length;\n        if (touchNode.current && touchNodeGroup.current) {\n            event.preventDefault();\n            return false;\n        }\n        const nodeIsSelected = !!selectedNode && !!selectedNode.node;\n        if (!nodeIsSelected) {\n            if (!canvasMode.isConnectingNodes) {\n                if (stage && stage.current) {\n                    let stageInstance = stage.current.getStage();\n                    const position = stageInstance.getPointerPosition();\n                    const scaleFactor = stageInstance.scaleX();\n                    const taskType = \"DataGridTask\";\n                    let presetValues = {};\n                    const shapeSetting = (0,_config__WEBPACK_IMPORTED_MODULE_7__.getTaskConfigForTask)(taskType);\n                    if (shapeSetting && shapeSetting.presetValues) {\n                        presetValues = shapeSetting.presetValues;\n                    }\n                    let id = uuidV4();\n                    let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewNode)({\n                        name: id,\n                        id: id,\n                        label: \"DataGrid\",\n                        taskType: taskType,\n                        shapeType: \"Html\",\n                        x: ((position.x - (stageInstance).x()) / scaleFactor),\n                        y: ((position.y - (stageInstance).y()) / scaleFactor),\n                        ...presetValues,\n                        values,\n                        columns: columnCount,\n                        rows: rowCount\n                    }, flowStore.flow);\n                    let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeType(newNode.shapeType, newNode.taskType, newNode.isStartEnd);\n                    let centerXCorrection = 0;\n                    let centerYCorrection = 0;\n                    if (shapeType == \"Rect\" || shapeType == \"Ellipse\") {\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectWidht / 2;\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectHeight / 2;\n                    }\n                    else if (shapeType == \"Circle\") {\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize / 2;\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize / 2;\n                    }\n                    else if (shapeType == \"Diamond\") {\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize / 2;\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize / 2;\n                    }\n                    newNode.x = newNode.x - centerXCorrection;\n                    newNode.y = newNode.y - centerYCorrection;\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\n                        x: newNode.x,\n                        y: newNode.y\n                    });\n                    flowStore.addFlowNode(newNode);\n                }\n            }\n        }\n        selectedNode.selectNode(\"\", undefined);\n        canvasMode.setConnectiongNodeCanvasMode(false);\n        canvasMode.setSelectedTask(\"\");\n        return false;\n    };\n    const nodeStateList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const nodeStateCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const nodeStateTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    const nodeStateTimeoutCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        nodeStateList.current.map((nodeState) => {\n            let nodeStateClass = nodeState.nodeState == \"error\" ? \"has-error\" : \"\";\n            const element = elementRefs.current[nodeState.nodeName];\n            if (element) {\n                element.classList.remove(\"has-error\");\n                if (nodeStateClass != \"\") {\n                    element.classList.add(nodeStateClass);\n                }\n            }\n            const shapeRef = shapeRefs.current[nodeState.nodeName];\n            let newShapeState = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ShapeStateEnum.Default;\n            if (nodeState.nodeState == \"ok\") {\n                newShapeState = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ShapeStateEnum.Ok;\n            }\n            else if (nodeState.nodeState == \"error\") {\n                newShapeState = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ShapeStateEnum.Error;\n            }\n            if (shapeRef) {\n                shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetState, {\n                    state: newShapeState\n                });\n            }\n        });\n        Object.keys(touchedNodesLocal.current).map((touchNodeId) => {\n            const lineRef = shapeRefs.current[touchNodeId];\n            if (lineRef && lineRef && lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.GetShapeType, {}) == \"line\") {\n                return;\n            }\n            const element = elementRefs.current[touchNodeId];\n            if (element) {\n                if (touchedNodesLocal.current[touchNodeId] === true) {\n                    element.classList.remove(\"untouched\");\n                }\n                else {\n                    element.classList.add(\"untouched\");\n                }\n            }\n            else {\n                if (!touchedNodesLocal.current[touchNodeId] &&\n                    nodesStateLocal.current[touchNodeId] != \"\") {\n                    nodesStateLocal.current[touchNodeId] = \"\";\n                    const shapeRef = shapeRefs.current[touchNodeId];\n                    if (shapeRef) {\n                        shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetState, {\n                            state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ShapeStateEnum.Default\n                        });\n                    }\n                }\n            }\n        });\n        updateTouchedNodes();\n        nodeStateList.current = [];\n        nodeStateCount.current = 0;\n    }, [flowStore.flow]);\n    const nodeStateObserver = (nodeName, nodeState, _touchedNodes) => {\n        if (!updateNodeTouchedState) {\n            return;\n        }\n        if (nodeStateTimeout.current) {\n            clearTimeout(nodeStateTimeout.current);\n            nodeStateTimeout.current = undefined;\n        }\n        nodeStateCount.current += 1;\n        nodeStateList.current.push({\n            nodeState: nodeState,\n            nodeName: nodeName\n        });\n        nodeStateTimeout.current = setTimeout(nodeStateTimeoutCallback, 30);\n        touchedNodesLocal.current = _touchedNodes;\n        nodesStateLocal.current[nodeName] = nodeState;\n    };\n    const cancelScroll = () => {\n        window.scrollTop = 0;\n        window.scrollLeft = 0;\n        document.body.scrollTop = 0;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        window.addEventListener(\"resize\", onResize);\n        window.addEventListener(\"scroll\", cancelScroll);\n        document.addEventListener('paste', onPaste);\n        updateDimensions();\n        document.body.scrollTop = 0;\n        touchedNodesStore.clearNodesTouched();\n        props.flowrunnerConnector.unregisterNodeStateObserver(\"canvas\");\n        props.flowrunnerConnector.registerNodeStateObserver(\"canvas\", nodeStateObserver);\n        return () => {\n            props.flowrunnerConnector.unregisterNodeStateObserver(\"canvas\");\n            window.removeEventListener(\"resize\", onResize);\n            window.removeEventListener(\"scroll\", cancelScroll);\n        };\n    }, []);\n    const onResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        updateDimensions();\n        fitStage(undefined, true, true);\n    }, [flowStore.flow]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        let subscription;\n        if (props.canvasToolbarsubject) {\n            subscription = props.canvasToolbarsubject.subscribe({\n                next: (message) => {\n                    if (unmounted.current) {\n                        return;\n                    }\n                    if (message == \"loadFlow\") {\n                        flowIsLoading.current = true;\n                        setCanvasOpacity(0);\n                    }\n                    else if (message == \"fitStage\") {\n                        fitStage(undefined, true, true);\n                        setCanvasOpacity(1);\n                    }\n                    else if (message == \"reload\") {\n                        setCanvasKey(canvasKey + 1);\n                    }\n                    else if (message == \"export\") {\n                        exportCanvas();\n                    }\n                }\n            });\n        }\n        return () => {\n            if (subscription) {\n                subscription.unsubscribe();\n            }\n        };\n    }, [flowStore.flow]);\n    const updateTouchedNodes = () => {\n        if (touchedNodesLocal.current) {\n            if (stage && stage.current) {\n                let stageInstance = stage.current.getStage();\n                if (stageInstance) {\n                    Object.keys(shapeRefs.current).map((touchNodeId) => {\n                        const lineRef = shapeRefs.current[touchNodeId];\n                        if (lineRef && lineRef && lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.GetShapeType, {}) == \"line\") {\n                            if (touchedNodesLocal.current[touchNodeId]) {\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetState, {\n                                    state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ShapeStateEnum.Touched\n                                });\n                            }\n                            else {\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetState, {\n                                    state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ShapeStateEnum.Default\n                                });\n                            }\n                        }\n                    });\n                    stageInstance.batchDraw();\n                }\n            }\n        }\n    };\n    const recalculateStartEndpoints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((doBatchdraw) => {\n        const startPerf = performance.now();\n        flowStore.flow.map((node, index) => {\n            if (node.shapeType !== \"Line\") {\n                let shapeRef = shapeRefs.current[node.name];\n                if (shapeRef && shapeRef) {\n                    let element = elementRefs.current[node.name];\n                    if (element) {\n                        const position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name) || { x: node.x, y: node.y };\n                        let x = parseFloat(element.getAttribute(\"data-x\") || \"\");\n                        let y = parseFloat(element.getAttribute(\"data-y\") || \"\");\n                        if (node && element.getAttribute(\"data-node\") == node.name) {\n                            x = position.x;\n                            y = position.y;\n                            element.setAttribute(\"data-x\", x.toString());\n                            element.setAttribute(\"data-y\", y.toString());\n                        }\n                        const nodeName = element.getAttribute(\"data-node\") || \"\";\n                        setHtmlElementStyle(element, stageX, stageY, stageScale, x, y);\n                        setNewPositionForNode(node, shapeRef, { x: position.x, y: position.y }, false, true, doBatchdraw, true);\n                    }\n                }\n            }\n        });\n        if (!!doBatchdraw && stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                stageInstance.batchDraw();\n            }\n        }\n    }, [flowStore.flow]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        window.addEventListener(\"resize\", onResize);\n        const lineRef = shapeRefs.current[connectionForDraggingName];\n        if (lineRef && lineRef) {\n            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n        }\n        const startPerf = performance.now();\n        if (props.flow && props.flow.length > 0) {\n            if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_24__.FlowState.loading || props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_24__.FlowState.idle) {\n                setCanvasOpacity(0);\n                flowIsLoading.current = true;\n            }\n            else if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_24__.FlowState.loaded && flowIsLoading.current) {\n                if (canvasOpacity == 0) {\n                    setCanvasOpacity(1);\n                }\n                flowIsLoading.current = false;\n                flowIsFittedStageForSingleNode.current = true;\n                let perfstart = performance.now();\n                (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.clearPositions)();\n                perfstart = performance.now();\n                flowStore.flow.map((node, index) => {\n                    if (node.x && node.y) {\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\n                            x: node.x,\n                            y: node.y\n                        });\n                    }\n                    if (node.xstart && node.ystart) {\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\n                            xstart: node.xstart,\n                            ystart: node.ystart,\n                            xend: node.xend,\n                            yend: node.yend\n                        });\n                    }\n                });\n                perfstart = performance.now();\n                nodesStateLocal.current = {};\n                touchedNodesLocal.current = {};\n                fitStage(undefined, false, false);\n                if (stage && stage.current) {\n                    let stageDiv = stage.current;\n                    if (stageDiv && stageDiv.attrs[\"container\"]) {\n                        stageDiv.attrs[\"container\"].parentNode.focus();\n                    }\n                }\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\n                recalculateStartEndpoints(false);\n            }\n            else if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_24__.FlowState.loaded && !flowIsLoading.current) {\n                if (flowStore.flow.length == 1) {\n                    if (!flowIsFittedStageForSingleNode.current) {\n                        fitStage(undefined, false, false);\n                        flowIsFittedStageForSingleNode.current = true;\n                    }\n                }\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\n                recalculateStartEndpoints(false);\n            }\n            touchedNodesStore.setNodesTouched(touchedNodesLocal.current);\n            let disabledUpdateTouchedState = false;\n            flowStore.flow.map((node, index) => {\n                if (node.taskType === \"TimerTask\" ||\n                    (node.taskType == \"DebugTask\" &&\n                        node.visualizer == \"animatedgridcanvas\")) {\n                    disabledUpdateTouchedState = true;\n                }\n            });\n            if (!!disabledUpdateTouchedState) {\n                setUpdateNodeTouchedState(false);\n            }\n            else {\n                setUpdateNodeTouchedState(true);\n            }\n        }\n        else if (flowStore && flowStore.flow.length == 0) {\n            flowIsFittedStageForSingleNode.current = false;\n            if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_24__.FlowState.loaded) {\n                if (canvasOpacity == 0) {\n                    setCanvasOpacity(1);\n                }\n            }\n        }\n        if (stage && stage.current) {\n            const stageInstance = stage.current.getStage();\n            stageInstance.batchDraw();\n        }\n        updateTouchedNodes();\n        return () => {\n            document.removeEventListener('paste', onPaste);\n            window.removeEventListener(\"resize\", onResize);\n        };\n    }, [props.flowState, flowStore.flow]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        updateTouchedNodes();\n    }, [\n        canvasMode,\n        props.canvasToolbarsubject,\n        stageWidth,\n        stageHeight,\n        canvasOpacity,\n        showNodeSettings,\n        editNode,\n        editNodeSettings,\n        isConnectingNodesByDragging,\n        connectionX,\n        connectionY\n    ]);\n    const setNewPositionForNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node, group, position, isCommitingToStore, linesOnly, doDraw, skipSetHtml) => {\n        const unselectedNodeOpacity = 0.15;\n        if (!linesOnly) {\n            flowStore.flow.map((flowNode) => {\n                if (flowNode.name !== node.name) {\n                    if (shapeRefs.current[flowNode.name]) {\n                        const shape = shapeRefs.current[flowNode.name];\n                        if (shape) {\n                        }\n                    }\n                    const element = elementRefs.current[flowNode.name];\n                    if (element) {\n                        element.style.opacity = \"1\";\n                    }\n                }\n            });\n        }\n        let resultXY = group && group.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.GetXY, {});\n        const x = resultXY ? resultXY.x : 0;\n        const y = resultXY ? resultXY.y : 0;\n        let newPosition = position || { x: x, y: y };\n        if (newPosition && !linesOnly) {\n            if (stage && stage.current) {\n                let stageInstance = stage.current.getStage();\n                if (stageInstance) {\n                    let touchPos = stageInstance.getPointerPosition();\n                    if (touchPos) {\n                        const scaleFactor = stageInstance.scaleX();\n                        newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor) - mouseStartX.current;\n                        newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor) - mouseStartY.current;\n                    }\n                }\n            }\n            if (shapeRefs.current[node.name]) {\n                if (shapeRefs.current[node.name]) {\n                    let currentGroup = shapeRefs.current[node.name];\n                    if (currentGroup) {\n                        currentGroup.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetXY, newPosition);\n                        currentGroup.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(node.taskType, node);\n                    const shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeType(node.shapeType, node.taskType, node.isStartEnd);\n                    let diamondThumb = 0;\n                    if (shapeType === \"Diamond\") {\n                        if (!settings.altThumbPositions) {\n                            diamondThumb = 1;\n                        }\n                        else if (settings.altThumbPositions === 1) {\n                            diamondThumb = 2;\n                        }\n                    }\n                    let currentGroupThumbs = shapeRefs.current[\"thumb_\" + node.name];\n                    if (currentGroupThumbs) {\n                        let thumbPosition;\n                        if (diamondThumb === 2) {\n                            thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbEndPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top);\n                        }\n                        else {\n                            thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbEndPosition(shapeType, newPosition);\n                        }\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetXY, thumbPosition);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    currentGroupThumbs = shapeRefs.current[\"thumbtop_\" + node.name];\n                    if (currentGroupThumbs) {\n                        const thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbEndPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetXY, thumbPosition);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    currentGroupThumbs = shapeRefs.current[\"thumbstart_\" + node.name];\n                    if (currentGroupThumbs) {\n                        const thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetXY, thumbPosition);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    currentGroupThumbs = shapeRefs.current[\"thumbstarttop_\" + node.name];\n                    if (currentGroupThumbs) {\n                        let thumbPosition;\n                        if (diamondThumb === 2) {\n                            thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.left);\n                        }\n                        else {\n                            thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top);\n                        }\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetXY, thumbPosition);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    currentGroupThumbs = shapeRefs.current[\"thumbstartbottom_\" + node.name];\n                    if (currentGroupThumbs) {\n                        let thumbPosition;\n                        if (diamondThumb === 2) {\n                            thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.right);\n                        }\n                        else {\n                            thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom);\n                        }\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetXY, thumbPosition);\n                        currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    const element = elementRefs.current[node.name];\n                    if (element) {\n                        element.style.opacity = \"1\";\n                    }\n                }\n            }\n        }\n        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, { ...newPosition });\n        if (skipSetHtml === undefined || skipSetHtml === false) {\n            setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current, newPosition.x, newPosition.y, node);\n        }\n        const startLines = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getLinesForStartNodeFromCanvasFlow(flowStore.flow, node, flowStore.flowHashmap);\n        let lines = {};\n        if (startLines) {\n            startLines.map((lineNode) => {\n                const newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(node, newPosition, lineNode, props.getNodeInstance, lineNode.thumbPosition);\n                let endNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.endshapeid).index];\n                if (endNode) {\n                    const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(endNode.name) || endNode;\n                    const newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getEndPointForLine(endNode, {\n                        x: positionNode.x,\n                        y: positionNode.y\n                    }, node, props.getNodeInstance, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                    const lineRef = shapeRefs.current[lineNode.name];\n                    if (lineRef) {\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_15__.calculateLineControlPoints)(newStartPosition.x, newStartPosition.y, newEndPosition.x, newEndPosition.y, lineNode.thumbPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetPoints, { points: [newStartPosition.x, newStartPosition.y,\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\n                                newEndPosition.x, newEndPosition.y] });\n                    }\n                    const endNodeRef = shapeRefs.current[lineNode.endshapeid];\n                    if (endNodeRef) {\n                        endNodeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(lineNode.name, {\n                        xstart: newStartPosition.x, ystart: newStartPosition.y,\n                        xend: newEndPosition.x, yend: newEndPosition.y\n                    });\n                }\n                lines[lineNode.name] = { x: newStartPosition.x, y: newStartPosition.y };\n            });\n        }\n        const endLines = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getLinesForEndNodeFromCanvasFlow(flowStore.flow, node, flowStore.flowHashmap);\n        if (endLines) {\n            endLines.map((lineNode) => {\n                const newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getEndPointForLine(node, newPosition, lineNode, props.getNodeInstance, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                const positionLine = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(lineNode.name) || lineNode;\n                let startPos = {\n                    x: positionLine.xstart,\n                    y: positionLine.ystart\n                };\n                let startNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.startshapeid).index];\n                if (startNode) {\n                    const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(startNode.name) || startNode;\n                    let newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(startNode, {\n                        x: positionNode.x,\n                        y: positionNode.y\n                    }, lineNode, props.getNodeInstance, lineNode.thumbPosition);\n                    if (lines[lineNode.name]) {\n                        newStartPosition = lines[lineNode.name];\n                    }\n                    const lineRef = shapeRefs.current[lineNode.name];\n                    if (lineRef) {\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_15__.calculateLineControlPoints)(newStartPosition.x, newStartPosition.y, newEndPosition.x, newEndPosition.y, lineNode.thumbPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetPoints, { points: [newStartPosition.x, newStartPosition.y,\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\n                                newEndPosition.x, newEndPosition.y] });\n                    }\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(lineNode.name, {\n                        xstart: newStartPosition.x, ystart: newStartPosition.y,\n                        xend: newEndPosition.x, yend: newEndPosition.y\n                    });\n                    const startNodeRef = shapeRefs.current[lineNode.startshapeid];\n                    if (startNodeRef) {\n                        startNodeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                    }\n                }\n            });\n        }\n        if (!!doDraw) {\n            if (stage && stage.current) {\n                let stageInstance = stage.current.getStage();\n                stageInstance.batchDraw();\n            }\n            updateTouchedNodes();\n        }\n        if (!!isCommitingToStore) {\n            selectedNode.selectNode(node.name, node);\n            canvasMode.setConnectiongNodeCanvasMode(false);\n            if (props.flowrunnerConnector.hasStorageProvider) {\n                props.saveFlow();\n            }\n        }\n    }, [flowStore.flow]);\n    const onCloneNode = (node, event) => {\n        event.preventDefault();\n        let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewNode)({ ...node }, flowStore.flow);\n        newNode.x = newNode.x + 100;\n        newNode.y = newNode.y + 100;\n        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\n            x: newNode.x,\n            y: newNode.y\n        });\n        flowStore.addFlowNode(newNode);\n        return false;\n    };\n    const onShowNodeSettings = (node, settings, event) => {\n        event.preventDefault();\n        setEditNode(node);\n        setEditNodeSettings(settings);\n        setShowNodeSettings(true);\n        return false;\n    };\n    const onCloseEditNodeSettings = () => {\n        setShowNodeSettings(false);\n        setEditNode(undefined);\n        setEditNodeSettings(undefined);\n    };\n    const downloadURI = (uri, name) => {\n        let link = document.createElement('a');\n        link.download = name;\n        link.href = uri;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    };\n    const exportCanvas = () => {\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            var dataURL = stageInstance.toDataURL({ pixelRatio: 6 });\n            downloadURI(dataURL, 'flow.png');\n        }\n    };\n    const onClickSetup = (node, settings, event) => {\n        if (node.notSelectable) {\n            return false;\n        }\n        event.evt.preventDefault();\n        setEditNode(node);\n        setEditNodeSettings(settings);\n        setShowNodeSettings(true);\n        return false;\n    };\n    const onMouseOver = (node, event) => {\n        if (node.notSelectable) {\n            return false;\n        }\n        document.body.style.cursor = 'pointer';\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(node.taskType, node);\n        if (node.shapeType === \"Diamond\" && settings.altThumbPositions === 1) {\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top;\n        }\n        else if (node.shapeType === \"Diamond\" && !settings.altThumbPositions) {\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n        }\n    };\n    const onMouseOut = () => {\n        document.body.style.cursor = 'default';\n    };\n    const determineStartPosition = (group) => {\n        const x = group.attrs[\"x\"];\n        const y = group.attrs[\"y\"];\n        let newPosition = { x: x, y: y };\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                var touchPos = stageInstance.getPointerPosition();\n                const scaleFactor = stageInstance.scaleX();\n                newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\n                newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\n                mouseStartX.current = newPosition.x - x;\n                mouseStartY.current = newPosition.y - y;\n            }\n        }\n    };\n    const onMouseStart = (node, event) => {\n        if (!!canvasMode.isConnectingNodes) {\n            cancelDragStage();\n            return false;\n        }\n        if (isConnectingNodesByDraggingLocal.current) {\n            cancelDragStage();\n            return false;\n        }\n        if (isPinching.current) {\n            cancelDragStage();\n            return;\n        }\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        touching.current = true;\n        touchNode.current = node;\n        touchNodeGroup.current = event.currentTarget;\n        if (event.currentTarget) {\n            determineStartPosition(event.currentTarget);\n        }\n        return false;\n    };\n    const onMouseMove = (node, event) => {\n        if (node && touching.current && touchNode.current &&\n            node.name !== touchNode.current.name) {\n            return;\n        }\n        if (isConnectingNodesByDraggingLocal.current) {\n            return;\n        }\n        if (isPinching.current) {\n            return;\n        }\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        if (!!canvasMode.isConnectingNodes) {\n            cancelDragStage();\n            return false;\n        }\n        if (touching.current) {\n            if (event.currentTarget) {\n                mouseDragging.current = true;\n                document.body.classList.add(\"mouse--moving\");\n                setNewPositionForNode(node, shapeRefs.current[node.name], event.evt.screenX ? {\n                    x: event.evt.screenX,\n                    y: event.evt.screenY\n                } : undefined, false, false, true);\n            }\n        }\n        return false;\n    };\n    const connectConnectionToNode = (node, thumbPositionRelativeToNode) => {\n        let eventHelper = undefined;\n        if (connectionNodeEventName !== undefined &&\n            connectionNodeEventName.current !== \"\" &&\n            !isNaN(connectionNodeEvent.current)) {\n            eventHelper = {};\n            eventHelper.event = connectionNodeEventName.current;\n        }\n        const connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewConnection)(touchNode.current, node, props.getNodeInstance, eventHelper, connectionNodeThumbPositionRelativeToNode.current);\n        connection.thumbPosition = connectionNodeThumbPositionRelativeToNode.current;\n        if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.happyFlow) {\n            connection.followflow = \"onsuccess\";\n        }\n        else if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.unhappyFlow) {\n            connection.followflow = \"onfailure\";\n        }\n        if (thumbPositionRelativeToNode !== undefined) {\n            connection.thumbEndPosition = thumbPositionRelativeToNode;\n        }\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(node.taskType, node);\n        if (node.shapeType === \"Diamond\" && settings.altThumbPositions === 1) {\n            connection.thumbEndPosition = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top;\n        }\n        if (connectionNodeEventName.current !== \"\" &&\n            !isNaN(connectionNodeEvent.current)) {\n            connection.event = connectionNodeEventName.current;\n        }\n        touching.current = false;\n        isConnectingNodesByDraggingLocal.current = false;\n        connectionNodeEvent.current = false;\n        connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n        connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default;\n        connectionNodeEventName.current = \"\";\n        touchNode.current = undefined;\n        touchNodeGroup.current = undefined;\n        const lineRef = shapeRefs.current[connectionForDraggingName];\n        if (lineRef) {\n            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n        }\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                stageInstance.batchDraw();\n            }\n        }\n        document.body.classList.remove(\"connecting-nodes\");\n        mouseDragging.current = false;\n        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connection.name, {\n            xstart: connection.xstart,\n            ystart: connection.ystart,\n            xend: connection.xend,\n            yend: connection.yend\n        });\n        flowStore.addConnection(connection);\n        canvasMode.setConnectiongNodeCanvasMode(false);\n    };\n    const onMouseEnd = (node, event) => {\n        if (isPinching.current) {\n            return;\n        }\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\n            connectConnectionToNode(node);\n            return false;\n        }\n        document.body.classList.remove(\"mouse--moving\");\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        if (touchNodeGroup.current != event.currentTarget) {\n            return false;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        touching.current = false;\n        dragTime.current = undefined;\n        touchNodeGroup.current = undefined;\n        if (event.currentTarget && mouseDragging.current) {\n            setNewPositionForNode(node, shapeRefs.current[node.name], undefined, true, false, true);\n        }\n        else {\n            selectedNode.selectNode(node.name, node);\n            canvasMode.setConnectiongNodeCanvasMode(false);\n        }\n        touchNode.current = undefined;\n        mouseDragging.current = false;\n        return false;\n    };\n    const onStageMouseEnd = (event) => {\n        if (isPinching.current) {\n            isPinching.current = false;\n            return;\n        }\n        if (touching.current || isConnectingNodesByDraggingLocal.current) {\n            cancelDragStage();\n            if (stage && stage.current) {\n                let stageInstance = stage.current.getStage();\n                dragTime.current = undefined;\n                touching.current = false;\n                event.evt.preventDefault();\n                event.evt.cancelBubble = true;\n                touchNode.current = undefined;\n                touchNodeGroup.current = undefined;\n                isConnectingNodesByDraggingLocal.current = false;\n                connectionNodeEvent.current = false;\n                connectionNodeEventName.current = \"\";\n                connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n                connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default;\n                document.body.classList.remove(\"connecting-nodes\");\n                document.body.classList.remove(\"mouse--moving\");\n                const lineRef = shapeRefs.current[connectionForDraggingName];\n                if (lineRef) {\n                    lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n                }\n                if (stageInstance) {\n                    stageInstance.batchDraw();\n                }\n            }\n            return false;\n        }\n    };\n    const onStageMouseLeave = (event) => {\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        const lineRef = shapeRefs.current[connectionForDraggingName];\n        if (lineRef) {\n            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n            if (stage && stage.current) {\n                let stageInstance = stage.current.getStage();\n                if (stageInstance !== undefined) {\n                    stageInstance.batchDraw();\n                }\n            }\n        }\n        isConnectingNodesByDraggingLocal.current = false;\n        connectionNodeEvent.current = false;\n        connectionNodeEventName.current = \"\";\n        connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n        connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default;\n        document.body.classList.remove(\"connecting-nodes\");\n        document.body.classList.remove(\"mouse--moving\");\n        touching.current = false;\n        dragTime.current = undefined;\n        touchNode.current = undefined;\n        touchNodeGroup.current = undefined;\n        isPinching.current = false;\n        return false;\n    };\n    const onMouseLeave = (node, event) => {\n        return;\n    };\n    const onStageTouchStart = (event) => {\n        isPinching.current = false;\n        if (!!canvasMode.isConnectingNodes) {\n            cancelDragStage();\n            return false;\n        }\n        if (touchNode.current && touchNodeGroup.current) {\n            cancelDragStage();\n        }\n        else {\n            if (event.evt.touches.length > 1) {\n                isPinching.current = true;\n                cancelDragStage();\n                if (event.evt.touches.length == 2) {\n                    pinchStartPosition.current = {\n                        x: (event.evt.touches[0].screenX + event.evt.touches[1].screenX) / 2,\n                        y: (event.evt.touches[0].screenY + event.evt.touches[1].screenY) / 2\n                    };\n                    const x = event.evt.touches[0].screenX - event.evt.touches[1].screenX;\n                    const y = event.evt.touches[0].screenY - event.evt.touches[1].screenY;\n                    startDistance.current = Math.sqrt(x * x + y * y);\n                }\n            }\n        }\n    };\n    const onStageTouchMove = (event) => {\n        if (isConnectingNodesByDraggingLocal.current) {\n            event.evt.cancelBubble = true;\n            if (stage && stage.current) {\n                let stageInstance = stage.current.getStage();\n                if (stageInstance) {\n                    var touchPos = stageInstance.getPointerPosition();\n                    const scaleFactor = stageInstance.scaleX();\n                    let newPosition = {\n                        x: 0,\n                        y: 0\n                    };\n                    newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\n                    newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\n                    if (lineRef) {\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_15__.calculateLineControlPoints)(connectionXStart.current, connectionYStart.current, newPosition.x, newPosition.y, connectionNodeThumbPositionRelativeToNode.current, connectionNodeThumbPositionRelativeToEndNode.current);\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetPoints, { points: [connectionXStart.current, connectionYStart.current,\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\n                                newPosition.x, newPosition.y] });\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                        stageInstance.batchDraw();\n                    }\n                }\n            }\n            return;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            cancelDragStage();\n            return false;\n        }\n        if (touchNode.current && touchNodeGroup.current && !isPinching.current) {\n            event.evt.preventDefault();\n            event.evt.cancelBubble = true;\n            setNewPositionForNode(touchNode.current, shapeRefs.current[touchNode.current.name], event.evt.screenX ? {\n                x: event.evt.screenX,\n                y: event.evt.screenY\n            } : undefined, false, false, true);\n            cancelDragStage();\n            return false;\n        }\n        else {\n            if (isPinching.current && event.evt.touches && event.evt.touches.length > 1) {\n                cancelDragStage();\n                event.evt.preventDefault();\n                event.evt.cancelBubble = true;\n                if (event.evt.touches.length == 2) {\n                    const x = event.evt.touches[0].screenX - event.evt.touches[1].screenX;\n                    const y = event.evt.touches[0].screenY - event.evt.touches[1].screenY;\n                    let newDistance = Math.sqrt(x * x + y * y);\n                    wheelEvent({\n                        deltaY: newDistance - startDistance.current,\n                        toElement: undefined\n                    }, pinchStartPosition.current);\n                }\n                return false;\n            }\n        }\n    };\n    const onStageTouchEnd = (event) => {\n        isPinching.current = false;\n        if (!mouseDragging.current) {\n            if (touchNode.current && touchNodeGroup.current) {\n                selectedNode.selectNode(touchNode.current.name, touchNode.current);\n                canvasMode.setConnectiongNodeCanvasMode(false);\n            }\n        }\n    };\n    const cancelDragStage = () => {\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                stageInstance.stopDrag();\n            }\n        }\n    };\n    const onTouchStart = (node, event) => {\n        if (isPinching.current) {\n            return;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (isConnectingNodesByDraggingLocal.current) {\n            return false;\n        }\n        touching.current = true;\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        touchNode.current = node;\n        touchNodeGroup.current = event.currentTarget;\n        cancelDragStage();\n        if (event.currentTarget) {\n            determineStartPosition(event.currentTarget);\n        }\n        return false;\n    };\n    const onTouchMove = (node, event) => {\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (isConnectingNodesByDraggingLocal.current) {\n            return false;\n        }\n        if (isPinching.current) {\n            return;\n        }\n        if (touchNodeGroup.current != event.currentTarget) {\n            return false;\n        }\n        touching.current = true;\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        if (event.currentTarget) {\n            mouseDragging.current = true;\n            setNewPositionForNode(node, shapeRefs.current[node.name], event.evt.touches.length > 0 ? {\n                x: event.evt.touches[0].screenX,\n                y: event.evt.touches[0].screenY\n            } : undefined, false, false, true);\n        }\n        return false;\n    };\n    const onTouchEnd = (node, event) => {\n        if (isPinching.current) {\n            return;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (isConnectingNodesByDraggingLocal.current) {\n            return false;\n        }\n        if (touchNodeGroup.current != event.currentTarget) {\n            return false;\n        }\n        touching.current = false;\n        dragTime.current = undefined;\n        touchNode.current = undefined;\n        touchNodeGroup.current = undefined;\n        event.evt.preventDefault();\n        event.evt.cancelBubble = true;\n        if (event.currentTarget) {\n            if (mouseDragging.current) {\n                setNewPositionForNode(node, shapeRefs.current[node.name], event.evt.changedTouches.length > 0 ? {\n                    x: event.evt.changedTouches[0].screenX,\n                    y: event.evt.changedTouches[0].screenY\n                } : undefined, false, false, true);\n            }\n            else {\n                selectedNode.selectNode(node.name, node);\n                canvasMode.setConnectiongNodeCanvasMode(false);\n            }\n        }\n        mouseDragging.current = false;\n        return false;\n    };\n    const onMouseConnectionStartOver = (node, nodeEvent, event) => {\n        if (node.notSelectable) {\n            return false;\n        }\n        document.body.style.cursor = 'pointer';\n    };\n    const onMouseConnectionStartOut = (node, nodeEvent, event) => {\n        document.body.style.cursor = 'default';\n    };\n    const onMouseConnectionStartStart = (node, nodeEvent, nodeEventName, followFlow, thumbPositionRelativeToNode, event) => {\n        if (isConnectingNodesByDraggingLocal.current) {\n            return false;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (node && touching.current && touchNode.current) {\n            return;\n        }\n        isConnectingNodesByDraggingLocal.current = true;\n        connectionNodeEvent.current = nodeEvent;\n        connectionNodeEventName.current = nodeEventName;\n        connectionNodeFollowFlow.current = followFlow;\n        connectionNodeThumbPositionRelativeToNode.current = thumbPositionRelativeToNode;\n        connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n        document.body.classList.add(\"connecting-nodes\");\n        touchNode.current = node;\n        touchNodeGroup.current = event.currentTarget;\n        const x = touchNodeGroup.current.attrs[\"x\"];\n        const y = touchNodeGroup.current.attrs[\"y\"];\n        let newPosition = {\n            x: 0,\n            y: 0\n        };\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stage) {\n                var touchPos = stageInstance.getPointerPosition();\n                const scaleFactor = stageInstance.scaleX();\n                newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\n                newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\n                connectionXStart.current = newPosition.x;\n                connectionYStart.current = newPosition.y;\n            }\n        }\n    };\n    const onMouseConnectionStartMove = (node, nodeEvent, event) => {\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (node && touching.current && touchNode.current) {\n            return;\n        }\n        event.evt.cancelBubble = true;\n    };\n    const onMouseConnectionStartEnd = (node, nodeEvent, thumbPositionRelativeToNode, event) => {\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (node && touching.current && touchNode.current) {\n            return;\n        }\n    };\n    const onMouseConnectionEndOver = (node, nodeEvent, event, thumbPositionRelativeToNode) => {\n        if (node.notSelectable) {\n            return false;\n        }\n        document.body.style.cursor = 'pointer';\n        if (thumbPositionRelativeToNode) {\n            connectionNodeThumbPositionRelativeToEndNode.current = thumbPositionRelativeToNode;\n        }\n        else {\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n        }\n    };\n    const onMouseConnectionEndOut = (node, nodeEvent, event) => {\n        document.body.style.cursor = 'default';\n    };\n    const onMouseConnectionEndStart = (node, nodeEvent, event) => {\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (node && touching.current && touchNode.current && !isConnectingNodesByDraggingLocal.current) {\n            return;\n        }\n    };\n    const onMouseConnectionEndMove = (node, nodeEvent, event) => {\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (node && touching.current && touchNode.current && !isConnectingNodesByDraggingLocal.current) {\n            return;\n        }\n    };\n    const onMouseConnectionEndEnd = (node, nodeEvent, event, thumbPositionRelativeToNode) => {\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (node && touching.current && touchNode.current && !isConnectingNodesByDraggingLocal.current) {\n            return;\n        }\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\n            connectConnectionToNode(node, thumbPositionRelativeToNode);\n        }\n    };\n    const onMouseConnectionEndLeave = (node, nodeEvent, event) => {\n    };\n    let draggingWhileTouching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const onDragStart = (node, event) => {\n        if (touching.current) {\n            draggingWhileTouching.current = true;\n            if (event.evt && event.evt.cancelBubble) {\n                event.evt.cancelBubble = true;\n            }\n            if (event && event.cancelBubble) {\n                event.cancelBubble = true;\n            }\n            return false;\n        }\n    };\n    const onDragMove = (node, event) => {\n        if (touching.current) {\n            draggingWhileTouching.current = true;\n            return false;\n        }\n        setNewPositionForNode(node, shapeRefs.current[node.name], false, false, true);\n    };\n    const onDragEnd = (node, event) => {\n        if (touching.current || draggingWhileTouching.current) {\n            draggingWhileTouching.current = false;\n            return false;\n        }\n        dragTime.current = undefined;\n        setNewPositionForNode(node, shapeRefs.current[node.name]);\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            stageInstance.batchDraw();\n        }\n        updateTouchedNodes();\n    };\n    const onClickShape = (node, event) => {\n        event.cancelBubble = true;\n        event.evt.preventDefault();\n        cancelDragStage();\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\n            connectConnectionToNode(node);\n            return false;\n        }\n        if ((!!canvasMode.isConnectingNodes || !!shiftDown.current) &&\n            selectedNode !== undefined &&\n            selectedNode.node !== undefined &&\n            selectedNode.node.shapeType !== \"Line\") {\n            const connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewConnection)(selectedNode.node, node, props.getNodeInstance, connectionNodeThumbPositionRelativeToNode.current);\n            if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.happyFlow) {\n                connection.followflow = \"onsuccess\";\n            }\n            else if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.unhappyFlow) {\n                connection.followflow = \"onfailure\";\n            }\n            flowStore.addConnection(connection);\n            canvasMode.setConnectiongNodeCanvasMode(false);\n        }\n        selectedNode.selectNode(node.name, node);\n        canvasMode.setConnectiongNodeCanvasMode(false);\n        return false;\n    };\n    const onClickLine = (node, event) => {\n        event.cancelBubble = true;\n        event.evt.preventDefault();\n        cancelDragStage();\n        if (node.notSelectable) {\n            return false;\n        }\n        canvasMode.setConnectiongNodeCanvasMode(false);\n        selectedNode.selectNode(node.name, node);\n        return false;\n    };\n    const onDragStageMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        if (isPinching.current) {\n            return;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (touching.current || draggingWhileTouching.current) {\n            if (event.target && event.target.stopDrag) {\n            }\n            if (event.evt && event.evt.cancelBubble) {\n                event.evt.cancelBubble = true;\n            }\n            if (event && event.cancelBubble) {\n                event.cancelBubble = true;\n            }\n            return false;\n        }\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                stageX.current = stageInstance.x();\n                stageY.current = stageInstance.y();\n                stageScale.current = stageInstance.scale().x;\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\n            }\n        }\n    }, [flowStore.flow]);\n    const onDragStageEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        if (isPinching.current) {\n            return;\n        }\n        if (!!canvasMode.isConnectingNodes) {\n            return false;\n        }\n        if (event.evt && event.evt.cancelBubble) {\n            event.evt.cancelBubble = true;\n        }\n        if (event && event.cancelBubble) {\n            event.cancelBubble = true;\n        }\n        if (touching.current || draggingWhileTouching.current) {\n            return false;\n        }\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                stageX.current = stageInstance.x();\n                stageY.current = stageInstance.y();\n                stageScale.current = stageInstance.scale().x;\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\n            }\n        }\n    }, [flowStore.flow]);\n    const setHtmlElementsPositionAndScale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((stageX, stageY, stageScale, newX, newY, node, repositionSingleNode) => {\n        flowStore.flow.map((flowNode) => {\n            if (flowNode.shapeType !== \"Line\") {\n                const element = elementRefs.current[flowNode.name];\n                if (element) {\n                    let x = parseFloat(element.getAttribute(\"data-x\") || \"\");\n                    let y = parseFloat(element.getAttribute(\"data-y\") || \"\");\n                    const clientElementHeight = element.clientHeight;\n                    if (node && element.getAttribute(\"data-node\") == node.name) {\n                        if (newX && !isNaN(newX)) {\n                            x = newX;\n                        }\n                        if (newY && !isNaN(newY)) {\n                            y = newY;\n                        }\n                        element.setAttribute(\"data-x\", x.toString());\n                        element.setAttribute(\"data-y\", y.toString());\n                    }\n                    const nodeName = element.getAttribute(\"data-node\") || \"\";\n                    setHtmlElementStyle(element, stageX, stageY, stageScale, x, y);\n                }\n            }\n        });\n    }, [flowStore.flow]);\n    const setHtmlElementStyle = (element, stageX, stageY, stageScale, x, y) => {\n        element.style.transform =\n            \"translate(\" + (stageX + x * stageScale) + \"px,\" +\n                (stageY + y * stageScale) + \"px) \" +\n                \"scale(\" + (stageScale) + \",\" + (stageScale) + \") \";\n    };\n    const fitStage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node, doBatchdraw, doSetHtmlElementsPositionAndScale) => {\n        let xMin;\n        let yMin;\n        let xMax;\n        let yMax;\n        let containsHtmlShape = false;\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance !== undefined) {\n                flowStore.flow.map((shape, index) => {\n                    if (node !== undefined) {\n                        if (node.id !== shape.id) {\n                            return;\n                        }\n                    }\n                    if (shape.shapeType != \"Line\") {\n                        const taskSettings = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getTaskSettings(shape.taskType);\n                        let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeTypeUsingSettings(shape.shapeType, shape.taskType, shape.isStartEnd, taskSettings);\n                        const RealShape = _shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes[shapeType];\n                        let addWidth = 0;\n                        let addHeight = 0;\n                        let subtractWidth = 0;\n                        let subtractHeight = 0;\n                        if (shapeType === \"Html\" && RealShape) {\n                            containsHtmlShape = true;\n                            let width = undefined;\n                            let height = undefined;\n                            if (props.getNodeInstance) {\n                                const instance = props.getNodeInstance(shape, props.flowrunnerConnector, flowStore.flow, taskSettings);\n                                if (instance) {\n                                    if (instance.getWidth && instance.getHeight) {\n                                        width = instance.getWidth(shape);\n                                        height = instance.getHeight(shape);\n                                    }\n                                }\n                            }\n                            let element = document.querySelector(\"#\" + shape.name + \" .html-plugin-node\");\n                            if (element) {\n                                const elementHeight = element.clientHeight;\n                                if (elementHeight > height) {\n                                    height = elementHeight;\n                                }\n                                const elementWidth = element.clientWidth;\n                                if (elementWidth > width) {\n                                    width = elementWidth;\n                                }\n                            }\n                            subtractWidth = 0;\n                            subtractHeight = 0;\n                            addWidth = (width || shape.width || 250);\n                            addHeight = (height || shape.height || 250);\n                        }\n                        else {\n                            addWidth = 100;\n                            addHeight = 50;\n                            if (shapeType === 'Circle') {\n                                addWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize;\n                                addHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize;\n                            }\n                            else if (shapeType === 'Diamond') {\n                                addWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize;\n                                addHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize;\n                            }\n                            else {\n                                addWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectWidht;\n                                addHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectHeight;\n                            }\n                        }\n                        if (xMin === undefined) {\n                            xMin = shape.x - subtractWidth;\n                        }\n                        if (yMin === undefined) {\n                            yMin = shape.y - subtractHeight;\n                        }\n                        if (xMax === undefined) {\n                            xMax = shape.x + addWidth;\n                        }\n                        if (yMax === undefined) {\n                            yMax = shape.y + addHeight;\n                        }\n                        if (shape.x - subtractWidth < xMin) {\n                            xMin = shape.x - subtractWidth;\n                        }\n                        if (shape.x + addWidth > xMax) {\n                            xMax = shape.x + addWidth;\n                        }\n                        if (shape.y - subtractHeight < yMin) {\n                            yMin = shape.y - subtractHeight;\n                        }\n                        if (shape.y + addHeight > yMax) {\n                            yMax = shape.y + addHeight;\n                        }\n                    }\n                });\n                if (flowStore.flow.length > 0 &&\n                    xMin !== undefined && yMin !== undefined && xMax !== undefined && yMax !== undefined) {\n                    let scale = 1;\n                    let flowWidth = Math.abs(xMax - xMin);\n                    let flowHeight = Math.abs(yMax - yMin);\n                    const stageContainerElement = document.querySelector(\"body .canvas-controller__scroll-container\");\n                    const bodyElement = document.querySelector(\"body\");\n                    if (stageContainerElement !== null && bodyElement !== null) {\n                        let subtractWidth = 128;\n                        if (stageContainerElement.clientWidth < 1024) {\n                            subtractWidth = 0;\n                        }\n                        let realStageWidth = stageContainerElement.clientWidth - subtractWidth;\n                        let realStageHeight = bodyElement.clientHeight - 64;\n                        if (realStageHeight < 500) {\n                        }\n                        if (flowStore.flow.length === 1) {\n                            scale = 1;\n                            if (stageContainerElement.clientWidth < 1024) {\n                                scale = 0.5;\n                            }\n                        }\n                        else {\n                            if (flowWidth !== 0) {\n                                scale = realStageWidth / flowWidth;\n                            }\n                            if (flowHeight * scale > realStageHeight) {\n                                scale = realStageHeight / flowHeight;\n                            }\n                            scale = scale * 0.7;\n                        }\n                        if (node !== undefined) {\n                            if (containsHtmlShape) {\n                                scale = scale * 0.5;\n                            }\n                            else {\n                                scale = scale * 0.15;\n                            }\n                        }\n                        stageInstance.scale({ x: scale, y: scale });\n                        const newPos = {\n                            x: 0,\n                            y: 0\n                        };\n                        let offsetX = 64;\n                        let stageWidth = stageContainerElement.clientWidth;\n                        let stageHeight = bodyElement.clientHeight;\n                        if (stageWidth < 1024) {\n                            offsetX = 0;\n                        }\n                        newPos.x = offsetX + (-(xMin) * scale) + (stageWidth) / 2 - ((flowWidth * scale)) / 2;\n                        newPos.y = (-(yMin) * scale) + (stageHeight + 64) / 2 - ((flowHeight * scale)) / 2;\n                        stageInstance.position(newPos);\n                        if (!!doBatchdraw) {\n                            stageInstance.batchDraw();\n                        }\n                        stageX.current = newPos.x;\n                        stageY.current = newPos.y;\n                        stageScale.current = scale;\n                        if (doSetHtmlElementsPositionAndScale === undefined || !!doSetHtmlElementsPositionAndScale) {\n                            setHtmlElementsPositionAndScale(newPos.x, newPos.y, scale);\n                        }\n                        setCanvasOpacity(1);\n                        console.log(\"fitStage realStageWidth realStageHeight flowHeight yMin yMax stageWidth stageHeight\", realStageWidth, realStageHeight, flowHeight, yMin, yMax, stageWidth, stageHeight);\n                    }\n                }\n                else {\n                    const newPos = {\n                        x: 0,\n                        y: 0\n                    };\n                    let scale = 1;\n                    const stageContainerElement = document.querySelector(\".canvas-controller__scroll-container\");\n                    if (stageContainerElement !== null) {\n                        if (stageContainerElement.clientWidth < 1024) {\n                            scale = 0.5;\n                        }\n                    }\n                    stageInstance.position(newPos);\n                    if (!!doBatchdraw) {\n                        stageInstance.batchDraw();\n                    }\n                    stageX.current = newPos.x;\n                    stageY.current = newPos.y;\n                    stageScale.current = scale;\n                    setHtmlElementsPositionAndScale(newPos.x, newPos.y, scale);\n                    setCanvasOpacity(1);\n                }\n            }\n        }\n    }, [flowStore.flow]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    }, [flowStore.flow]);\n    const clickStage = (event) => {\n        if (isConnectingNodesByDraggingLocal.current) {\n            event.evt.preventDefault();\n            isConnectingNodesByDraggingLocal.current = false;\n            connectionNodeEvent.current = false;\n            connectionNodeEventName.current = \"\";\n            connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n            connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default;\n            touchNode.current = undefined;\n            touchNodeGroup.current = undefined;\n            document.body.classList.remove(\"connecting-nodes\");\n            document.body.classList.remove(\"mouse--moving\");\n            const lineRef = shapeRefs.current[connectionForDraggingName];\n            if (lineRef) {\n                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n                if (stage && stage.current) {\n                    let stageInstance = stage.current.getStage();\n                    if (stageInstance !== undefined) {\n                        stageInstance.batchDraw();\n                    }\n                }\n            }\n            return false;\n        }\n        if (touchNode.current && touchNodeGroup.current) {\n            event.evt.preventDefault();\n            return false;\n        }\n        const nodeIsSelected = !!selectedNode && !!selectedNode.node;\n        if (!nodeIsSelected && canvasMode.selectedTask !== undefined &&\n            canvasMode.selectedTask !== \"\") {\n            if (!canvasMode.isConnectingNodes) {\n                if (stage && stage.current) {\n                    let stageInstance = stage.current.getStage();\n                    const position = stageInstance.getPointerPosition();\n                    const scaleFactor = stageInstance.scaleX();\n                    const taskType = canvasMode.selectedTask || \"TraceConsoleTask\";\n                    let presetValues = {};\n                    const shapeSetting = (0,_config__WEBPACK_IMPORTED_MODULE_7__.getTaskConfigForTask)(taskType);\n                    if (shapeSetting && shapeSetting.presetValues) {\n                        presetValues = shapeSetting.presetValues;\n                    }\n                    let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewNode)({\n                        name: canvasMode.selectedTask,\n                        id: canvasMode.selectedTask,\n                        taskType: taskType,\n                        shapeType: canvasMode.selectedTask == \"IfConditionTask\" ? \"Diamond\" : (shapeSetting.shapeType ? shapeSetting.shapeType : \"Rect\"),\n                        x: ((position.x - (stageInstance).x()) / scaleFactor),\n                        y: ((position.y - (stageInstance).y()) / scaleFactor),\n                        ...presetValues\n                    }, flowStore.flow);\n                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(newNode.taskType, newNode);\n                    let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeType(newNode.shapeType, newNode.taskType, newNode.isStartEnd);\n                    let centerXCorrection = 0;\n                    let centerYCorrection = 0;\n                    if (shapeType == \"Rect\" || shapeType == \"Ellipse\") {\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectWidht / 2;\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectHeight / 2;\n                    }\n                    else if (shapeType == \"Circle\") {\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize / 2;\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize / 2;\n                    }\n                    else if (shapeType == \"Diamond\") {\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize / 2;\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize / 2;\n                    }\n                    newNode.x = newNode.x - centerXCorrection;\n                    newNode.y = newNode.y - centerYCorrection;\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\n                    if (lineRef) {\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n                        if (stage && stage.current) {\n                            let stageInstance = stage.current.getStage();\n                            if (stageInstance !== undefined) {\n                                stageInstance.batchDraw();\n                            }\n                        }\n                    }\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\n                        x: newNode.x,\n                        y: newNode.y\n                    });\n                    flowStore.addFlowNode(newNode);\n                }\n            }\n        }\n        selectedNode.selectNode(\"\", undefined);\n        canvasMode.setConnectiongNodeCanvasMode(false);\n        canvasMode.setSelectedTask(\"\");\n        return false;\n    };\n    const getNodeByName = (nodeName) => {\n        const nodes = flowStore.flow.filter((node, index) => {\n            return node.name === nodeName;\n        });\n        if (nodes.length > 0) {\n            return nodes[0];\n        }\n        return null;\n    };\n    const getNodeByVariableName = (nodeName) => {\n        const nodes = flowStore.flow.filter((node, index) => {\n            return node.variableName === nodeName && node.taskType;\n        });\n        if (nodes.length > 0) {\n            return nodes[0];\n        }\n        return null;\n    };\n    const getDependentConnections = () => {\n        const nodeIsSelected = !!selectedNode && !!selectedNode.node;\n        try {\n            let connections = [];\n            flowStore.flow.map((node, index) => {\n                if (node.shapeType !== \"Line\") {\n                    const nodeJson = JSON.stringify(node);\n                    let nodeMatches = nodeJson.match(/(\"node\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    const getVariableNodeMatches = nodeJson.match(/(\"getVariable\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (getVariableNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(getVariableNodeMatches);\n                        }\n                        else {\n                            nodeMatches = getVariableNodeMatches;\n                        }\n                    }\n                    const setVariableNodeMatches = nodeJson.match(/(\"setVariable\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (setVariableNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(setVariableNodeMatches);\n                        }\n                        else {\n                            nodeMatches = setVariableNodeMatches;\n                        }\n                    }\n                    const datasourceNodeMatches = nodeJson.match(/(\"datasourceNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (datasourceNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(datasourceNodeMatches);\n                        }\n                        else {\n                            nodeMatches = datasourceNodeMatches;\n                        }\n                    }\n                    const functionCallNodeMatches = nodeJson.match(/(\"functionnodeid\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (functionCallNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(functionCallNodeMatches);\n                        }\n                        else {\n                            nodeMatches = functionCallNodeMatches;\n                        }\n                    }\n                    const detailNodeMatches = nodeJson.match(/(\"detailNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (detailNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(detailNodeMatches);\n                        }\n                        else {\n                            nodeMatches = detailNodeMatches;\n                        }\n                    }\n                    const deleteNodeMatches = nodeJson.match(/(\"deleteNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (deleteNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(deleteNodeMatches);\n                        }\n                        else {\n                            nodeMatches = deleteNodeMatches;\n                        }\n                    }\n                    const listFromNodeMatches = nodeJson.match(/(\"useListFromNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                    if (listFromNodeMatches) {\n                        if (nodeMatches) {\n                            nodeMatches = nodeMatches.concat(listFromNodeMatches);\n                        }\n                        else {\n                            nodeMatches = listFromNodeMatches;\n                        }\n                    }\n                    if (node.taskType && node.taskType.indexOf(\"Type\") < 0) {\n                        const variableNodeMatches = nodeJson.match(/(\"variableName\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\n                        if (variableNodeMatches) {\n                            if (nodeMatches) {\n                                nodeMatches = nodeMatches.concat(variableNodeMatches);\n                            }\n                            else {\n                                nodeMatches = variableNodeMatches;\n                            }\n                        }\n                    }\n                    if (nodeMatches) {\n                        nodeMatches.map((match, index) => {\n                            let isNodeByName = match.indexOf('\"node\":') >= 0;\n                            let isGetVariable = match.indexOf('\"getVariable\":') >= 0;\n                            let isSetVariable = match.indexOf('\"setVariable\":') >= 0;\n                            let isFunctionCall = match.indexOf('\"functionnodeid\":') >= 0;\n                            let isUseListFromNode = match.indexOf('\"useListFromNode\":') >= 0;\n                            isNodeByName = isNodeByName || isUseListFromNode || isFunctionCall;\n                            let nodeName = match.replace('\"node\":', \"\");\n                            nodeName = nodeName.replace('\"variableName\":', \"\");\n                            nodeName = nodeName.replace('\"getVariable\":', \"\");\n                            nodeName = nodeName.replace('\"setVariable\":', \"\");\n                            nodeName = nodeName.replace('\"datasourceNode\":', \"\");\n                            nodeName = nodeName.replace('\"functionnodeid\":', \"\");\n                            nodeName = nodeName.replace('\"detailNode\":', \"\");\n                            nodeName = nodeName.replace('\"deleteNode\":', \"\");\n                            nodeName = nodeName.replace('\"useListFromNode\":', \"\");\n                            nodeName = nodeName.replace(/\\ /g, \"\");\n                            nodeName = nodeName.replace(/\\\"/g, \"\");\n                            let nodeEnd;\n                            let startToEnd = true;\n                            let isConnectionWithVariable = false;\n                            if (isNodeByName && !isGetVariable && !isSetVariable) {\n                                nodeEnd = getNodeByName(nodeName);\n                                if (nodeEnd && !!nodeEnd.hasVariableAttached) {\n                                    isConnectionWithVariable = true;\n                                }\n                                if (nodeEnd && nodeEnd.variableName && node.getVariable) {\n                                    nodeEnd = undefined;\n                                }\n                            }\n                            if (isGetVariable || isSetVariable) {\n                                nodeEnd = getNodeByVariableName(nodeName);\n                                if (nodeEnd) {\n                                    isConnectionWithVariable = true;\n                                }\n                                if (isGetVariable) {\n                                    startToEnd = false;\n                                }\n                            }\n                            if (nodeEnd) {\n                                let startPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(node, { x: node.x, y: node.y }, undefined, props.getNodeInstance);\n                                let endPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getEndPointForLine(nodeEnd, { x: nodeEnd.x, y: nodeEnd.y }, undefined, props.getNodeInstance);\n                                if (!startToEnd) {\n                                    startPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(nodeEnd, { x: nodeEnd.x, y: nodeEnd.y }, undefined, props.getNodeInstance);\n                                    endPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getEndPointForLine(node, { x: node.x, y: node.y }, undefined, props.getNodeInstance);\n                                }\n                                let connection = {\n                                    shapeType: \"Line\",\n                                    name: \"_dc\" + index,\n                                    id: \"_dc\" + index,\n                                    xstart: startPosition.x,\n                                    ystart: startPosition.y,\n                                    xend: endPosition.x,\n                                    yend: endPosition.y,\n                                    notSelectable: true,\n                                    startshapeid: (startToEnd ? node.name : nodeEnd.name),\n                                    endshapeid: (startToEnd ? nodeEnd.name : node.name),\n                                    isConnectionWithVariable: isConnectionWithVariable || isFunctionCall\n                                };\n                                connections.push(connection);\n                            }\n                        });\n                    }\n                }\n            });\n            return connections;\n        }\n        catch (err) {\n            console.log(err);\n            return [];\n        }\n    };\n    const onDropTask = (event) => {\n        event.preventDefault();\n        let taskClassName = event.dataTransfer.getData(\"data-task\");\n        addTaskToCanvas(taskClassName);\n    };\n    const addTaskToCanvas = (taskClassName) => {\n        if (stage && stage.current) {\n            let _stage = stage.current.getStage();\n            _stage.setPointersPositions(event);\n            const nodeIsSelected = !!selectedNode && !!selectedNode.node;\n            selectedNode.selectNode(\"\", undefined);\n            canvasMode.setConnectiongNodeCanvasMode(false);\n            if (taskClassName && taskClassName !== \"\") {\n                if (!canvasMode.isConnectingNodes) {\n                    if (stage && stage.current) {\n                        let stageInstance = stage.current.getStage();\n                        const position = stageInstance.getPointerPosition();\n                        const scaleFactor = stageInstance.scaleX();\n                        const taskType = taskClassName;\n                        let presetValues = {};\n                        const shapeSetting = (0,_config__WEBPACK_IMPORTED_MODULE_7__.getTaskConfigForTask)(taskType);\n                        if (shapeSetting && shapeSetting.presetValues) {\n                            presetValues = shapeSetting.presetValues;\n                        }\n                        let element = document.querySelector(\".taskbar__task-dragging\");\n                        let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewNode)({\n                            name: taskClassName,\n                            id: taskClassName,\n                            taskType: taskType,\n                            shapeType: taskClassName == \"IfConditionTask\" ? \"Diamond\" : (shapeSetting.shapeType ? shapeSetting.shapeType : \"Rect\"),\n                            x: (position.x - (_stage).x()) / scaleFactor,\n                            y: (position.y - (_stage).y()) / scaleFactor,\n                            ...presetValues\n                        }, flowStore.flow);\n                        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(newNode.taskType, newNode);\n                        let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeType(newNode.shapeType, newNode.taskType, newNode.isStartEnd);\n                        if (shapeType == \"Html\" && element) {\n                            let rect = element.getBoundingClientRect();\n                            if (props.getNodeInstance) {\n                                const left = Math.round((rect.left + rect.right) / 2);\n                                let result = props.getNodeInstance(newNode, props.flowrunnerConnector, undefined, settings);\n                                if (result && result.getWidth) {\n                                    newNode.x = (left - (_stage).x()) / scaleFactor;\n                                    newNode.y = (rect.top - (_stage).y()) / scaleFactor;\n                                    newNode.x -= (result.getWidth(newNode) || newNode.width || 250) / 2;\n                                }\n                            }\n                        }\n                        let centerXCorrection = 0;\n                        let centerYCorrection = 0;\n                        if (shapeType == \"Rect\" || shapeType == \"Ellipse\") {\n                            centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectWidht / 2;\n                            centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.rectHeight / 2;\n                        }\n                        else if (shapeType == \"Circle\") {\n                            centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize / 2;\n                            centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.circleSize / 2;\n                        }\n                        else if (shapeType == \"Diamond\") {\n                            centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize / 2;\n                            centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_12__.ShapeMeasures.diamondSize / 2;\n                        }\n                        newNode.x = newNode.x - centerXCorrection;\n                        newNode.y = newNode.y - centerYCorrection;\n                        const lineRef = shapeRefs.current[connectionForDraggingName];\n                        if (lineRef) {\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n                            if (stage && stage.current) {\n                                let stageInstance = stage.current.getStage();\n                                if (stageInstance !== undefined) {\n                                    stageInstance.batchDraw();\n                                }\n                            }\n                        }\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\n                            x: newNode.x,\n                            y: newNode.y\n                        });\n                        flowStore.addFlowNode(newNode);\n                        let closestNode = closestNodeWhenAddingNewNode.current;\n                        if (closestNode) {\n                            let connection;\n                            const orientationIsLeft = orientationClosestNodeWhenAddingNewNode.current;\n                            if (orientationIsLeft && closestNode.shapeType !== \"Diamond\") {\n                                connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewConnection)(closestNode, newNode, props.getNodeInstance, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                            }\n                            else {\n                                if (nodeOrientationClosestNodeWhenAddingNewNode.current === _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default) {\n                                    connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewConnection)(newNode, closestNode, props.getNodeInstance, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                                }\n                                else {\n                                    connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_11__.getNewConnection)(closestNode, newNode, props.getNodeInstance, false, nodeOrientationClosestNodeWhenAddingNewNode.current);\n                                    if (nodeOrientationClosestNodeWhenAddingNewNode.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top) {\n                                        connection.followflow = \"onsuccess\";\n                                    }\n                                    else {\n                                        connection.followflow = \"onfailure\";\n                                    }\n                                    connection.thumbPosition = nodeOrientationClosestNodeWhenAddingNewNode.current;\n                                }\n                            }\n                            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connection.name, {\n                                xstart: connection.xstart,\n                                ystart: connection.ystart,\n                                xend: connection.xend,\n                                yend: connection.yend\n                            });\n                            flowStore.addConnection(connection);\n                        }\n                    }\n                }\n            }\n            else {\n                alert(\"select task!!\");\n            }\n        }\n        return false;\n    };\n    const getDistance = (node, position) => {\n        const x = node.x - position.x;\n        const y = node.y - position.y;\n        return Math.sqrt(x * x + y * y);\n    };\n    const onAllowDrop = (event) => {\n        event.preventDefault();\n        movingTaskToCanvas(event.clientX, event.clientY);\n    };\n    const movingTaskToCanvas = (dropX, dropY) => {\n        if (stage && stage.current) {\n            let stageInstance = stage.current.getStage();\n            if (stageInstance) {\n                const scaleFactor = stageInstance.scaleX();\n                let position = {\n                    x: 0,\n                    y: 0\n                };\n                position.x = ((dropX - (stageInstance).x()) / scaleFactor);\n                position.y = ((dropY - (stageInstance).y()) / scaleFactor);\n                const minDistanceForAutoConnect = 750;\n                let minDistance = -1;\n                let closestNode;\n                let orientationIsLeft = false;\n                let nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n                closestNodeWhenAddingNewNode.current = undefined;\n                nodeOrientationClosestNodeWhenAddingNewNode.current = nodeOrientation;\n                flowStore.flow.forEach((node) => {\n                    if (node.shapeType !== 'Line') {\n                        const nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\n                        const rightPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(node, {\n                            x: nodePosition.x,\n                            y: nodePosition.y\n                        }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                        const leftPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getEndPointForLine(node, {\n                            x: nodePosition.x,\n                            y: nodePosition.y\n                        }, undefined, props.getNodeInstance);\n                        let distanceTop = -1;\n                        let distanceBottom = -1;\n                        if (node.shapeType === \"Diamond\") {\n                            const topPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(node, {\n                                x: nodePosition.x,\n                                y: nodePosition.y\n                            }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top);\n                            const bottomosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(node, {\n                                x: nodePosition.x,\n                                y: nodePosition.y\n                            }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom);\n                            distanceTop = getDistance(position, topPosition);\n                            distanceBottom = getDistance(position, bottomosition);\n                        }\n                        const distanceLeft = getDistance(position, leftPosition);\n                        const distanceRight = getDistance(position, rightPosition);\n                        if (minDistance == -1 || distanceLeft < minDistance) {\n                            if (distanceLeft < minDistanceForAutoConnect) {\n                                minDistance = distanceLeft;\n                                closestNode = node;\n                                orientationIsLeft = false;\n                                nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n                            }\n                        }\n                        if (distanceTop >= 0 && (minDistance == -1 || distanceTop < minDistance)) {\n                            if (distanceTop < minDistanceForAutoConnect) {\n                                minDistance = distanceTop;\n                                closestNode = node;\n                                orientationIsLeft = false;\n                                nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top;\n                            }\n                        }\n                        if (distanceBottom >= 0 && (minDistance == -1 || distanceBottom < minDistance)) {\n                            if (distanceBottom < minDistanceForAutoConnect) {\n                                minDistance = distanceBottom;\n                                closestNode = node;\n                                orientationIsLeft = false;\n                                nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom;\n                            }\n                        }\n                        if (node.shapeType !== \"Diamond\") {\n                            if (minDistance == -1 || distanceRight < minDistance) {\n                                if (distanceRight < minDistanceForAutoConnect) {\n                                    minDistance = distanceRight;\n                                    closestNode = node;\n                                    orientationIsLeft = true;\n                                    nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n                                }\n                            }\n                        }\n                    }\n                });\n                if (closestNode) {\n                    closestNodeWhenAddingNewNode.current = closestNode;\n                    orientationClosestNodeWhenAddingNewNode.current = orientationIsLeft;\n                    nodeOrientationClosestNodeWhenAddingNewNode.current = nodeOrientation;\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\n                    if (lineRef) {\n                        let thumbPosition = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default;\n                        let lineStartPosition;\n                        const nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(closestNode.name);\n                        if (closestNode.shapeType === \"Diamond\" && nodeOrientation !== _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default) {\n                            lineStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(closestNode, {\n                                x: nodePosition.x,\n                                y: nodePosition.y\n                            }, undefined, props.getNodeInstance, nodeOrientation);\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_15__.calculateLineControlPoints)(lineStartPosition.x, lineStartPosition.y, position.x, position.y, nodeOrientation);\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetPoints, { points: [lineStartPosition.x, lineStartPosition.y,\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\n                                    position.x, position.y] });\n                        }\n                        else if (orientationIsLeft) {\n                            lineStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getStartPointForLine(closestNode, {\n                                x: nodePosition.x,\n                                y: nodePosition.y\n                            }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_15__.calculateLineControlPoints)(lineStartPosition.x, lineStartPosition.y, position.x, position.y, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetPoints, { points: [lineStartPosition.x, lineStartPosition.y,\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\n                                    position.x, position.y] });\n                        }\n                        else {\n                            lineStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getEndPointForLine(closestNode, {\n                                x: nodePosition.x,\n                                y: nodePosition.y\n                            }, undefined, props.getNodeInstance);\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_15__.calculateLineControlPoints)(position.x, position.y, lineStartPosition.x, lineStartPosition.y, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default);\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetPoints, { points: [position.x, position.y,\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\n                                    lineStartPosition.x, lineStartPosition.y] });\n                        }\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\n                        stageInstance.batchDraw();\n                    }\n                }\n                else {\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\n                    if (lineRef) {\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\n                        stageInstance.batchDraw();\n                    }\n                }\n            }\n        }\n    };\n    const onInput = (event) => {\n        if (event.target && (event.target.tagName || \"\").toLowerCase() == \"input\") {\n            return;\n        }\n        if (event.target && (event.target.tagName || \"\").toLowerCase() == \"textarea\") {\n            return;\n        }\n        if (event.target && event.target.attributes && event.target.attributes[\"role\"]\n            && event.target.attributes[\"role\"].value == \"textbox\") {\n            return;\n        }\n        console.log(\"oninput\", event);\n        if (event.keyCode == shiftKey) {\n            shiftDown.current = true;\n            return true;\n        }\n        if (event.keyCode == ctrlKey || event.keyCode == cmdKey) {\n            ctrlDown.current = true;\n            return true;\n        }\n        if (!!ctrlDown.current && event.keyCode == pasteKey) {\n            return true;\n        }\n    };\n    const onKeyUp = (event) => {\n        ctrlDown.current = false;\n        shiftDown.current = false;\n    };\n    const onStoreFlowNode = (node, orgNodeName) => {\n        flowStore.storeFlowNode(node, orgNodeName);\n    };\n    const handleDragStart = (event) => {\n        setActiveId(event.active.id);\n    };\n    const handleDragEnd = (event) => {\n        if (activeId) {\n            addTaskToCanvas(activeId);\n        }\n        setActiveId(undefined);\n    };\n    const handleDragMove = (event) => {\n        let element = document.querySelector(\".taskbar__task-dragging\");\n        if (element) {\n            let rect = element.getBoundingClientRect();\n            movingTaskToCanvas(Math.round((rect.left + rect.right) / 2), Math.round((rect.top + rect.bottom) / 2));\n        }\n    };\n    const canvasHasSelectedNode = !!selectedNode && !!selectedNode.node;\n    const connections = canvasMode.showDependencies ? getDependentConnections() : [];\n    let nodesConnectedToSelectedNode = {};\n    const flowMemo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return flowStore.flow;\n    }, [flowStore.flow]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_dnd_kit_core__WEBPACK_IMPORTED_MODULE_9__.DndContext, { id: \"canvas-dndcontext\", modifiers: [_dnd_kit_modifiers__WEBPACK_IMPORTED_MODULE_26__.restrictToWindowEdges], onDragStart: handleDragStart, onDragMove: handleDragMove, onDragEnd: handleDragEnd },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Taskbar__WEBPACK_IMPORTED_MODULE_25__.Taskbar, { flowrunnerConnector: props.flowrunnerConnector, isDragging: activeId !== undefined }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_dnd_kit_core__WEBPACK_IMPORTED_MODULE_9__.DragOverlay, { className: \"taskbar__task-dragging\", zIndex: 20000, dropAnimation: null }, activeId ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(_dragging_task__WEBPACK_IMPORTED_MODULE_10__.DragginTask, { id: activeId, style: {}, children: {}, listeners: {} }) : null),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"stage-layer-wrapper-\" + canvasKey, ref: ref => (canvasWrapper.current = ref), style: { opacity: canvasOpacity }, className: \"canvas-controller__scroll-container\", tabIndex: 0, onInput: onInput, onKeyDown: onInput, onKeyUp: onKeyUp, onWheel: wheelEvent },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_helpers_error__WEBPACK_IMPORTED_MODULE_27__.ErrorBoundary, null,\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: setNodeRef, style: droppableStyle },\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Stage, { onClick: clickStage, draggable: true, pixelRatio: 1, width: stageWidth, height: stageHeight, ref: ref => (stage.current = ref), onDragMove: onDragStageMove, onDragEnd: onDragStageEnd, onTouchStart: onStageTouchStart, onTouchMove: onStageTouchMove, onMouseMove: onStageTouchMove, onTouchEnd: onStageMouseEnd, onMouseLeave: onStageMouseLeave, onMouseUp: onStageMouseEnd, onTap: clickStage, className: \"stage-container\" },\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Layer, { key: \"stage-layer-\" + canvasKey, ref: ref => (layer.current = ref) },\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect, { x: 0, y: 0, width: 1024, height: 750 }),\n                                connections.length > 0 && connections.map((node, index) => {\n                                    if (canvasHasSelectedNode && selectedNode && selectedNode.node) {\n                                        if (node.startshapeid === selectedNode.node.name) {\n                                            nodesConnectedToSelectedNode[node.endshapeid] = true;\n                                        }\n                                        if (node.endshapeid === selectedNode.node.name) {\n                                            nodesConnectedToSelectedNode[node.startshapeid] = true;\n                                        }\n                                    }\n                                    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes.Line, { key: \"cn-node-\" + index, onMouseOver: (event) => onMouseOver(node, event), onMouseOut: (event) => onMouseOut(), onClickLine: (event) => onClickLine(node, event), isSelected: false, isAltColor: true, canvasHasSelectedNode: canvasHasSelectedNode, isConnectionWithVariable: node.isConnectionWithVariable, xstart: node.xstart, ystart: node.ystart, xend: node.xend, yend: node.yend, selectedNodeName: canvasHasSelectedNode ? selectedNode.node.name : \"\", startNodeName: node.startshapeid, endNodeName: node.endshapeid, noMouseEvents: true });\n                                }),\n                                flowMemo.map((node, index) => {\n                                    if (node.shapeType !== \"Line\") {\n                                        let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\n                                        if (!position) {\n                                            if (node.shapeType !== \"Line\") {\n                                                (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\n                                                    x: node.x,\n                                                    y: node.y\n                                                });\n                                            }\n                                            else {\n                                                (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\n                                                    xstart: node.xstart,\n                                                    ystart: node.ystart,\n                                                    xend: node.xend,\n                                                    yend: node.yend\n                                                });\n                                            }\n                                            position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\n                                        }\n                                        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_lines_for_shape__WEBPACK_IMPORTED_MODULE_3__.LinesForShape, { key: \"node-linshahe-\" + index, x: position.x, y: position.y, name: node.name, flow: flowMemo, taskType: node.taskType, node: node, flowHash: flowStore.flowHashmap, shapeRefs: shapeRefs, positions: _services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition, canvasHasSelectedNode: canvasHasSelectedNode, nodeState: \"\", selectedNode: selectedNode, onLineMouseOver: onMouseOver, onLineMouseOut: onMouseOut, onClickLine: onClickLine, onClickSetup: undefined, onMouseOver: (event) => onMouseOver(node, event), onMouseOut: onMouseOut, onDragStart: (event) => onDragStart(node, event), onDragEnd: (event) => onDragEnd(node, event), onDragMove: (event) => onDragMove(node, event), onTouchStart: (event) => onTouchStart(node, event), onTouchEnd: (event) => onTouchEnd(node, event), onTouchMove: (event) => onTouchMove(node, event), onClickShape: (event) => onClickShape(node, event), onMouseStart: (event) => onMouseStart(node, event), onMouseMove: (event) => onMouseMove(node, event), onMouseEnd: (event) => onMouseEnd(node, event), onMouseLeave: (event) => onMouseLeave(node, event), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: false, getNodeInstance: props.getNodeInstance, touchedNodes: touchedNodesStore.nodesTouched });\n                                    }\n                                    return null;\n                                }),\n                                flowMemo.map((node, index) => {\n                                    let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeType(node.shapeType, node.taskType, node.isStartEnd);\n                                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(node.taskType, node);\n                                    const Shape = _shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes[shapeType];\n                                    let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\n                                    if (!position) {\n                                        if (node.shapeType !== \"Line\") {\n                                            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\n                                                x: node.x,\n                                                y: node.y\n                                            });\n                                        }\n                                        else {\n                                            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\n                                                xstart: node.xstart,\n                                                ystart: node.ystart,\n                                                xend: node.xend,\n                                                yend: node.yend\n                                            });\n                                        }\n                                        position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\n                                    }\n                                    if (node.shapeType !== \"Line\" && Shape) {\n                                        let nodeState = \"\";\n                                        nodeState = nodesStateLocal.current[node.name] || \"\";\n                                        let isConnectedToSelectedNode = selectedNode && nodesConnectedToSelectedNode[node.name] === true;\n                                        if (selectedNode &&\n                                            selectedNode.node &&\n                                            selectedNode.node.shapeType === \"Line\") {\n                                            if (selectedNode.node.startshapeid === node.name) {\n                                                isConnectedToSelectedNode = true;\n                                            }\n                                            if (selectedNode.node.endshapeid === node.name) {\n                                                isConnectedToSelectedNode = true;\n                                            }\n                                        }\n                                        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: \"node-fragment-\" + index },\n                                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Shape, { key: \"node-\" + index, x: position.x, y: position.y, name: node.name, flow: flowMemo, taskType: node.taskType, node: node, ref: ref => (shapeRefs.current[node.name] = ref), shapeRefs: shapeRefs, positions: _services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition, canvasHasSelectedNode: canvasHasSelectedNode, nodeState: nodeState, selectedNode: selectedNode, onLineMouseOver: onMouseOver, onLineMouseOut: onMouseOut, onClickLine: onClickLine, onClickSetup: (event) => onClickSetup(node, settings, event), onMouseOver: (event) => onMouseOver(node, event), onMouseOut: onMouseOut, onDragStart: (event) => onDragStart(node, event), onDragEnd: (event) => onDragEnd(node, event), onDragMove: (event) => onDragMove(node, event), onTouchStart: (event) => onTouchStart(node, event), onTouchEnd: (event) => onMouseEnd(node, event), onTouchMove: (event) => onMouseMove(node, event), onClickShape: (event) => onClickShape(node, event), onMouseStart: (event) => onMouseStart(node, event), onMouseMove: (event) => onMouseMove(node, event), onMouseEnd: (event) => onMouseEnd(node, event), onMouseLeave: (event) => onMouseLeave(node, event), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, getNodeInstance: props.getNodeInstance, touchedNodes: touchedNodesStore.nodesTouched }),\n                                            (shapeType === \"Rect\" || (shapeType === \"Diamond\" && !settings.altThumbPositions) || shapeType === \"Html\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbs__WEBPACK_IMPORTED_MODULE_4__.Thumbs, { key: \"node-thumb-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbEndPosition(shapeType, position), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumb_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, onMouseConnectionEndOver: (event) => onMouseConnectionEndOver(node, false, event), onMouseConnectionEndOut: (event) => onMouseConnectionEndOut(node, false, event), onMouseConnectionEndStart: (event) => onMouseConnectionEndStart(node, false, event), onMouseConnectionEndMove: (event) => onMouseConnectionEndMove(node, false, event), onMouseConnectionEndEnd: (event) => onMouseConnectionEndEnd(node, false, event), onMouseConnectionEndLeave: (event) => onMouseConnectionEndLeave(node, false, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Diamond\" && settings.altThumbPositions === 1) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbs__WEBPACK_IMPORTED_MODULE_4__.Thumbs, { key: \"node-thumb-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbEndPosition(shapeType, position, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumb_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, thumbPositionRelativeToNode: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top, onMouseConnectionEndOver: (event) => onMouseConnectionEndOver(node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top), onMouseConnectionEndOut: (event) => onMouseConnectionEndOut(node, false, event), onMouseConnectionEndStart: (event) => onMouseConnectionEndStart(node, false, event), onMouseConnectionEndMove: (event) => onMouseConnectionEndMove(node, false, event), onMouseConnectionEndEnd: (event) => onMouseConnectionEndEnd(node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top), onMouseConnectionEndLeave: (event) => onMouseConnectionEndLeave(node, false, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Rect\" || shapeType === \"Html\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_5__.ThumbsStart, { key: \"node-thumbstart-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumbstart_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, onMouseConnectionStartOver: (event) => onMouseConnectionStartOver(node, false, event), onMouseConnectionStartOut: (event) => onMouseConnectionStartOut(node, false, event), onMouseConnectionStartStart: (event) => onMouseConnectionStartStart(node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, event), onMouseConnectionStartMove: (event) => onMouseConnectionStartMove(node, false, event), onMouseConnectionStartEnd: (event) => onMouseConnectionStartEnd(node, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Html\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_5__.ThumbsStart, { key: \"node-thumbstartbottom-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumbstartbottom_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, thumbPositionRelativeToNode: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom, onMouseConnectionStartOver: (event) => onMouseConnectionStartOver(node, false, event), onMouseConnectionStartOut: (event) => onMouseConnectionStartOut(node, false, event), onMouseConnectionStartStart: (event) => onMouseConnectionStartStart(node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom, event), onMouseConnectionStartMove: (event) => onMouseConnectionStartMove(node, false, event), onMouseConnectionStartEnd: (event) => onMouseConnectionStartEnd(node, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Html\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbs__WEBPACK_IMPORTED_MODULE_4__.Thumbs, { key: \"node-thumbend-html-top-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbEndPosition(shapeType, position, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumbtop_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, thumbPositionRelativeToNode: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top, onMouseConnectionEndOver: (event) => onMouseConnectionEndOver(node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top), onMouseConnectionEndOut: (event) => onMouseConnectionEndOut(node, false, event), onMouseConnectionEndStart: (event) => onMouseConnectionEndStart(node, false, event), onMouseConnectionEndMove: (event) => onMouseConnectionEndMove(node, false, event), onMouseConnectionEndEnd: (event) => onMouseConnectionEndEnd(node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top), onMouseConnectionEndLeave: (event) => onMouseConnectionEndLeave(node, false, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Diamond\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_5__.ThumbsStart, { key: \"node-thumbstart-diamond-top-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.left), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumbstarttop_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, followFlow: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.happyFlow, thumbPositionRelativeToNode: !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.left, onMouseConnectionStartOver: (event) => onMouseConnectionStartOver(node, false, event), onMouseConnectionStartOut: (event) => onMouseConnectionStartOut(node, false, event), onMouseConnectionStartStart: (event) => onMouseConnectionStartStart(node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.happyFlow, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.left, event), onMouseConnectionStartMove: (event) => onMouseConnectionStartMove(node, false, event), onMouseConnectionStartEnd: (event) => onMouseConnectionStartEnd(node, false, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.left, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Diamond\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_5__.ThumbsStart, { key: \"node-thumbstart-diamond-bottom-\" + index, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.right), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumbstartbottom_\" + node.name] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, followFlow: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.unhappyFlow, thumbPositionRelativeToNode: !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.right, onMouseConnectionStartOver: (event) => onMouseConnectionStartOver(node, false, event), onMouseConnectionStartOut: (event) => onMouseConnectionStartOut(node, false, event), onMouseConnectionStartStart: (event) => onMouseConnectionStartStart(node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.unhappyFlow, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.right, event), onMouseConnectionStartMove: (event) => onMouseConnectionStartMove(node, false, event), onMouseConnectionStartEnd: (event) => onMouseConnectionStartEnd(node, false, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.right, event), getNodeInstance: props.getNodeInstance }),\n                                            (shapeType === \"Rect\" || shapeType === \"Html\") && settings.events && settings.events.map((event, eventIndex) => {\n                                                return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_5__.ThumbsStart, { key: \"node-thumbstart-\" + index + \"-\" + eventIndex, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getThumbStartPosition(shapeType, position, eventIndex + 1), name: node.name, taskType: node.taskType, shapeType: shapeType, node: node, ref: ref => (shapeRefs.current[\"thumbstartevent_\" + node.name + eventIndex] = ref), isSelected: selectedNode && selectedNode.node.name === node.name, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: canvasHasSelectedNode, onMouseConnectionStartOver: (event) => onMouseConnectionStartOver(node, eventIndex, event), onMouseConnectionStartOut: (event) => onMouseConnectionStartOut(node, eventIndex, event), onMouseConnectionStartStart: (event) => onMouseConnectionStartStart(node, eventIndex, event.eventName, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbFollowFlow.event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, event), onMouseConnectionStartMove: (event) => onMouseConnectionStartMove(node, eventIndex, event), onMouseConnectionStartEnd: (event) => onMouseConnectionStartEnd(node, eventIndex, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_13__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance });\n                                            }));\n                                    }\n                                    return null;\n                                }),\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes.Line, { ref: ref => (shapeRefs.current[connectionForDraggingName] = ref), onMouseOver: undefined, onMouseOut: undefined, onClickLine: undefined, isSelected: false, isAltColor: true, canvasHasSelectedNode: canvasHasSelectedNode, isConnectionWithVariable: false, xstart: connectionX, ystart: connectionY, xend: connectionX, yend: connectionY, selectedNodeName: \"\", startNodeName: \"\", endNodeName: \"\", opacity: 0, noMouseEvents: true, isNodeConnectorHelper: true }))))),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: ref => (htmlWrapper.current = ref), className: \"canvas__html-elements\" }, flowMemo.map((node, index) => {\n                    let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_6__.FlowToCanvas.getShapeType(node.shapeType, node.taskType, node.isStartEnd);\n                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_8__.ShapeSettings.getShapeSettings(node.taskType, node);\n                    const Shape = _shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes[shapeType];\n                    if (shapeType === \"Html\" && Shape) {\n                        const nodeClone = { ...node };\n                        const position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name) || node;\n                        let nodeState = (nodesStateLocal.current[node.name] || \"\") == \"error\" ? \" has-error\" : \"\";\n                        const isSelected = selectedNode && selectedNode.node.name === node.name;\n                        nodeClone.htmlPlugin = node.htmlPlugin || settings.htmlPlugin || \"\";\n                        let width = undefined;\n                        let height = undefined;\n                        if (props.getNodeInstance) {\n                            const instance = props.getNodeInstance(node, props.flowrunnerConnector, flowStore.flow, settings);\n                            if (instance) {\n                                if (instance.getWidth && instance.getHeight) {\n                                    width = instance.getWidth(node);\n                                    height = instance.getHeight(node);\n                                }\n                            }\n                        }\n                        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"html\" + index, style: { transform: \"translate(\" + (stageX.current + position.x * stageScale.current) + \"px,\" +\n                                    (stageY.current + (position.y) * stageScale.current) + \"px) \" +\n                                    \"scale(\" + (stageScale.current) + \",\" + (stageScale.current) + \") \",\n                                width: (width || node.width || 250) + \"px\",\n                                minHeight: (height || node.height || 250) + \"px\",\n                                height: (height || node.height || 250) + \"px\",\n                                top: \"0px\",\n                                left: \"0px\",\n                                opacity: (!canvasHasSelectedNode || (selectedNode && selectedNode.node.name === node.name)) ? 1 : 1\n                            }, id: node.name, \"data-node\": node.name, \"data-task\": node.taskType, \"data-html-plugin\": nodeClone.htmlPlugin, \"data-visualizer\": node.visualizer || \"default\", \"data-x\": position.x, \"data-y\": position.y, \"data-height\": (height || node.height || 250), ref: ref => (elementRefs.current[node.name] = ref), className: \"canvas__html-shape canvas__html-shape-\" + node.name + nodeState },\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-bar \" + (isSelected ? \"canvas__html-shape-bar--selected\" : \"\") },\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"canvas__html-shape-bar-title\" },\n                                    settings.icon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"canvas__html-shape-title-icon fas \" + settings.icon }),\n                                    node.label ? node.label : node.name),\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: \"#\", onClick: (event) => onCloneNode(node, event), onFocus: _html_plugins_form_controls_helpers_focus__WEBPACK_IMPORTED_MODULE_22__.onFocus, className: \"canvas__html-shape-bar-icon far fa-clone\" }),\n                                !!settings.hasConfigMenu && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: \"#\", onFocus: _html_plugins_form_controls_helpers_focus__WEBPACK_IMPORTED_MODULE_22__.onFocus, onClick: (event) => onShowNodeSettings(node, settings, event), className: \"canvas__html-shape-bar-icon fas fa-cog\" })),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-body\" }, props.renderHtmlNode && props.renderHtmlNode(nodeClone, props.flowrunnerConnector, flowMemo, settings)),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-start canvas__html-shape-0\" }),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-startbottom\" }),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-endtop\" }),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-end canvas__html-shape-0\" }),\n                            settings.events && settings.events.map((event, eventIndex) => {\n                                return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-event canvas__html-shape-\" + (eventIndex + 1), key: \"_\" + index + \"-\" + eventIndex });\n                            }));\n                    }\n                    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: \"html\" + index });\n                })))),\n        showNodeSettings && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_edit_node_settings__WEBPACK_IMPORTED_MODULE_16__.EditNodeSettings, { node: editNode, settings: editNodeSettings, flowrunnerConnector: props.flowrunnerConnector, onClose: onCloseEditNodeSettings }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_flow__WEBPACK_IMPORTED_MODULE_14__.Flow, { flow: flowStore.flow, flowId: flowStore.flowId, flowrunnerConnector: props.flowrunnerConnector }));\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/index.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/circle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\n\n\n\n\n\nconst Circle = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\n                    return \"rect\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, \"data-id\": props.name, draggable: false, onDragStart: props.onDragStart, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, onClick: props.onClickShape, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onMouseLeave: props.onMouseLeave, opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize / 2, radius: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, stroke: settings.strokeColor, strokeWidth: 4, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, fill: props.isSelected ? settings.fillSelectedColor : settings.fillColor, perfectDrawEnabled: false }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { x: 0, y: 0, text: props.node && props.node.label ? props.node.label : props.name, align: 'center', width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, verticalAlign: \"middle\", listening: false, wrap: \"none\", fontSize: 18, ellipsis: true, fill: settings.textColor, perfectDrawEnabled: true })));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/circle.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/diamond.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Diamond\": () => (/* binding */ Diamond)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n/* harmony import */ var _helpers_replace_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/helpers/replace-values.ts\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/use-image/index.js\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(use_image__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\nconst Diamond = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const [image] = use_image__WEBPACK_IMPORTED_MODULE_6___default()(\"/svg/cog.svg\");\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const regularPolygonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\n                    return \"diamond\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                        regularPolygonRef.current.to({\n                            duration: 0.05,\n                            opacity: parameters.opacity\n                        });\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\n                    if (regularPolygonRef && regularPolygonRef.current && parameters) {\n                        if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Default) {\n                            regularPolygonRef.current.to({\n                                duration: 0.15,\n                                stroke: settings.strokeColor,\n                                fill: settings.fillColor\n                            });\n                        }\n                        else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Error) {\n                            regularPolygonRef.current.to({\n                                duration: 0.15,\n                                stroke: \"#f00000\",\n                                fill: \"#ff9d9d\"\n                            });\n                        }\n                        else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Ok) {\n                            regularPolygonRef.current.to({\n                                duration: 0.15,\n                                stroke: \"#00e000\",\n                                fill: \"#9dff9d\"\n                            });\n                        }\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    let labelText = props.node && props.node.label ? props.node.label : props.name;\n    if (settings.label) {\n        labelText = (0,_helpers_replace_values__WEBPACK_IMPORTED_MODULE_5__.replaceValuesExpressions)(settings.label, props.node, \"-\");\n    }\n    let textDecoration = \"\";\n    let strokeColor = settings.strokeColor;\n    let fillColor = props.isSelected ? settings.fillSelectedColor : settings.fillColor;\n    if (props.nodeState === \"error\") {\n        strokeColor = props.isSelected ? \"#f00000\" : \"#e00000\";\n        fillColor = props.isSelected ? \"#ff5454\" : \"#ff9d9d\";\n    }\n    else if (props.nodeState === \"ok\") {\n        strokeColor = props.isSelected ? \"#00f000\" : \"#00e000\";\n        fillColor = props.isSelected ? \"#54ff54\" : \"#9dff9d\";\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, draggable: false, transformsEnabled: \"position\", onClick: props.onClickShape, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.RegularPolygon, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, stroke: strokeColor, strokeWidth: 4, cornerRadius: 4, sides: 4, transformsEnabled: \"position\", ref: regularPolygonRef, radius: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, fill: fillColor, perfectDrawEnabled: false }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { x: 10, y: 0, text: labelText, align: 'center', width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize - 20, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, verticalAlign: \"middle\", listening: false, wrap: \"word\", transformsEnabled: \"position\", textDecoration: textDecoration, fontSize: 18, ellipsis: true, fill: settings.textColor, perfectDrawEnabled: true }),\n            !!settings.hasConfigMenu && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Image, { image: image, pathColor: settings.textColor, width: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 8), height: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 8), keepRatio: true, x: Math.round((_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2) - _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 16), y: 16, onClick: props.onClickSetup })));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/diamond.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/ellipse.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ellipse\": () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\n\n\n\n\n\nconst Ellipse = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\n                    return \"ellipse\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, draggable: false, onClick: props.onClickShape, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, transformsEnabled: \"position\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Ellipse, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectHeight / 2, radiusX: 100, radiusY: 50, stroke: settings.strokeColor, strokeWidth: 4, transformsEnabled: \"position\", cornerRadius: settings.cornerRadius, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectHeight, fill: props.isSelected ? settings.fillSelectedColor : settings.fillColor, perfectDrawEnabled: false }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { x: 0, y: 0, text: props.node && props.node.label ? props.node.label : props.name, align: 'center', width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectHeight, verticalAlign: \"middle\", transformsEnabled: \"position\", listening: false, wrap: \"none\", fontSize: 18, ellipsis: true, fill: settings.textColor, perfectDrawEnabled: true })));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/ellipse.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/html.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Html\": () => (/* binding */ Html)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\n\n\n\n\n\n\nconst Html = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\n                    return \"html\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (props.getNodeInstance) {\n            const instance = props.getNodeInstance(props.node, undefined, undefined, settings);\n            if (instance && instance.getWidth && instance.getHeight) {\n                setWidth(instance.getWidth(props.node));\n                setHeight(instance.getHeight(props.node));\n            }\n        }\n    }, [props.node]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, draggable: false, transformsEnabled: \"position\", onClick: props.onClickShape, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect, { x: 0, y: 0, strokeWidth: 0, cornerRadius: settings.cornerRadius, width: width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth, height: (height || props.node.height || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlHeight) + 5, fill: \"#000000\", opacity: 0, perfectDrawEnabled: false })));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/html.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shapes\": () => (/* binding */ Shapes)\n/* harmony export */ });\n/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/components/canvas/shapes/circle.tsx\");\n/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/rect.tsx\");\n/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/line.tsx\");\n/* harmony import */ var _diamond__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/diamond.tsx\");\n/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/components/canvas/shapes/ellipse.tsx\");\n/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/components/canvas/shapes/html.tsx\");\n\n\n\n\n\n\nconst Shapes = {\n    Circle: _circle__WEBPACK_IMPORTED_MODULE_0__.Circle, Rect: _rect__WEBPACK_IMPORTED_MODULE_1__.Rect, Line: _line__WEBPACK_IMPORTED_MODULE_2__.Line, Diamond: _diamond__WEBPACK_IMPORTED_MODULE_3__.Diamond, Ellipse: _ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse, Html: _html__WEBPACK_IMPORTED_MODULE_5__.Html\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/index.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/line-helper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineHelper\": () => (/* binding */ LineHelper),\n/* harmony export */   \"Lines\": () => (/* binding */ Lines)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/line.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\n\n\n\n\nconst LineHelper = (props) => {\n    const endNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const endIndex = props.flowHash.get(props.endshapeid).index;\n        if (endIndex < 0) {\n            return false;\n        }\n        return props.flow[endIndex];\n    }, [props.node.name, props.flow, props.flowHash, props.endshapeid]);\n    if (!endNode) {\n        return null;\n    }\n    let positionNode = props.positions(endNode.name) || endNode;\n    const newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getEndPointForLine(endNode, {\n        x: positionNode.x,\n        y: positionNode.y\n    }, endNode, props.getNodeInstance, props.lineNode.thumbEndPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_line__WEBPACK_IMPORTED_MODULE_1__.Line, { ref: ref => (props.shapeRefs.current[props.lineNode.name] = ref), onMouseOver: (event) => props.onLineMouseOver(props.lineNode, event), onMouseOut: (event) => props.onLineMouseOut(props.lineNode, event), onClickLine: (event) => props.onClickLine(props.lineNode, event), canvasHasSelectedNode: props.canvasHasSelectedNode, isSelected: props.selectedNode && props.selectedNode.node &&\n            props.selectedNode.node.name === props.lineNode.name, isErrorColor: props.lineNode.followflow === 'onfailure', isSuccessColor: props.lineNode.followflow === 'onsuccess', xstart: props.newStartPosition.x, ystart: props.newStartPosition.y, xend: newEndPosition.x, yend: newEndPosition.y, isEventNode: props.lineNode.event !== undefined && props.lineNode.event !== \"\", selectedNodeName: props.isSelected && props.selectedNode &&\n            props.selectedNode.node ? props.selectedNode.node.name : \"\", startNodeName: props.lineNode.startshapeid, endNodeName: props.lineNode.endshapeid, noMouseEvents: false, touchedNodes: props.touchedNodes, name: props.lineNode.name, thumbPosition: props.lineNode.thumbPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default, thumbEndPosition: props.lineNode.thumbEndPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default });\n};\nconst Lines = (props) => {\n    const lines = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return props.flowHash.get(props.node.name).start.map((lineIndex, index) => {\n            return props.flow[lineIndex];\n        });\n    }, [props.node.name, props.flow, props.flowHash]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, lines.map((lineNode, index) => {\n        let newPosition = { x: props.node.x, y: props.node.y };\n        newPosition = props.positions(props.node.name) || newPosition;\n        const newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getStartPointForLine(props.node, newPosition, lineNode, props.getNodeInstance, lineNode.thumbPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default);\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: index },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(LineHelper, { flow: props.flow, flowHash: props.flowHash, positions: props.positions, endshapeid: lineNode.endshapeid, node: props.node, lineNode: lineNode, getNodeInstance: props.getNodeInstance, canvasHasSelectedNode: props.canvasHasSelectedNode, isSelected: props.isSelected, selectedNode: props.selectedNode, shapeRefs: props.shapeRefs, onLineMouseOver: props.onLineMouseOver, onLineMouseOut: props.onLineMouseOut, onClickLine: props.onClickLine, touchedNodes: props.touchedNodes, newStartPosition: newStartPosition }));\n    }));\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/line-helper.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/line.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line\": () => (/* binding */ Line)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _helpers_line_points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/helpers/line-points.ts\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\n\n\n\nconst KonvaLine = react_konva__WEBPACK_IMPORTED_MODULE_1__.Arrow;\n\n\nconst Line = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const [fillColor, setFillColor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.isConnectionWithVariable ? \"#0080e0\" : \"#000000\");\n    const [strokeWidth, setStrokeWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(2);\n    const [opacity, setOpacity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [dash, setDash] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.touchedNodes && props.name && props.touchedNodes[props.name] ? [5, 10] : [1, 1]);\n    const lineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const bgLineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        let _fillColor = props.isSelected ? \"#606060\" : \"#000000\";\n        let _strokeWidth = 4;\n        if (props.isErrorColor) {\n            _fillColor = props.isSelected ? \"#800000\" : \"#e00000\";\n        }\n        if (props.isSuccessColor) {\n            _fillColor = props.isSelected ? \"#004000\" : \"#008300\";\n        }\n        if (props.isAltColor) {\n            _fillColor = \"#a0a0a0\";\n        }\n        if (props.isConnectionWithVariable) {\n            _fillColor = \"#0080e0\";\n        }\n        if (props.isEventNode) {\n            _fillColor = \"#a000a0\";\n            _strokeWidth = 4;\n        }\n        let _opacity = 1;\n        if (props.isNodeConnectorHelper !== undefined && !!props.isNodeConnectorHelper) {\n            _opacity = 0;\n            if (lineRef.current) {\n                lineRef.current.pointerWidth(0);\n                lineRef.current.pointerLength(0);\n            }\n        }\n        if (!props.isSelected && props.canvasHasSelectedNode) {\n            if (props.selectedNodeName != props.startNodeName &&\n                props.selectedNodeName != props.endNodeName) {\n            }\n        }\n        let dash = [];\n        if (props.touchedNodes && props.name && props.touchedNodes[props.name]) {\n            dash = [5, 10];\n            _strokeWidth = 8;\n        }\n        else {\n        }\n        if (lineRef.current) {\n            lineRef.current.to({\n                duration: 0.15,\n                fill: _fillColor,\n                stroke: _fillColor,\n                strokeWidth: _strokeWidth,\n                opacity: _opacity\n            });\n        }\n        else {\n            setFillColor(_fillColor);\n            setStrokeWidth(_strokeWidth);\n        }\n        if (props.touchedNodes && props.name && props.touchedNodes[props.name]) {\n            setDash([5, 10]);\n        }\n        else {\n            setDash([]);\n        }\n    }, [props.isSelected,\n        props.isErrorColor,\n        props.isSuccessColor,\n        props.isAltColor,\n        props.isConnectionWithVariable,\n        props.isEventNode,\n        props.canvasHasSelectedNode,\n        props.selectedNodeName,\n        props.startNodeName,\n        props.endNodeName,\n        props.touchedNodes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.GetShapeType: {\n                    return \"line\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.GetXY: {\n                    if (lineRef && lineRef.current) {\n                        return {\n                            x: lineRef.current.x(),\n                            y: lineRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetXY: {\n                    if (lineRef && lineRef.current && parameters) {\n                        lineRef.current.x(parameters.x);\n                        lineRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetOpacity: {\n                    if (lineRef && lineRef.current && parameters) {\n                        lineRef.current.opacity(parameters.opacity);\n                        if (props.isNodeConnectorHelper !== undefined && !!props.isNodeConnectorHelper) {\n                            if (lineRef.current) {\n                                if (parameters.opacity > 0) {\n                                    lineRef.current.pointerWidth(10);\n                                    lineRef.current.pointerLength(10);\n                                }\n                                else {\n                                    lineRef.current.pointerWidth(0);\n                                    lineRef.current.pointerLength(0);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetPoints: {\n                    if (lineRef && lineRef.current && parameters) {\n                        lineRef.current.points(parameters.points);\n                    }\n                    if (bgLineRef && bgLineRef.current && parameters) {\n                        bgLineRef.current.points(parameters.points);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetState: {\n                    if (lineRef && lineRef.current && parameters) {\n                        if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_3__.ShapeStateEnum.Touched) {\n                            lineRef.current.dash([5, 10]);\n                            lineRef.current.to({\n                                duration: 0.15,\n                                strokeWidth: 8,\n                                opacity: 1\n                            });\n                            if (bgLineRef.current) {\n                                bgLineRef.current.to({\n                                    duration: 0.15,\n                                    strokeWidth: (8 + 12),\n                                    opacity: 1\n                                });\n                            }\n                        }\n                        else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_3__.ShapeStateEnum.Default) {\n                            lineRef.current.dash([]);\n                            lineRef.current.to({\n                                duration: 0.15,\n                                strokeWidth: 4,\n                                opacity: 1\n                            });\n                            if (bgLineRef.current) {\n                                bgLineRef.current.to({\n                                    duration: 0.15,\n                                    strokeWidth: (4 + 12),\n                                    opacity: 1\n                                });\n                            }\n                        }\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_2__.calculateLineControlPoints)(props.xstart, props.ystart, props.xend, props.yend, props.thumbPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default, props.thumbEndPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { listening: !props.noMouseEvents },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaLine, { ref: bgLineRef, points: [props.xstart, props.ystart,\n                controlPoints.controlPointx1, controlPoints.controlPointy1,\n                controlPoints.controlPointx2, controlPoints.controlPointy2,\n                props.xend, props.yend], stroke: \"#e2e2e2\", strokeWidth: strokeWidth + 12, pointerLength: 10, pointerWidth: 10, lineCap: \"round\", lineJoin: \"round\", dash: dash, transformsEnabled: \"position\", fill: \"#e2e2e2\", opacity: props.opacity !== undefined ? props.opacity : opacity, tension: 0, bezier: true, perfectDrawEnabled: false, hitStrokeWidth: 0, noMouseEvents: true }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaLine, { ref: lineRef, points: [props.xstart, props.ystart,\n                controlPoints.controlPointx1, controlPoints.controlPointy1,\n                controlPoints.controlPointx2, controlPoints.controlPointy2,\n                props.xend, props.yend], stroke: fillColor, strokeWidth: strokeWidth + 2, pointerLength: 10, pointerWidth: 10, transformsEnabled: \"position\", lineCap: \"round\", lineJoin: \"round\", hitStrokeWidth: 16, dash: dash, fill: fillColor, opacity: props.opacity !== undefined ? props.opacity : 1, tension: 0, bezier: true, perfectDrawEnabled: false, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onClick: props.onClickLine, onTap: props.onClickLine }));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/line.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/lines-for-shape.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LinesForShape\": () => (/* binding */ LinesForShape)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _line_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/line-helper.tsx\");\n\n\nconst LinesForShape = (props) => {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_line_helper__WEBPACK_IMPORTED_MODULE_1__.Lines, { flow: props.flow, node: props.node, getNodeInstance: props.getNodeInstance, canvasHasSelectedNode: props.canvasHasSelectedNode, selectedNode: props.selectedNode, isSelected: props.isSelected, shapeRefs: props.shapeRefs, onLineMouseOver: props.onLineMouseOver, onLineMouseOut: props.onLineMouseOut, onClickLine: props.onClickLine, touchedNodes: props.touchedNodes, positions: props.positions, flowHash: props.flowHash });\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/lines-for-shape.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/rect.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rect\": () => (/* binding */ Rect)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/use-image/index.js\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(use_image__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\n\n\n\n\n\n\nconst Rect = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_5__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    let rect = undefined;\n    let textRef = undefined;\n    let skewX = 0;\n    let skewXOffset = 0;\n    let includeSvgIcon = false;\n    const [image] = use_image__WEBPACK_IMPORTED_MODULE_1___default()(\"/svg/layout.svg\");\n    const [cogImage] = use_image__WEBPACK_IMPORTED_MODULE_1___default()(\"/svg/cog.svg\");\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (settings.isSkewed) {\n        skewX = -0.5;\n        skewXOffset = (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8);\n    }\n    if (props.node && props.node.objectSchema) {\n        if (props.node.objectSchema == \"layout\") {\n            includeSvgIcon = true;\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (rect) {\n            rect.skew({\n                x: skewX,\n                y: 0\n            });\n            rect.cache();\n        }\n        if (textRef) {\n            textRef.cache();\n        }\n    });\n    const setRef = (ref) => {\n        rect = ref;\n        if (rect) {\n            rect.skew({\n                x: skewX,\n                y: 0\n            });\n        }\n    };\n    const setTextRef = (ref) => {\n        textRef = ref;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.GetShapeType: {\n                    return \"rect\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetState: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Group, { ref: groupRef, x: props.x, y: props.y, transformsEnabled: settings.isSkewed ? \"all\" : \"position\", draggable: false, order: 0, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onDragStart: props.onDragStart, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, onClick: props.onClickShape, listening: true, opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, { ref: ref => (setRef(ref)), x: skewXOffset, y: 0, stroke: settings.strokeColor, hitStrokeWidth: 0, strokeWidth: 4, listening: true, cornerRadius: settings.cornerRadius, transformsEnabled: settings.isSkewed ? \"all\" : \"position\", width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectHeight, fill: props.isSelected ? settings.fillSelectedColor : settings.fillColor, perfectDrawEnabled: false }),\n            settings.subShapeType && settings.subShapeType == \"Model\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Line, { points: [skewXOffset, 10, (skewXOffset + _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht), 10], stroke: settings.strokeColor, transformsEnabled: \"position\", listening: false, strokeWidth: 4 }),\n            includeSvgIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Image, { image: image, pathColor: settings.textColor, width: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 4), height: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 4), keepRatio: true, listening: false, x: Math.round((_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 2) - (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8)), y: 8 }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Text, { ref: ref => (setTextRef(ref)), x: 0, y: includeSvgIcon ? Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8) : 0, text: props.node && props.node.label ? props.node.label : props.name, align: 'center', fontSize: 18, transformsEnabled: \"position\", width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectHeight, verticalAlign: \"middle\", listening: false, wrap: \"none\", ellipsis: true, fill: settings.textColor, perfectDrawEnabled: false }),\n            !!settings.hasConfigMenu && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Image, { image: cogImage, pathColor: settings.textColor, transformsEnabled: \"position\", listening: true, width: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8), height: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8), keepRatio: true, x: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht - (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8) - 4), y: 4, onClick: props.onClickSetup })));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/rect.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/thumbs.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Thumbs\": () => (/* binding */ Thumbs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\n\n\n\nconst KonvaRect = react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect;\nconst KonvaCircle = react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle;\n\n\n\n\nconst Thumbs = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\n                    return \"thumbs\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (props.getNodeInstance) {\n            const instance = props.getNodeInstance(props.node, undefined, undefined, settings);\n            if (instance && instance.getWidth && instance.getHeight) {\n                setWidth(instance.getWidth(props.node));\n                let bodyElement = document.querySelector(\"#\" + props.name + \" .html-plugin-node\");\n                let element = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-thumb-startbottom\");\n                if (!bodyElement) {\n                    bodyElement = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-body\");\n                }\n                if (element && bodyElement) {\n                    setHeight(instance.getHeight(bodyElement.clientHeight + 20));\n                }\n                else {\n                    setHeight(instance.getHeight(props.node));\n                }\n            }\n        }\n    }, [props.isSelected, props.isConnectedToSelectedNode, props.node]);\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { ref: groupRef, x: props.position.x, y: props.position.y, onMouseOver: props.onMouseConnectionEndOver, onMouseOut: props.onMouseConnectionEndOut, onMouseDown: props.onMouseConnectionEndStart, onMouseMove: props.onMouseConnectionEndMove, onMouseUp: props.onMouseConnectionEndEnd, onMouseLeave: props.onMouseConnectionEndLeave, onTouchStart: props.onMouseConnectionEndStart, onTouchMove: props.onMouseConnectionEndMove, onTouchEnd: props.onMouseConnectionEndEnd, width: 12, height: 12, transformsEnabled: \"position\" },\n            (props.shapeType === \"Rect\" || props.shapeType === \"Diamond\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: 0, y: 12, radius: 8, listening: false, transformsEnabled: \"position\", fill: \"#000000\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: 0, y: 12, radius: 6, listening: false, transformsEnabled: \"position\", fill: \"#ffffff\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: 0, y: 12, radius: 12, listening: true, transformsEnabled: \"position\", opacity: 0 })),\n            props.shapeType === \"Html\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaRect, { x: props.shapeType === \"Html\" &&\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.top ?\n                        ((width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth) / 2) - 12 :\n                        -16, y: props.shapeType === \"Html\" &&\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.top ? -16 : 40, strokeWidth: 0, stroke: \"#808080\", cornerRadius: settings.cornerRadius, width: 24, transformsEnabled: \"position\", height: 24, fill: \"#ff0000\", opacity: 0, perfectDrawEnabled: false, name: \"connectiontionend\", listening: true }))));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/thumbs.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/thumbsstart.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThumbsStart\": () => (/* binding */ ThumbsStart)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\n\n\n\nconst KonvaRect = react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect;\nconst KonvaCircle = react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle;\n\n\n\n\nconst ThumbsStart = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\n        modifyShape: (action, parameters) => {\n            switch (+action) {\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\n                    return \"thumbsstart\";\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\n                    if (groupRef && groupRef.current) {\n                        return {\n                            x: groupRef.current.x(),\n                            y: groupRef.current.y(),\n                        };\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.x(parameters.x);\n                        groupRef.current.y(parameters.y);\n                        if (props.shapeType === \"Html\" && props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom) {\n                            let width = undefined;\n                            let height = undefined;\n                            if (props.getNodeInstance && props.node) {\n                                const nodeInstance = props.getNodeInstance(props.node, undefined, undefined, settings);\n                                if (nodeInstance && nodeInstance.getWidth) {\n                                    width = nodeInstance.getWidth(props.node);\n                                    height = nodeInstance.getHeight(props.node);\n                                }\n                            }\n                            let bodyElement = document.querySelector(\"#\" + props.name + \" .html-plugin-node\");\n                            let element = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-thumb-startbottom\");\n                            if (element && bodyElement) {\n                                element.style.top = ((bodyElement.clientHeight + 20) || height || \"400\") + \"px\";\n                            }\n                        }\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\n                    if (groupRef && groupRef.current && parameters) {\n                        groupRef.current.opacity(parameters.opacity);\n                    }\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\n                    break;\n                }\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    }));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (props.getNodeInstance) {\n            const instance = props.getNodeInstance(props.node, undefined, undefined, settings);\n            if (instance && instance.getWidth && instance.getHeight) {\n                setWidth(instance.getWidth(props.node));\n                let bodyElement = document.querySelector(\"#\" + props.name + \" .html-plugin-node\");\n                let element = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-thumb-startbottom\");\n                if (!bodyElement) {\n                    bodyElement = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-body\");\n                }\n                if (element && bodyElement) {\n                    setHeight(bodyElement.clientHeight + 20);\n                    if (props.shapeType === \"Html\" && props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom) {\n                        element.style.top = ((bodyElement.clientHeight + 20) || height || \"400\") + \"px\";\n                    }\n                }\n                else {\n                    setHeight(instance.getHeight(props.node));\n                }\n            }\n        }\n    }, [props.isSelected, props.isConnectedToSelectedNode, props.node]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { ref: groupRef, x: props.position.x, y: props.shapeType === \"Html\" &&\n                props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom ?\n                (props.position.y + height) :\n                props.position.y, onMouseOver: props.onMouseConnectionStartOver, onMouseOut: props.onMouseConnectionStartOut, onMouseDown: props.onMouseConnectionStartStart, onMouseMove: props.onMouseConnectionStartMove, onMouseUp: props.onMouseConnectionStartEnd, onTouchStart: props.onMouseConnectionStartStart, onTouchMove: props.onMouseConnectionStartMove, onTouchEnd: props.onMouseConnectionStartEnd, width: 12, height: 12, transformsEnabled: \"position\" },\n            (props.shapeType === \"Rect\" || props.shapeType === \"Diamond\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, y: 12, radius: 8, listening: false, transformsEnabled: \"position\", fill: props.followFlow == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbFollowFlow.happyFlow ? \"#00d300\" :\n                        (props.followFlow == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbFollowFlow.unhappyFlow ? \"#e00000\" : \"#000000\"), opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, y: 12, radius: 6, listening: false, transformsEnabled: \"position\", fill: \"#ffffff\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, y: 12, listening: true, transformsEnabled: \"position\", radius: 12, opacity: 0 })),\n            props.shapeType === \"Html\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaRect, { x: props.shapeType === \"Html\" &&\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom ?\n                        ((width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth) / 2) - 12 :\n                        (width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth) - 8, y: props.shapeType === \"Html\" &&\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom ? 0 :\n                        40, strokeWidth: 0, stroke: \"#808080\", transformsEnabled: \"position\", cornerRadius: settings.cornerRadius, width: 24, height: 24, fill: \"#ff0000\", opacity: 0, order: 1, perfectDrawEnabled: false, listening: true, name: \"connectiontionstart\" }))));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/thumbsstart.tsx?");

/***/ }),

/***/ "./src/components/edit-node-settings/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditNodeSettings\": () => (/* binding */ EditNodeSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/react-bootstrap/esm/Modal.js\");\n/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/react-bootstrap/esm/Button.js\");\n/* harmony import */ var _html_plugins_form_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/html-plugins/form-node.tsx\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _state_selected_node_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/state/selected-node-state.ts\");\n\n\n\n\n\n\nconst EditNodeSettings = (props) => {\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [orgNodeName, setOrgNodeName] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [orgNodeValues, setOrgNodeValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [requiredNodeValues, setRequiredNodeValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const flow = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_2__.useFlowStore)();\n    const selectedNode = (0,_state_selected_node_state__WEBPACK_IMPORTED_MODULE_3__.useSelectedNodeStore)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!props.node) {\n            return;\n        }\n        const node = { ...props.node };\n        let newRequiredNodeValues;\n        if (node.shapeType !== \"Line\") {\n            newRequiredNodeValues = {\n                _id: node._id,\n                id: node.id,\n                x: node.x,\n                y: node.y,\n                shapeType: node.shapeType\n            };\n            delete node.x;\n            delete node.y;\n        }\n        else {\n            newRequiredNodeValues = {\n                _id: node._id,\n                id: node.id,\n                startshapeid: node.startshapeid,\n                endshapeid: node.endshapeid,\n                xstart: node.xstart,\n                ystart: node.ystart,\n                xend: node.xend,\n                yend: node.yend,\n                shapeType: node.shapeType,\n                taskType: node.taskType\n            };\n            delete node.startshapeid;\n            delete node.endshapeid;\n            delete node.xstart;\n            delete node.ystart;\n            delete node.xend;\n            delete node.yend;\n            delete node.taskType;\n        }\n        delete node._id;\n        delete node.id;\n        delete node.shapeType;\n        setValue(node);\n        setOrgNodeName(props.node.name);\n        setOrgNodeValues({ ...props.node });\n        setRequiredNodeValues(newRequiredNodeValues);\n    }, []);\n    const saveNode = (e) => {\n        try {\n            const changedProperties = value;\n            if (changedProperties.id !== undefined) {\n                delete changedProperties.id;\n            }\n            const node = { ...requiredNodeValues, ...changedProperties };\n            props.flowrunnerConnector.resetCurrentFlow();\n            flow.storeFlowNode(node, orgNodeName);\n            selectedNode.selectNode(node.name, node);\n            props.onClose(true);\n        }\n        catch (err) {\n            alert(\"The json in the 'Node JSON' field is invalid\");\n        }\n        e.preventDefault();\n        return false;\n    };\n    const onCloseClick = (event) => {\n        event.preventDefault();\n        props.onClose();\n        return false;\n    };\n    const onSetValue = (newValue, fieldName) => {\n        setValue({ ...value, [fieldName]: newValue });\n    };\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"edit-node-settings\", ref: ref => (containerRef.current = ref) },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default, { show: true, centered: true, size: \"lg\", container: containerRef.current },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Header, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Title, null,\n                    \"Edit \",\n                    props.node.name)),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Body, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"form-group\" },\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(_html_plugins_form_node__WEBPACK_IMPORTED_MODULE_1__.FormNodeHtmlPlugin, { isNodeSettingsUI: true, node: props.node, taskSettings: props.settings, onSetValue: onSetValue, isInFlowEditor: false, flowrunnerConnector: props.flowrunnerConnector }))),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Footer, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_5__.default, { variant: \"secondary\", onClick: onCloseClick }, \"Close\"),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_5__.default, { variant: \"primary\", onClick: saveNode }, \"Save\"))));\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/edit-node-settings/index.tsx?");

/***/ }),

/***/ "./src/components/flow/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Flow\": () => (/* binding */ Flow)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n\n\nconst Flow = (props) => {\n    const [internalFlow, setInternalFlow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        console.log(\"FLOW in flow component useEffect\", performance.now());\n        if (internalFlow.length != props.flow.length) {\n            setInternalFlow(props.flow);\n        }\n        else {\n            let changed = false;\n            let changedNode = \"\";\n            let changedNodeProperty = \"\";\n            let properties = [\"x\", \"y\", \"xstart\", \"ystart\", \"xend\", \"yend\"];\n            let perfstart = performance.now();\n            props.flow.map((node, index) => {\n                if (changed) {\n                    return true;\n                }\n                const internalNode = internalFlow[index];\n                {\n                    let nodeKeys = Object.keys(node);\n                    let internalNodeKeys = Object.keys(internalNode);\n                    {\n                        nodeKeys.map((nodeProperty) => {\n                            if (changed) {\n                                return;\n                            }\n                            if (properties.indexOf(nodeProperty) >= 0) {\n                                return;\n                            }\n                            if (node[nodeProperty] !== internalNode[nodeProperty]) {\n                                changed = true;\n                                changedNode = node.name;\n                                changedNodeProperty = nodeProperty;\n                            }\n                        });\n                        if (!changed) {\n                            internalNodeKeys.map((internalNodeProperty) => {\n                                if (changed) {\n                                    return;\n                                }\n                                if (properties.indexOf(internalNodeProperty) >= 0) {\n                                    return;\n                                }\n                                if (node[internalNodeProperty] !== internalNode[internalNodeProperty]) {\n                                    changed = true;\n                                    changedNode = node.name;\n                                    changedNodeProperty = internalNodeProperty;\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            console.log(\"flow diffing time\", (performance.now() - perfstart) + \"ms\");\n            if (changed) {\n                console.log(\"flow changed\", changedNode, changedNodeProperty, props.flow);\n                setInternalFlow(props.flow);\n            }\n        }\n    }, [props.flow, props.flowId]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        let perfstart = performance.now();\n        if (!internalFlow) {\n            return;\n        }\n        props.flowrunnerConnector.pushFlowToFlowrunner(internalFlow, true, props.flowId);\n        console.log(\"flow pushFlowToFlowrunner\", (performance.now() - perfstart) + \"ms\");\n    }, [internalFlow]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/flow/index.tsx?");

/***/ }),

/***/ "./src/dragging-task.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DragginTask\": () => (/* binding */ DragginTask)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n\nconst DragginTask = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({}, props, { ref: ref, className: \"taskbar__task\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, props.id));\n});\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/dragging-task.tsx?");

/***/ }),

/***/ "./src/helpers/line-points.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateLineControlPoints\": () => (/* binding */ calculateLineControlPoints)\n/* harmony export */ });\n/* harmony import */ var victor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/victor/index.js\");\n/* harmony import */ var victor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(victor__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\n\nconst calculateLineControlPoints = (xstart, ystart, xend, yend, startPositionRelativeToNode, endPositionRelativeToNode) => {\n    let controlPointx1;\n    let controlPointy1;\n    let controlPointx2;\n    let controlPointy2;\n    let factor = 0.35;\n    var vec1 = new (victor__WEBPACK_IMPORTED_MODULE_0___default())(xstart, ystart);\n    var vec2 = new (victor__WEBPACK_IMPORTED_MODULE_0___default())(xend, yend);\n    var distance = vec1.distance(vec2) * factor;\n    let yadjust = 0;\n    let xadjust = 0;\n    if (xend < xstart && Math.abs(ystart - yend) < 32) {\n        yadjust = Math.abs(xstart - xend) * 0.5;\n        xadjust = 200;\n    }\n    if (startPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.left) {\n        controlPointx1 = xstart - distance - xadjust;\n        controlPointy1 = ystart + yadjust;\n    }\n    else if (startPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.top) {\n        controlPointx1 = xstart;\n        controlPointy1 = ystart - distance;\n    }\n    else if (startPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.bottom) {\n        controlPointx1 = xstart;\n        controlPointy1 = ystart + distance;\n    }\n    else {\n        controlPointx1 = xstart + distance + xadjust;\n        controlPointy1 = ystart + yadjust;\n    }\n    if (endPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.top) {\n        controlPointx2 = xend;\n        controlPointy2 = yend - distance;\n    }\n    else {\n        controlPointx2 = xend - distance - xadjust;\n        controlPointy2 = yend + yadjust;\n    }\n    return {\n        controlPointx1: controlPointx1,\n        controlPointy1: controlPointy1,\n        controlPointx2: controlPointx2,\n        controlPointy2: controlPointy2,\n    };\n};\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/helpers/line-points.ts?");

/***/ }),

/***/ "./src/helpers/shape-settings.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShapeSettings\": () => (/* binding */ ShapeSettings)\n/* harmony export */ });\n/* harmony import */ var _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/config.ts\");\n\n\nclass ShapeSettings {\n    static getShapeSettings(taskType, node) {\n        let settings = {\n            strokeColor: '#000000',\n            fillColor: _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_0__.shapeBackgroundColor,\n            fillSelectedColor: _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_0__.shapeSelectedBackgroundColor,\n            textColor: '#000000',\n            cornerRadius: 0,\n            isSkewed: false,\n            hasUI: false,\n        };\n        const taskTypeConfig = (0,_config__WEBPACK_IMPORTED_MODULE_1__.getTaskConfigForTask)(taskType);\n        if (taskTypeConfig) {\n            let variableSettings = {};\n            if (node && !!node.hasVariableAttached) {\n                variableSettings = taskTypeConfig['_variable'];\n            }\n            if (node && node.objectSchema && taskTypeConfig[node.objectSchema]) {\n                settings = {\n                    ...settings,\n                    ...taskTypeConfig,\n                    ...variableSettings,\n                    ...taskTypeConfig[node.objectSchema],\n                };\n            }\n            else {\n                settings = { ...settings, ...taskTypeConfig, ...variableSettings };\n            }\n        }\n        return settings;\n    }\n}\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/helpers/shape-settings.ts?");

/***/ }),

/***/ "./src/state/nodes-touched.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useNodesTouchedStateStore\": () => (/* binding */ useNodesTouchedStateStore),\n/* harmony export */   \"useNodesTouchedStateForMultiFormStore\": () => (/* binding */ useNodesTouchedStateForMultiFormStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/zustand/esm/index.js\");\n\nlet storeHandler = (set) => {\n    return {\n        nodesTouched: {},\n        setNodesTouched: (nodesTouched) => set(state => {\n            return {\n                nodesTouched: nodesTouched,\n            };\n        }),\n        clearNodesTouched: () => set(state => {\n            return {\n                nodesTouched: {},\n            };\n        }),\n    };\n};\nconst useNodesTouchedStateStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.default)(set => storeHandler(set));\nconst useNodesTouchedStateForMultiFormStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.default)(set => storeHandler(set));\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/state/nodes-touched.ts?");

/***/ })

}]);