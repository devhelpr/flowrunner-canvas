/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["flowcanvaswebpackJsonpPlugin"] = self["flowcanvaswebpackJsonpPlugin"] || []).push([["src_components_canvas_index_tsx"],{

/***/ "./src/components/canvas/canvas-components/html-node.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HtmlNode\": () => (/* binding */ HtmlNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/index.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n/* harmony import */ var _services_position_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/services/position-service.ts\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst HtmlNode = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    let shapeType = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getShapeType(props.node.shapeType, props.node.taskType, props.node.isStartEnd), [props.node]);\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_3__.ShapeSettings.getShapeSettings(props.node.taskType, props.node), [props.node]);\r\n    const flowStore = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_5__.useFlowStore)();\r\n    const Shape = _shapes__WEBPACK_IMPORTED_MODULE_1__.Shapes[shapeType];\r\n    if (shapeType === \"Html\" && Shape) {\r\n        const nodeClone = { ...props.node };\r\n        const position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.getPosition)(props.node.name) || props.node;\r\n        let nodeState = (props.nodesStateLocal || \"\") == \"error\" ? \" has-error\" : \"\";\r\n        const isSelected = false;\r\n        nodeClone.htmlPlugin = props.node.htmlPlugin || settings.htmlPlugin || \"\";\r\n        let width = undefined;\r\n        let height = undefined;\r\n        if (props.getNodeInstance) {\r\n            const instance = props.getNodeInstance(props.node, props.flowrunnerConnector, flowStore.flow, settings);\r\n            if (instance) {\r\n                if (instance.getWidth && instance.getHeight) {\r\n                    width = instance.getWidth(props.node);\r\n                    height = instance.getHeight(props.node);\r\n                }\r\n            }\r\n        }\r\n        let htmlPlugin = props.node.htmlPlugin;\r\n        if (!htmlPlugin || htmlPlugin == \"\") {\r\n            htmlPlugin = settings.htmlPlugin;\r\n        }\r\n        let additionalStyles = {};\r\n        if (htmlPlugin === \"shapeNode\") {\r\n            additionalStyles.height = (height || props.node.height || 250) + \"px\";\r\n        }\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { transform: \"translate(\" + (position.x) + \"px,\" +\r\n                    ((position.y)) + \"px) \" +\r\n                    \"scale(\" + (1) + \",\" + (1) + \") \",\r\n                width: (width || props.node.width || 250) + \"px\",\r\n                minHeight: (height || props.node.height || 250) + \"px\",\r\n                top: \"0px\",\r\n                left: \"0px\",\r\n                opacity: (!props.canvasHasSelectedNode) ? 1 : 1,\r\n                ...additionalStyles,\r\n            }, id: props.node.name, \"data-node\": props.node.name, \"data-task\": props.node.taskType, \"data-html-plugin\": nodeClone.htmlPlugin, \"data-visualizer\": props.node.visualizer || \"default\", \"data-x\": position.x, \"data-y\": position.y, \"data-height\": (height || props.node.height || 250), ref: ref, className: \"canvas__html-shape canvas__html-shape-\" + props.node.name + nodeState +\r\n                (settings.background ? \" \" + settings.background : \"\") +\r\n                (isSelected ? \" canvas__html-shap--selected\" : \"\") + \" \" +\r\n                (_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasOutputs(shapeType, settings) ? \"\" : \"canvas__html-shape--no-outputs\") + \" \" +\r\n                (_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasInputs(shapeType, settings) ? \"\" : \"canvas__html-shape--no-inputs\"), onMouseUp: (event) => props.onMouseEnd(props.node, event) },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-bar \" + (isSelected ? \"canvas__html-shape-bar--selected\" : \"\"), onMouseOver: (event) => props.onMouseOver(props.node, event), onMouseOut: props.onMouseOut, onTouchStart: (event) => props.onTouchStart(props.node, event), onTouchEnd: (event) => props.onMouseEnd(props.node, event), onTouchMove: (event) => props.onMouseMove(props.node, event), onMouseDown: (event) => props.onMouseStart(props.node, event), onMouseMove: (event) => props.onMouseMove(props.node, event), onMouseUp: (event) => props.onMouseEnd(props.node, event), onMouseLeave: (event) => props.onMouseLeave(props.node, event), onClick: (event) => props.onClickShape(props.node, event) },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"canvas__html-shape-bar-title\" },\r\n                    settings.icon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"canvas__html-shape-title-icon fas \" + settings.icon }),\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, !!props.hasTaskNameAsNodeTitle ? props.node.taskType : props.node.label ? props.node.label : props.node.name)),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: \"#\", onClick: (event) => props.onCloneNode(props.node, event), onFocus: props.onFocus, className: \"canvas__html-shape-bar-icon far fa-clone\" }),\r\n                !!settings.hasConfigMenu && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: \"#\", onFocus: props.onFocus, onClick: (event) => props.onShowNodeSettings(props.node, settings, event), className: \"canvas__html-shape-bar-icon fas fa-cog\" }),\r\n                htmlPlugin == \"formNode\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: \"#\", onFocus: props.onFocus, onClick: (event) => props.onShowNodeEditor(props.node, settings, event), className: \"canvas__html-shape-bar-icon fas fa-window-maximize\" })),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-body\", style: { ...(settings && settings.styleShapeBody) } }, props.renderHtmlNode && props.renderHtmlNode(nodeClone, props.flowrunnerConnector, props.flowMemo, settings, props.formNodesubject, props.flowId)),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-start canvas__html-shape-0\", onMouseOver: (event) => props.onMouseConnectionStartOver(props.node, false, event), onMouseOut: (event) => props.onMouseConnectionStartOut(props.node, false, event), onMouseDown: (event) => props.onMouseConnectionStartStart(props.node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbFollowFlow.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, event), onMouseMove: (event) => props.onMouseConnectionStartMove(props.node, false, event), onMouseUp: (event) => props.onMouseConnectionStartEnd(props.node, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, event) }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-startbottom\", onMouseOver: (event) => props.onMouseConnectionStartOver(props.node, false, event), onMouseOut: (event) => props.onMouseConnectionStartOut(props.node, false, event), onMouseDown: (event) => props.onMouseConnectionStartStart(props.node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbFollowFlow.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.bottom, event), onMouseMove: (event) => props.onMouseConnectionStartMove(props.node, false, event), onMouseUp: (event) => props.onMouseConnectionStartEnd(props.node, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, event) }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-endtop\", onMouseOver: (event) => props.onMouseConnectionEndOver(props.node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.top), onMouseOut: (event) => props.onMouseConnectionEndOut(props.node, false, event), onMouseDown: (event) => props.onMouseConnectionEndStart(props.node, false, event), onMouseMove: (event) => props.onMouseConnectionEndMove(props.node, false, event), onMouseUp: (event) => props.onMouseConnectionEndEnd(props.node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.top), onMouseLeave: (event) => props.onMouseConnectionEndLeave(props.node, false, event) }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-thumb-end canvas__html-shape-0\", onMouseOver: (event) => props.onMouseConnectionEndOver(props.node, false, event), onMouseOut: (event) => props.onMouseConnectionEndOut(props.node, false, event), onMouseDown: (event) => props.onMouseConnectionEndStart(props.node, false, event), onMouseMove: (event) => props.onMouseConnectionEndMove(props.node, false, event), onMouseUp: (event) => props.onMouseConnectionEndEnd(props.node, false, event), onMouseLeave: (event) => props.onMouseConnectionEndLeave(props.node, false, event) }),\r\n            settings.events && settings.events.map((event, eventIndex) => {\r\n                return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"canvas__html-shape-event canvas__html-shape-\" + (eventIndex + 1), key: \"_\" + props.node.name + (props.flowId || \"\") + \"-\" + eventIndex });\r\n            }));\r\n    }\r\n    return null;\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/canvas-components/html-node.tsx?");

/***/ }),

/***/ "./src/components/canvas/canvas-components/konva-node.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KonvaNode\": () => (/* binding */ KonvaNode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/index.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n/* harmony import */ var _services_position_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/services/position-service.ts\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _shapes_thumbs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./src/components/canvas/shapes/thumbs.tsx\");\n/* harmony import */ var _shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./src/components/canvas/shapes/thumbsstart.tsx\");\n/* harmony import */ var _state_nodes_touched__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./src/state/nodes-touched.ts\");\n/* harmony import */ var _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst KonvaNode = (props) => {\r\n    let shapeType = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getShapeType(props.node.shapeType, props.node.taskType, props.node.isStartEnd), [props.node]);\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_3__.ShapeSettings.getShapeSettings(props.node.taskType, props.node), [props.node]);\r\n    const flowStore = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_5__.useFlowStore)();\r\n    const touchedNodesStore = (0,_state_nodes_touched__WEBPACK_IMPORTED_MODULE_8__.useNodesTouchedStateStore)();\r\n    if (shapeType === \"Html\") {\r\n        return null;\r\n    }\r\n    const Shape = _shapes__WEBPACK_IMPORTED_MODULE_1__.Shapes[shapeType];\r\n    let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.getPosition)(props.node.name);\r\n    if (!position) {\r\n        if (props.node.shapeType !== \"Line\") {\r\n            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.setPosition)(props.node.name, {\r\n                x: props.node.x,\r\n                y: props.node.y\r\n            });\r\n        }\r\n        else {\r\n            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.setPosition)(props.node.name, {\r\n                xstart: props.node.xstart,\r\n                ystart: props.node.ystart,\r\n                xend: props.node.xend,\r\n                yend: props.node.yend\r\n            });\r\n        }\r\n        position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.getPosition)(props.node.name);\r\n    }\r\n    if (props.node.shapeType !== \"Line\" && Shape) {\r\n        let nodeState = \"\";\r\n        nodeState = props.nodesStateLocal;\r\n        let isConnectedToSelectedNode = false;\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Shape, { x: position.x, y: position.y, name: props.node.name, flow: props.flowMemo, taskType: props.node.taskType, node: props.node, ref: ref => (props.shapeRefs.current[props.node.name] = ref), shapeRefs: props.shapeRefs, positions: _services_position_service__WEBPACK_IMPORTED_MODULE_4__.getPosition, canvasHasSelectedNode: props.canvasHasSelectedNode, nodeState: nodeState, selectedNode: undefined, onLineMouseOver: props.onMouseOver, onLineMouseOut: props.onMouseOut, onClickLine: props.onClickLine, hasTaskNameAsNodeTitle: props.hasTaskNameAsNodeTitle, onClickSetup: (event) => props.onClickSetup(props.node, settings, event), onMouseOver: (event) => props.onMouseOver(props.node, event), onMouseOut: props.onMouseOut, onDragStart: (event) => props.onDragStart(props.node, event), onDragEnd: (event) => props.onDragEnd(props.node, event), onDragMove: (event) => props.onDragMove(props.node, event), onTouchStart: (event) => props.onTouchStart(props.node, event), onTouchEnd: (event) => props.onMouseEnd(props.node, event), onTouchMove: (event) => props.onMouseMove(props.node, event), onClickShape: (event) => props.onClickShape(props.node, event), onMouseStart: (event) => props.onMouseStart(props.node, event), onMouseMove: (event) => props.onMouseMove(props.node, event), onMouseEnd: (event) => props.onMouseEnd(props.node, event), onMouseLeave: (event) => props.onMouseLeave(props.node, event), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, getNodeInstance: props.getNodeInstance, touchedNodes: touchedNodesStore.nodesTouched }),\r\n            (shapeType === \"Rect\" || (shapeType === \"Diamond\" && !settings.altThumbPositions) || shapeType === \"Html\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasInputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbs__WEBPACK_IMPORTED_MODULE_6__.Thumbs, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbEndPosition(shapeType, position), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumb_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, onMouseConnectionEndOver: (event) => props.onMouseConnectionEndOver(props.node, false, event), onMouseConnectionEndOut: (event) => props.onMouseConnectionEndOut(props.node, false, event), onMouseConnectionEndStart: (event) => props.onMouseConnectionEndStart(props.node, false, event), onMouseConnectionEndMove: (event) => props.onMouseConnectionEndMove(props.node, false, event), onMouseConnectionEndEnd: (event) => props.onMouseConnectionEndEnd(props.node, false, event), onMouseConnectionEndLeave: (event) => props.onMouseConnectionEndLeave(props.node, false, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Diamond\" && settings.altThumbPositions === 1) &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasInputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbs__WEBPACK_IMPORTED_MODULE_6__.Thumbs, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbEndPosition(shapeType, position, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumb_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, thumbPositionRelativeToNode: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top, onMouseConnectionEndOver: (event) => props.onMouseConnectionEndOver(props.node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top), onMouseConnectionEndOut: (event) => props.onMouseConnectionEndOut(props.node, false, event), onMouseConnectionEndStart: (event) => props.onMouseConnectionEndStart(props.node, false, event), onMouseConnectionEndMove: (event) => props.onMouseConnectionEndMove(props.node, false, event), onMouseConnectionEndEnd: (event) => props.onMouseConnectionEndEnd(props.node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top), onMouseConnectionEndLeave: (event) => props.onMouseConnectionEndLeave(props.node, false, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Rect\" || shapeType === \"Html\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasOutputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_7__.ThumbsStart, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumbstart_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, onMouseConnectionStartOver: (event) => props.onMouseConnectionStartOver(props.node, false, event), onMouseConnectionStartOut: (event) => props.onMouseConnectionStartOut(props.node, false, event), onMouseConnectionStartStart: (event) => props.onMouseConnectionStartStart(props.node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.default, event), onMouseConnectionStartMove: (event) => props.onMouseConnectionStartMove(props.node, false, event), onMouseConnectionStartEnd: (event) => props.onMouseConnectionStartEnd(props.node, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Html\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasOutputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_7__.ThumbsStart, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumbstartbottom_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, thumbPositionRelativeToNode: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.bottom, onMouseConnectionStartOver: (event) => props.onMouseConnectionStartOver(props.node, false, event), onMouseConnectionStartOut: (event) => props.onMouseConnectionStartOut(props.node, false, event), onMouseConnectionStartStart: (event) => props.onMouseConnectionStartStart(props.node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.bottom, event), onMouseConnectionStartMove: (event) => props.onMouseConnectionStartMove(props.node, false, event), onMouseConnectionStartEnd: (event) => props.onMouseConnectionStartEnd(props.node, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Html\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasInputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbs__WEBPACK_IMPORTED_MODULE_6__.Thumbs, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbEndPosition(shapeType, position, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumbtop_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, thumbPositionRelativeToNode: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top, onMouseConnectionEndOver: (event) => props.onMouseConnectionEndOver(props.node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top), onMouseConnectionEndOut: (event) => props.onMouseConnectionEndOut(props.node, false, event), onMouseConnectionEndStart: (event) => props.onMouseConnectionEndStart(props.node, false, event), onMouseConnectionEndMove: (event) => props.onMouseConnectionEndMove(props.node, false, event), onMouseConnectionEndEnd: (event) => props.onMouseConnectionEndEnd(props.node, false, event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top), onMouseConnectionEndLeave: (event) => props.onMouseConnectionEndLeave(props.node, false, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Diamond\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasOutputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_7__.ThumbsStart, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.left), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumbstarttop_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, followFlow: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.happyFlow, thumbPositionRelativeToNode: !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.left, onMouseConnectionStartOver: (event) => props.onMouseConnectionStartOver(props.node, false, event), onMouseConnectionStartOut: (event) => props.onMouseConnectionStartOut(props.node, false, event), onMouseConnectionStartStart: (event) => props.onMouseConnectionStartStart(props.node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.happyFlow, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.left, event), onMouseConnectionStartMove: (event) => props.onMouseConnectionStartMove(props.node, false, event), onMouseConnectionStartEnd: (event) => props.onMouseConnectionStartEnd(props.node, false, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.top : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.left, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Diamond\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasOutputs(shapeType, settings) &&\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_7__.ThumbsStart, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbStartPosition(shapeType, position, 0, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.right), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumbstartbottom_\" + props.node.name] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, followFlow: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.unhappyFlow, thumbPositionRelativeToNode: !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.right, onMouseConnectionStartOver: (event) => props.onMouseConnectionStartOver(props.node, false, event), onMouseConnectionStartStart: (event) => props.onMouseConnectionStartStart(props.node, false, \"\", _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.unhappyFlow, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.right, event), onMouseConnectionStartMove: (event) => props.onMouseConnectionStartMove(props.node, false, event), onMouseConnectionStartEnd: (event) => props.onMouseConnectionStartEnd(props.node, false, !settings.altThumbPositions ? _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.bottom : _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.right, event), getNodeInstance: props.getNodeInstance }),\r\n            (shapeType === \"Rect\" || shapeType === \"Html\") &&\r\n                _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getHasOutputs(shapeType, settings) &&\r\n                settings.events && settings.events.map((event, eventIndex) => {\r\n                return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_thumbsstart__WEBPACK_IMPORTED_MODULE_7__.ThumbsStart, { key: \"node-thumbstart-\" + props.flowId + props.node.name + \"-\" + eventIndex, position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getThumbStartPosition(shapeType, position, eventIndex + 1), name: props.node.name, taskType: props.node.taskType, shapeType: shapeType, node: props.node, ref: ref => (props.shapeRefs.current[\"thumbstartevent_\" + props.node.name + eventIndex] = ref), isSelected: false, isConnectedToSelectedNode: isConnectedToSelectedNode, canvasHasSelectedNode: props.canvasHasSelectedNode, onMouseConnectionStartOver: (event) => props.onMouseConnectionStartOver(props.node, eventIndex, event), onMouseConnectionStartOut: (event) => props.onMouseConnectionStartOut(props.node, eventIndex, event), onMouseConnectionStartStart: (event) => props.onMouseConnectionStartStart(props.node, eventIndex, event.eventName, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbFollowFlow.event, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.default, event), onMouseConnectionStartMove: (event) => props.onMouseConnectionStartMove(props.node, eventIndex, event), onMouseConnectionStartEnd: (event) => props.onMouseConnectionStartEnd(props.node, eventIndex, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_9__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance });\r\n            }));\r\n    }\r\n    return null;\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/canvas-components/konva-node.tsx?");

/***/ }),

/***/ "./src/components/canvas/canvas-types/interaction-state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InteractionState\": () => (/* binding */ InteractionState)\n/* harmony export */ });\nvar InteractionState;\r\n(function (InteractionState) {\r\n    InteractionState[InteractionState[\"idle\"] = 0] = \"idle\";\r\n    InteractionState[InteractionState[\"draggingNode\"] = 1] = \"draggingNode\";\r\n    InteractionState[InteractionState[\"draggingConnectionStart\"] = 2] = \"draggingConnectionStart\";\r\n    InteractionState[InteractionState[\"draggingConnectionEnd\"] = 3] = \"draggingConnectionEnd\";\r\n    InteractionState[InteractionState[\"addingNewNode\"] = 4] = \"addingNewNode\";\r\n    InteractionState[InteractionState[\"addingNewConnection\"] = 5] = \"addingNewConnection\";\r\n    InteractionState[InteractionState[\"draggingNodesByConnection\"] = 6] = \"draggingNodesByConnection\";\r\n    InteractionState[InteractionState[\"draggingNodesDownstream\"] = 7] = \"draggingNodesDownstream\";\r\n    InteractionState[InteractionState[\"draggingNodesUpstream\"] = 8] = \"draggingNodesUpstream\";\r\n    InteractionState[InteractionState[\"selectingNodes\"] = 9] = \"selectingNodes\";\r\n    InteractionState[InteractionState[\"multiSelect\"] = 10] = \"multiSelect\";\r\n})(InteractionState || (InteractionState = {}));\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/canvas-types/interaction-state.ts?");

/***/ }),

/***/ "./src/components/canvas/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/index.tsx\");\n/* harmony import */ var _shapes_lines_for_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/lines-for-shape.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/config.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _dragging_task__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./src/dragging-task.tsx\");\n/* harmony import */ var _helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"./src/helpers/flow-methods.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"./src/components/flow/index.tsx\");\n/* harmony import */ var _helpers_line_points__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"./src/helpers/line-points.ts\");\n/* harmony import */ var _edit_node_settings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"./src/components/edit-node-settings/index.tsx\");\n/* harmony import */ var _edit_node__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"./src/components/edit-node/index.tsx\");\n/* harmony import */ var _canvas_components_html_node__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(\"./src/components/canvas/canvas-components/html-node.tsx\");\n/* harmony import */ var _canvas_components_konva_node__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(\"./src/components/canvas/canvas-components/konva-node.tsx\");\n/* harmony import */ var _services_position_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(\"./src/services/position-service.ts\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(\"./src/state/canvas-mode-state.ts\");\n/* harmony import */ var _state_selected_node_state__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(\"./src/state/selected-node-state.ts\");\n/* harmony import */ var _state_nodes_touched__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(\"./src/state/nodes-touched.ts\");\n/* harmony import */ var _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _html_plugins_form_controls_helpers_focus__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(\"./src/components/html-plugins/form-controls/helpers/focus.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(\"./node_modules/uuid/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_24__);\n/* harmony import */ var _use_flows__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(\"./src/use-flows.ts\");\n/* harmony import */ var _taskbar__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(\"./src/components/taskbar/index.tsx\");\n/* harmony import */ var _dnd_kit_modifiers__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(\"./node_modules/@dnd-kit/modifiers/dist/modifiers.esm.js\");\n/* harmony import */ var _helpers_error__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(\"./src/helpers/error.tsx\");\n/* harmony import */ var konva__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(\"./node_modules/konva/lib/index.js\");\n/* harmony import */ var _konva_Tween__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(\"./src/components/canvas/konva/Tween.ts\");\n/* harmony import */ var _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(\"./src/components/canvas/canvas-types/interaction-state.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst uuidV4 = uuid__WEBPACK_IMPORTED_MODULE_24__.v4;\r\nconst Canvas = (props) => {\r\n    const [stageWidth, setStageWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [stageHeight, setStageHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [canvasOpacity, setCanvasOpacity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [canvasKey, setCanvasKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\r\n    const [showNodeSettings, setShowNodeSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\r\n    const [showNodeEdit, setShowNodeEdit] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\r\n    const [editNode, setEditNode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\r\n    const [editNodeSettings, setEditNodeSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\r\n    const [isConnectingNodesByDragging, setIsConnectingNodesByDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\r\n    const [connectionX, setConnectionX] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [connectionY, setConnectionY] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [updateNodeTouchedState, setUpdateNodeTouchedState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\r\n    const [activeId, setActiveId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\r\n    const { isOver, setNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_7__.useDroppable)({ id: 'droppable' });\r\n    const flowStore = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_18__.useFlowStore)();\r\n    const canvasMode = (0,_state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_19__.useCanvasModeStateStore)();\r\n    const selectNode = (0,_state_selected_node_state__WEBPACK_IMPORTED_MODULE_20__.useSelectedNodeStore)(state => state.selectNode);\r\n    const touchedNodesStore = (0,_state_nodes_touched__WEBPACK_IMPORTED_MODULE_21__.useNodesTouchedStateStore)();\r\n    const gridSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(50);\r\n    let stage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let canvasWrapper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let htmlWrapper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let layer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let stageGroup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let selectingRectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let lastMousePositionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let flowIsLoading = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\r\n    let flowIsFittedStageForSingleNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let closestNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let orientationClosestNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let nodeOrientationClosestNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n    let closestStartNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let closestEndNodeWhenAddingNewNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let closestNodeAreLineNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let draggingMultipleNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\r\n    let selectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\r\n    let selectingRectInfo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let shapeRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\r\n    let elementRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\r\n    const connectionForDraggingName = \"_connection-dragging\";\r\n    let oldwheeltime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let nodesStateLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\r\n    let touchedNodesLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\r\n    let dragTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let touching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let touchNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let touchNodeGroup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let isConnectingNodesByDraggingLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let mouseStartX = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let mouseStartY = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let mouseEndX = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let mouseEndY = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let mouseStartPointerX = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let mouseStartPointerY = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let stageScale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(1.0);\r\n    let stageX = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0.0);\r\n    let stageY = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0.0);\r\n    let mouseDragging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let isPinching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let pinchStartPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ x: 0, y: 0 });\r\n    let startDistance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let unmounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let connectionXStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let connectionYStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    let connectionNodeEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((false));\r\n    let connectionNodeEventName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\r\n    let connectionNodeThumbs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\r\n    let connectionNodeThumbsLineNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let connectionNodeThumbPositionRelativeToNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n    let connectionNodeThumbPositionRelativeToEndNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n    let connectionNodeFollowFlow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.default);\r\n    let shiftDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let ctrlDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    let animationScript = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    let interactionState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle);\r\n    const selectedNodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_state_selected_node_state__WEBPACK_IMPORTED_MODULE_20__.useSelectedNodeStore.getState().node);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => _state_selected_node_state__WEBPACK_IMPORTED_MODULE_20__.useSelectedNodeStore.subscribe((node, previousNode) => {\r\n        console.log(\"useSelectedNodeStore.subscribe\", node.name);\r\n        selectedNodeRef.current = node;\r\n        if (previousNode && previousNode.node) {\r\n            const barElement = document.querySelector(`#${previousNode.node.id} .canvas__html-shape-bar`);\r\n            if (barElement) {\r\n                barElement.classList.remove(\"canvas__html-shape-bar--selected\");\r\n            }\r\n            const htmlElement = document.querySelector(`#${previousNode.node.id}.canvas__html-shape`);\r\n            if (htmlElement) {\r\n                htmlElement.classList.add(\"canvas__html-shape\");\r\n            }\r\n            else {\r\n                const shapeRef = shapeRefs.current[previousNode.node.id];\r\n                if (shapeRef) {\r\n                    shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                        state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Default\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (node && node.node) {\r\n            const barElement = document.querySelector(`#${node.node.id} .canvas__html-shape-bar`);\r\n            if (barElement) {\r\n                barElement.classList.add(\"canvas__html-shape-bar--selected\");\r\n            }\r\n            const htmlElement = document.querySelector(`#${node.node.id}.canvas__html-shape`);\r\n            if (htmlElement) {\r\n                htmlElement.classList.add(\"canvas__html-shape\");\r\n            }\r\n            else {\r\n                const shapeRef = shapeRefs.current[node.node.id];\r\n                if (shapeRef) {\r\n                    shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                        state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Selected\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }, state => state.node), []);\r\n    const droppableStyle = { color: isOver ? 'green' : undefined };\r\n    const ctrlKey = 17;\r\n    const shiftKey = 16;\r\n    const cmdKey = 91;\r\n    const pasteKey = 86;\r\n    const backspaceKey = 8;\r\n    const fKeyCapt = 70;\r\n    const fKey = 102;\r\n    let wheelTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const onDocumentMouseMove = (event) => {\r\n        lastMousePositionRef.current = event;\r\n    };\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        document.addEventListener(\"mousemove\", onDocumentMouseMove);\r\n        gridSize.current = canvasMode.snapToGrid ? 50 : 1;\r\n        return () => {\r\n            document.removeEventListener(\"mousemove\", onDocumentMouseMove);\r\n        };\r\n    }, []);\r\n    const wheelEnableLayoutOnTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\r\n        if (layer && layer.current) {\r\n            layer.current.listening(true);\r\n            layer.current.batchDraw();\r\n        }\r\n    }, [flowStore.flow]);\r\n    const wheelEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, touchPosition) => {\r\n        if (wheelTimeout.current) {\r\n            clearTimeout(wheelTimeout.current);\r\n            wheelTimeout.current = undefined;\r\n        }\r\n        if (e.toElement && e.toElement.closest) {\r\n            let element = e.toElement.closest(\".no-wheel\");\r\n            if (element) {\r\n                return true;\r\n            }\r\n        }\r\n        if (layer && layer.current && layer.current.isListening()) {\r\n            layer.current.listening(false);\r\n        }\r\n        wheelTimeout.current = setTimeout(wheelEnableLayoutOnTimeout, 500);\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            let scaleBy = 1.23;\r\n            scaleBy = 1.13;\r\n            if (stageInstance !== undefined && stageInstance.getPointerPosition()) {\r\n                const oldScale = stageInstance.scaleX();\r\n                let xPos = stageInstance.getPointerPosition().x;\r\n                let yPos = stageInstance.getPointerPosition().y;\r\n                if (isPinching.current && touchPosition) {\r\n                    xPos = touchPosition.x;\r\n                    yPos = touchPosition.y;\r\n                }\r\n                const mousePointTo = {\r\n                    x: xPos / oldScale - stageInstance.x() / oldScale,\r\n                    y: yPos / oldScale - stageInstance.y() / oldScale,\r\n                };\r\n                const newScale = e.deltaY > 0 ? oldScale * scaleBy : oldScale / scaleBy;\r\n                const startPerf = performance.now();\r\n                stageInstance.scale({ x: newScale, y: newScale });\r\n                const newPos = {\r\n                    x: -(mousePointTo.x - xPos / newScale) * newScale,\r\n                    y: -(mousePointTo.y - yPos / newScale) * newScale\r\n                };\r\n                const newPosHtml = {\r\n                    x: -(mousePointTo.x - xPos / newScale),\r\n                    y: -(mousePointTo.y - yPos / newScale)\r\n                };\r\n                stageInstance.position(newPos);\r\n                stageInstance.batchDraw();\r\n                stageX.current = newPos.x;\r\n                stageY.current = newPos.y;\r\n                stageScale.current = newScale;\r\n                setHtmlGlobalScale(newPos.x, newPos.y, newScale);\r\n            }\r\n            oldwheeltime.current = performance.now();\r\n        }\r\n        return false;\r\n    }, [flowStore.flow]);\r\n    const updateDimensions = () => {\r\n        const stageContainerElement = document.querySelector(\".stage-container\");\r\n        const bodyElement = document.querySelector(\"body\");\r\n        if (stageContainerElement !== null && bodyElement !== null) {\r\n            let widthCanvas = stageContainerElement.clientWidth;\r\n            let heightCanvas = bodyElement.clientHeight;\r\n            if (heightCanvas < 500) {\r\n                heightCanvas = 500;\r\n            }\r\n            setStageWidth(widthCanvas);\r\n            setStageHeight(heightCanvas);\r\n        }\r\n    };\r\n    const onPaste = async (event) => {\r\n        let text;\r\n        if (navigator.clipboard) {\r\n            text = await navigator.clipboard.readText();\r\n        }\r\n        else {\r\n            text = event.clipboardData.getData('text/plain');\r\n        }\r\n        if (event && event.target && event.target.tagName !== \"BODY\") {\r\n            return;\r\n        }\r\n        let pastedData;\r\n        event.stopPropagation();\r\n        event.preventDefault();\r\n        pastedData = text;\r\n        let columnCount = 0;\r\n        let rowCount = 0;\r\n        let values = [];\r\n        let lines = pastedData.split(/\\r?\\n/);\r\n        lines.forEach((line, index) => {\r\n            let insertValues = [];\r\n            line.split(/\\t/).forEach((value, index) => {\r\n                if (lines.length == 1) {\r\n                    const numericValue = parseInt(value);\r\n                    if (!isNaN(numericValue)) {\r\n                        values.push(numericValue);\r\n                    }\r\n                    else {\r\n                        values.push((value || \"\").toString());\r\n                    }\r\n                }\r\n                else {\r\n                    const numericValue = parseInt(value);\r\n                    if (!isNaN(numericValue)) {\r\n                        insertValues.push(numericValue);\r\n                    }\r\n                    else {\r\n                        insertValues.push((value || \"\").toString());\r\n                    }\r\n                }\r\n            });\r\n            if (lines.length > 1) {\r\n                values.push(insertValues);\r\n                if (insertValues.length > columnCount) {\r\n                    columnCount = insertValues.length;\r\n                }\r\n            }\r\n            else {\r\n                columnCount = values.length;\r\n            }\r\n        });\r\n        rowCount = lines.length;\r\n        if (touchNode.current && touchNodeGroup.current) {\r\n            event.preventDefault();\r\n            return false;\r\n        }\r\n        const nodeIsSelected = !!selectedNodeRef.current;\r\n        if (!nodeIsSelected) {\r\n            if (!canvasMode.isConnectingNodes) {\r\n                if (stage && stage.current) {\r\n                    let stageInstance = stage.current.getStage();\r\n                    const position = stageInstance.getPointerPosition();\r\n                    const scaleFactor = stageInstance.scaleX();\r\n                    const taskType = \"DataGridTask\";\r\n                    let presetValues = {};\r\n                    const shapeSetting = (0,_config__WEBPACK_IMPORTED_MODULE_5__.getTaskConfigForTask)(taskType);\r\n                    if (shapeSetting && shapeSetting.presetValues) {\r\n                        presetValues = shapeSetting.presetValues;\r\n                    }\r\n                    let id = uuidV4();\r\n                    let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewNode)({\r\n                        name: id,\r\n                        id: id,\r\n                        label: \"DataGrid\",\r\n                        taskType: taskType,\r\n                        shapeType: \"Html\",\r\n                        x: ((position.x - (stageInstance).x()) / scaleFactor),\r\n                        y: ((position.y - (stageInstance).y()) / scaleFactor),\r\n                        ...presetValues,\r\n                        values,\r\n                        columns: columnCount,\r\n                        rows: rowCount\r\n                    }, flowStore.flow);\r\n                    let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeType(newNode.shapeType, newNode.taskType, newNode.isStartEnd);\r\n                    let centerXCorrection = 0;\r\n                    let centerYCorrection = 0;\r\n                    if (shapeType == \"Rect\" || shapeType == \"Ellipse\") {\r\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectWidht / 2;\r\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectHeight / 2;\r\n                    }\r\n                    else if (shapeType == \"Circle\") {\r\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize / 2;\r\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize / 2;\r\n                    }\r\n                    else if (shapeType == \"Diamond\") {\r\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize / 2;\r\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize / 2;\r\n                    }\r\n                    newNode.x = newNode.x - centerXCorrection;\r\n                    newNode.y = newNode.y - centerYCorrection;\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\r\n                        x: newNode.x,\r\n                        y: newNode.y\r\n                    });\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(newNode.name, {\r\n                        x: newNode.x,\r\n                        y: newNode.y\r\n                    });\r\n                    flowStore.addFlowNode(newNode);\r\n                }\r\n            }\r\n        }\r\n        selectNode(\"\", undefined);\r\n        canvasMode.setConnectiongNodeCanvasMode(false);\r\n        canvasMode.setSelectedTask(\"\");\r\n        return false;\r\n    };\r\n    const nodeStateList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\r\n    const nodeStateCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\r\n    const nodeStateTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\r\n    const nodeStateTimeoutCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\r\n        nodeStateList.current.map((nodeState) => {\r\n            let nodeStateClass = nodeState.nodeState == \"error\" ? \"has-error\" : \"\";\r\n            const element = elementRefs.current[nodeState.nodeName];\r\n            if (element) {\r\n                element.classList.remove(\"has-error\");\r\n                if (nodeStateClass != \"\") {\r\n                    element.classList.add(nodeStateClass);\r\n                }\r\n            }\r\n            const shapeRef = shapeRefs.current[nodeState.nodeName];\r\n            let newShapeState = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Default;\r\n            if (nodeState.nodeState == \"ok\") {\r\n                newShapeState = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Ok;\r\n            }\r\n            else if (nodeState.nodeState == \"error\") {\r\n                newShapeState = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Error;\r\n            }\r\n            if (shapeRef) {\r\n                shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                    state: newShapeState\r\n                });\r\n            }\r\n        });\r\n        Object.keys(touchedNodesLocal.current).map((touchNodeId) => {\r\n            const lineRef = shapeRefs.current[touchNodeId];\r\n            if (lineRef && lineRef && lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.GetShapeType, {}) == \"line\") {\r\n                return;\r\n            }\r\n            const element = elementRefs.current[touchNodeId];\r\n            if (element) {\r\n                if (touchedNodesLocal.current[touchNodeId] === true) {\r\n                    element.classList.remove(\"untouched\");\r\n                }\r\n                else {\r\n                    element.classList.add(\"untouched\");\r\n                }\r\n            }\r\n            else {\r\n                if (!touchedNodesLocal.current[touchNodeId] &&\r\n                    nodesStateLocal.current[touchNodeId] != \"\") {\r\n                    nodesStateLocal.current[touchNodeId] = \"\";\r\n                    const shapeRef = shapeRefs.current[touchNodeId];\r\n                    if (shapeRef) {\r\n                        shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                            state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Default\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        updateTouchedNodes();\r\n        nodeStateList.current = [];\r\n        nodeStateCount.current = 0;\r\n    }, [flowStore.flow]);\r\n    const nodeStateObserver = (nodeName, nodeState, _touchedNodes) => {\r\n        if (!updateNodeTouchedState) {\r\n            return;\r\n        }\r\n        if (nodeStateTimeout.current) {\r\n            clearTimeout(nodeStateTimeout.current);\r\n            nodeStateTimeout.current = undefined;\r\n        }\r\n        if (nodeState === \"RESET_ALL\") {\r\n            nodeStateList.current = [];\r\n            nodeStateCount.current = 0;\r\n            Object.keys(elementRefs.current).map((nodeName) => {\r\n                const element = elementRefs.current[nodeName];\r\n                if (element) {\r\n                    element.classList.remove(\"has-error\");\r\n                }\r\n            });\r\n            Object.keys(shapeRefs.current).map((nodeName) => {\r\n                const shapeRef = shapeRefs.current[nodeName];\r\n                if (shapeRef) {\r\n                    shapeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                        state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Default\r\n                    });\r\n                }\r\n            });\r\n            return;\r\n        }\r\n        nodeStateCount.current += 1;\r\n        nodeStateList.current.push({\r\n            nodeState: nodeState,\r\n            nodeName: nodeName\r\n        });\r\n        nodeStateTimeout.current = setTimeout(nodeStateTimeoutCallback, 30);\r\n        touchedNodesLocal.current = _touchedNodes;\r\n        nodesStateLocal.current[nodeName] = nodeState;\r\n    };\r\n    const cancelScroll = () => {\r\n        window.scrollTop = 0;\r\n        window.scrollLeft = 0;\r\n        document.body.scrollTop = 0;\r\n    };\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\r\n        window.addEventListener(\"resize\", onResize);\r\n        window.addEventListener(\"scroll\", cancelScroll);\r\n        document.addEventListener('paste', onPaste);\r\n        updateDimensions();\r\n        document.body.scrollTop = 0;\r\n        touchedNodesStore.clearNodesTouched();\r\n        props.flowrunnerConnector.unregisterNodeStateObserver(\"canvas\");\r\n        props.flowrunnerConnector.registerNodeStateObserver(\"canvas\", nodeStateObserver);\r\n        return () => {\r\n            props.flowrunnerConnector.unregisterNodeStateObserver(\"canvas\");\r\n            window.removeEventListener(\"resize\", onResize);\r\n            window.removeEventListener(\"scroll\", cancelScroll);\r\n        };\r\n    }, []);\r\n    const onResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\r\n        updateDimensions();\r\n        fitStage(undefined, true, true);\r\n    }, [flowStore.flow]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        let subscription;\r\n        if (props.canvasToolbarsubject) {\r\n            subscription = props.canvasToolbarsubject.subscribe({\r\n                next: (message) => {\r\n                    if (unmounted.current) {\r\n                        return;\r\n                    }\r\n                    if (message == \"loadFlow\") {\r\n                        flowIsLoading.current = true;\r\n                        setCanvasOpacity(0);\r\n                    }\r\n                    else if (message == \"fitStage\") {\r\n                        fitStage(undefined, true, true);\r\n                        setCanvasOpacity(1);\r\n                    }\r\n                    else if (message == \"reload\") {\r\n                        setCanvasKey(canvasKey + 1);\r\n                    }\r\n                    else if (message == \"export\") {\r\n                        exportCanvas();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return () => {\r\n            if (subscription) {\r\n                subscription.unsubscribe();\r\n            }\r\n        };\r\n    }, [flowStore.flow]);\r\n    const updateTouchedNodes = () => {\r\n        if (touchedNodesLocal.current) {\r\n            if (stage && stage.current) {\r\n                let stageInstance = stage.current.getStage();\r\n                if (stageInstance) {\r\n                    Object.keys(shapeRefs.current).forEach((touchNodeId) => {\r\n                        const lineRef = shapeRefs.current[touchNodeId];\r\n                        if (lineRef && lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.GetShapeType, {}) == \"line\") {\r\n                            if (touchedNodesLocal.current[touchNodeId]) {\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                                    state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Touched\r\n                                });\r\n                            }\r\n                            else {\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetState, {\r\n                                    state: _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ShapeStateEnum.Default\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                    stageInstance.batchDraw();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const recalculateStartEndpoints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((doBatchdraw) => {\r\n        const startPerf = performance.now();\r\n        flowStore.flow.forEach((node, index) => {\r\n            if (node.shapeType !== \"Line\") {\r\n                let shapeRef = shapeRefs.current[node.name];\r\n                if (shapeRef) {\r\n                    let element = elementRefs.current[node.name];\r\n                    if (element) {\r\n                        const position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name) || { x: node.x, y: node.y };\r\n                        let x = parseFloat(element.getAttribute(\"data-x\") || \"\");\r\n                        let y = parseFloat(element.getAttribute(\"data-y\") || \"\");\r\n                        if (node && element.getAttribute(\"data-node\") == node.name) {\r\n                            x = position.x;\r\n                            y = position.y;\r\n                            element.setAttribute(\"data-x\", x.toString());\r\n                            element.setAttribute(\"data-y\", y.toString());\r\n                        }\r\n                        const nodeName = element.getAttribute(\"data-node\") || \"\";\r\n                        setHtmlElementStyle(element, 0, 0, 1, x, y);\r\n                        setNewPositionForNode(undefined, node, shapeRef, { x: position.x, y: position.y }, false, true, doBatchdraw, true);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        setHtmlGlobalScale(stageX.current, stageY.current, stageScale.current);\r\n        if (!!doBatchdraw && stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                stageInstance.batchDraw();\r\n            }\r\n        }\r\n    }, [flowStore.flow]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\r\n        window.addEventListener(\"resize\", onResize);\r\n        const lineRef = shapeRefs.current[connectionForDraggingName];\r\n        if (lineRef) {\r\n            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n        }\r\n        const startPerf = performance.now();\r\n        if (props.flow && props.flow.length > 0) {\r\n            if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_25__.FlowState.loading || props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_25__.FlowState.idle) {\r\n                setCanvasOpacity(0);\r\n                flowIsLoading.current = true;\r\n                if (selectedNodeRef.current && selectedNodeRef.current.node !== undefined) {\r\n                    selectNode(\"\", undefined);\r\n                }\r\n            }\r\n            else if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_25__.FlowState.loaded && flowIsLoading.current) {\r\n                if (canvasOpacity == 0) {\r\n                    setCanvasOpacity(1);\r\n                }\r\n                flowIsLoading.current = false;\r\n                flowIsFittedStageForSingleNode.current = true;\r\n                let perfstart = performance.now();\r\n                (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.clearPositions)();\r\n                perfstart = performance.now();\r\n                flowStore.flow.map((node, index) => {\r\n                    if (node.x !== undefined && node.y !== undefined) {\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                            x: node.x,\r\n                            y: node.y\r\n                        });\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(node.name, {\r\n                            x: node.x,\r\n                            y: node.y\r\n                        });\r\n                    }\r\n                    if (node.xstart !== undefined && node.ystart !== undefined) {\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                            xstart: node.xstart,\r\n                            ystart: node.ystart,\r\n                            xend: node.xend,\r\n                            yend: node.yend\r\n                        });\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(node.name, {\r\n                            xstart: node.xstart,\r\n                            ystart: node.ystart,\r\n                            xend: node.xend,\r\n                            yend: node.yend\r\n                        });\r\n                    }\r\n                });\r\n                perfstart = performance.now();\r\n                nodesStateLocal.current = {};\r\n                touchedNodesLocal.current = {};\r\n                fitStage(undefined, false, false);\r\n                if (stage && stage.current) {\r\n                    let stageDiv = stage.current;\r\n                    if (stageDiv && stageDiv.attrs[\"container\"]) {\r\n                        stageDiv.attrs[\"container\"].parentNode.focus();\r\n                    }\r\n                }\r\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\r\n                recalculateStartEndpoints(false);\r\n            }\r\n            else if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_25__.FlowState.loaded && !flowIsLoading.current) {\r\n                if (flowStore.flow.length == 1) {\r\n                    if (!flowIsFittedStageForSingleNode.current) {\r\n                        fitStage(undefined, false, false);\r\n                        flowIsFittedStageForSingleNode.current = true;\r\n                    }\r\n                }\r\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\r\n                recalculateStartEndpoints(false);\r\n            }\r\n            touchedNodesStore.setNodesTouched(touchedNodesLocal.current);\r\n            let disabledUpdateTouchedState = false;\r\n            flowStore.flow.map((node, index) => {\r\n                if (node.taskType === \"TimerTask\" ||\r\n                    (node.taskType == \"DebugTask\" &&\r\n                        node.visualizer == \"animatedgridcanvas\")) {\r\n                    disabledUpdateTouchedState = true;\r\n                }\r\n            });\r\n            if (!!disabledUpdateTouchedState) {\r\n                setUpdateNodeTouchedState(false);\r\n            }\r\n            else {\r\n                setUpdateNodeTouchedState(true);\r\n            }\r\n        }\r\n        else if (flowStore && flowStore.flow.length == 0) {\r\n            flowIsFittedStageForSingleNode.current = false;\r\n            if (props.flowState == _use_flows__WEBPACK_IMPORTED_MODULE_25__.FlowState.loaded) {\r\n                if (canvasOpacity == 0) {\r\n                    setCanvasOpacity(1);\r\n                }\r\n            }\r\n        }\r\n        deselectAllNodes();\r\n        interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n        selectingRectRef.current.opacity(0);\r\n        if (stage && stage.current) {\r\n            const stageInstance = stage.current.getStage();\r\n            stageInstance.batchDraw();\r\n        }\r\n        updateTouchedNodes();\r\n        return () => {\r\n            document.removeEventListener('paste', onPaste);\r\n            window.removeEventListener(\"resize\", onResize);\r\n        };\r\n    }, [props.flowState, flowStore.flow]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\r\n        updateTouchedNodes();\r\n    }, [\r\n        canvasMode,\r\n        props.canvasToolbarsubject,\r\n        stageWidth,\r\n        stageHeight,\r\n        canvasOpacity,\r\n        showNodeSettings,\r\n        editNode,\r\n        editNodeSettings,\r\n        isConnectingNodesByDragging,\r\n        connectionX,\r\n        connectionY\r\n    ]);\r\n    const setNewPositionForNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, node, group, position, isCommitingToStore, linesOnly, doDraw, skipSetHtml, isEndNode, offsetPosition) => {\r\n        const unselectedNodeOpacity = 0.15;\r\n        if (!linesOnly) {\r\n            if (draggingMultipleNodes.current && draggingMultipleNodes.current.length == 0) {\r\n                flowStore.flow.map((flowNode) => {\r\n                    if (flowNode.name !== node.name) {\r\n                        const element = elementRefs.current[flowNode.name];\r\n                        if (element) {\r\n                            element.style.opacity = \"1\";\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        let resultXY = group && group.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.GetXY, {});\r\n        const x = resultXY ? resultXY.x : 0;\r\n        const y = resultXY ? resultXY.y : 0;\r\n        let newPosition = position || { x: x, y: y };\r\n        if (offsetPosition !== undefined) {\r\n            let mappedNode = flowStore.flowHashmap.get(node.name);\r\n            if (mappedNode) {\r\n                let flowNode = flowStore.flow[mappedNode.index];\r\n                if (flowNode) {\r\n                    let committedPosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getCommittedPosition)(flowNode.name);\r\n                    if (committedPosition) {\r\n                        newPosition = {\r\n                            x: committedPosition.x + offsetPosition.x,\r\n                            y: committedPosition.y + offsetPosition.y\r\n                        };\r\n                    }\r\n                    else {\r\n                        newPosition = {\r\n                            x: flowNode.x + offsetPosition.x,\r\n                            y: flowNode.y + offsetPosition.y\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        newPosition.x = newPosition.x - (newPosition.x % gridSize.current);\r\n        newPosition.y = newPosition.y - (newPosition.y % gridSize.current);\r\n        if (newPosition && !linesOnly) {\r\n            if (stage && stage.current && offsetPosition === undefined) {\r\n                let stageInstance = stage.current.getStage();\r\n                if (stageInstance) {\r\n                    let touchPos = getCurrentPosition(event);\r\n                    if (touchPos) {\r\n                        const scaleFactor = stageInstance.scaleX();\r\n                        if (!!isEndNode) {\r\n                            newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor) - mouseEndX.current;\r\n                            newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor) - mouseEndY.current;\r\n                        }\r\n                        else {\r\n                            newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor) - mouseStartX.current;\r\n                            newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor) - mouseStartY.current;\r\n                        }\r\n                        newPosition.x = newPosition.x - (newPosition.x % gridSize.current);\r\n                        newPosition.y = newPosition.y - (newPosition.y % gridSize.current);\r\n                    }\r\n                }\r\n            }\r\n            if (shapeRefs.current[node.name]) {\r\n                const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n                const shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeType(node.shapeType, node.taskType, node.isStartEnd);\r\n                let currentGroup = shapeRefs.current[node.name];\r\n                if (currentGroup && shapeType !== \"Line\") {\r\n                    currentGroup.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, newPosition);\r\n                    currentGroup.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                }\r\n                let diamondThumb = 0;\r\n                if (shapeType === \"Diamond\") {\r\n                    if (!settings.altThumbPositions) {\r\n                        diamondThumb = 1;\r\n                    }\r\n                    else if (settings.altThumbPositions === 1) {\r\n                        diamondThumb = 2;\r\n                    }\r\n                }\r\n                let currentGroupThumbs = shapeRefs.current[\"thumb_\" + node.name];\r\n                if (currentGroupThumbs) {\r\n                    let thumbPosition;\r\n                    if (diamondThumb === 2) {\r\n                        thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbEndPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top);\r\n                    }\r\n                    else {\r\n                        thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbEndPosition(shapeType, newPosition);\r\n                    }\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, thumbPosition);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                }\r\n                currentGroupThumbs = shapeRefs.current[\"thumbtop_\" + node.name];\r\n                if (currentGroupThumbs) {\r\n                    const thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbEndPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, thumbPosition);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                }\r\n                currentGroupThumbs = shapeRefs.current[\"thumbstart_\" + node.name];\r\n                if (currentGroupThumbs) {\r\n                    const thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, thumbPosition);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                }\r\n                currentGroupThumbs = shapeRefs.current[\"thumbstarttop_\" + node.name];\r\n                if (currentGroupThumbs) {\r\n                    let thumbPosition;\r\n                    if (diamondThumb === 2) {\r\n                        thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.left);\r\n                    }\r\n                    else {\r\n                        thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top);\r\n                    }\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, thumbPosition);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                }\r\n                currentGroupThumbs = shapeRefs.current[\"thumbstartbottom_\" + node.name];\r\n                if (currentGroupThumbs) {\r\n                    let thumbPosition;\r\n                    if (diamondThumb === 2) {\r\n                        thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.right);\r\n                    }\r\n                    else {\r\n                        thumbPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getThumbStartPosition(shapeType, newPosition, 0, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.bottom);\r\n                    }\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, thumbPosition);\r\n                    currentGroupThumbs.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                }\r\n                const element = elementRefs.current[node.name];\r\n                if (element) {\r\n                    element.style.opacity = \"1\";\r\n                }\r\n            }\r\n        }\r\n        if (node.shapeType !== \"Line\") {\r\n            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, { ...newPosition });\r\n        }\r\n        if (skipSetHtml === undefined || skipSetHtml === false) {\r\n            setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current, newPosition.x, newPosition.y, node);\r\n        }\r\n        const startLines = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getLinesForStartNodeFromCanvasFlow(flowStore.flow, node, flowStore.flowHashmap);\r\n        let lines = {};\r\n        if (startLines) {\r\n            startLines.map((lineNode) => {\r\n                const newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(node, newPosition, lineNode, props.getNodeInstance, lineNode.thumbPosition);\r\n                const positionLine = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(lineNode.name) || lineNode;\r\n                let endPos = {\r\n                    x: positionLine.xend,\r\n                    y: positionLine.yend\r\n                };\r\n                let endNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.endshapeid).index];\r\n                if (endNode) {\r\n                    const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(endNode.name) || endNode;\r\n                    const newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(endNode, {\r\n                        x: positionNode.x,\r\n                        y: positionNode.y\r\n                    }, node, props.getNodeInstance, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                    const lineRef = shapeRefs.current[lineNode.name];\r\n                    if (lineRef) {\r\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(newStartPosition.x, newStartPosition.y, newEndPosition.x, newEndPosition.y, lineNode.thumbPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [newStartPosition.x, newStartPosition.y,\r\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                newEndPosition.x, newEndPosition.y] });\r\n                    }\r\n                    const endNodeRef = shapeRefs.current[lineNode.endshapeid];\r\n                    if (endNodeRef) {\r\n                        endNodeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                    }\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(lineNode.name, {\r\n                        xstart: newStartPosition.x, ystart: newStartPosition.y,\r\n                        xend: newEndPosition.x, yend: newEndPosition.y\r\n                    });\r\n                }\r\n                else {\r\n                    const lineRef = shapeRefs.current[lineNode.name];\r\n                    if (lineRef) {\r\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(newStartPosition.x, newStartPosition.y, endPos.x, endPos.y, lineNode.thumbPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [newStartPosition.x, newStartPosition.y,\r\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                endPos.x, endPos.y] });\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(lineNode.name, {\r\n                            xstart: newStartPosition.x, ystart: newStartPosition.y,\r\n                            xend: endPos.x, yend: endPos.y\r\n                        });\r\n                    }\r\n                }\r\n                lines[lineNode.name] = { x: newStartPosition.x, y: newStartPosition.y };\r\n            });\r\n        }\r\n        const endLines = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getLinesForEndNodeFromCanvasFlow(flowStore.flow, node, flowStore.flowHashmap);\r\n        if (endLines) {\r\n            endLines.map((lineNode) => {\r\n                const newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(node, newPosition, lineNode, props.getNodeInstance, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                const positionLine = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(lineNode.name) || lineNode;\r\n                let startPos = {\r\n                    x: positionLine.xstart,\r\n                    y: positionLine.ystart\r\n                };\r\n                let startNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.startshapeid).index];\r\n                if (startNode) {\r\n                    const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(startNode.name) || startNode;\r\n                    let newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(startNode, {\r\n                        x: positionNode.x,\r\n                        y: positionNode.y\r\n                    }, lineNode, props.getNodeInstance, lineNode.thumbPosition);\r\n                    if (lines[lineNode.name]) {\r\n                        newStartPosition = lines[lineNode.name];\r\n                    }\r\n                    const lineRef = shapeRefs.current[lineNode.name];\r\n                    if (lineRef) {\r\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(newStartPosition.x, newStartPosition.y, newEndPosition.x, newEndPosition.y, lineNode.thumbPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [newStartPosition.x, newStartPosition.y,\r\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                newEndPosition.x, newEndPosition.y] });\r\n                    }\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(lineNode.name, {\r\n                        xstart: newStartPosition.x, ystart: newStartPosition.y,\r\n                        xend: newEndPosition.x, yend: newEndPosition.y\r\n                    });\r\n                    const startNodeRef = shapeRefs.current[lineNode.startshapeid];\r\n                    if (startNodeRef) {\r\n                        startNodeRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                    }\r\n                }\r\n                else {\r\n                    const lineRef = shapeRefs.current[lineNode.name];\r\n                    if (lineRef) {\r\n                        let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(startPos.x, startPos.y, newEndPosition.x, newEndPosition.y, lineNode.thumbPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, lineNode.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [startPos.x, startPos.y,\r\n                                controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                newEndPosition.x, newEndPosition.y] });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (node.shapeType === \"Line\") {\r\n            newPosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n            if (node.endshapeid) {\r\n                let endNode = flowStore.flow[flowStore.flowHashmap.get(node.endshapeid).index];\r\n                if (endNode) {\r\n                    const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(endNode.name) || endNode;\r\n                    const newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(endNode, {\r\n                        x: positionNode.x,\r\n                        y: positionNode.y\r\n                    }, node, props.getNodeInstance, node.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                    newPosition.xend = newEndPosition.x;\r\n                    newPosition.yend = newEndPosition.y;\r\n                }\r\n            }\r\n            if (node.startshapeid) {\r\n                let startNode = flowStore.flow[flowStore.flowHashmap.get(node.startshapeid).index];\r\n                if (startNode) {\r\n                    const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(startNode.name) || startNode;\r\n                    let newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(startNode, {\r\n                        x: positionNode.x,\r\n                        y: positionNode.y\r\n                    }, node, props.getNodeInstance, node.thumbPosition);\r\n                    newPosition.xstart = newStartPosition.x;\r\n                    newPosition.ystart = newStartPosition.y;\r\n                }\r\n            }\r\n            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, newPosition);\r\n        }\r\n        if (!!doDraw) {\r\n            if (draggingMultipleNodes.current && draggingMultipleNodes.current.length == 0) {\r\n                if (stage && stage.current) {\r\n                    let stageInstance = stage.current.getStage();\r\n                    stageInstance.batchDraw();\r\n                }\r\n                updateTouchedNodes();\r\n            }\r\n        }\r\n        if (!!isCommitingToStore) {\r\n            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(node.name, { ...newPosition });\r\n            if (draggingMultipleNodes.current && draggingMultipleNodes.current.length == 0) {\r\n                selectNode(node.name, node);\r\n                canvasMode.setConnectiongNodeCanvasMode(false);\r\n                if (props.flowrunnerConnector.hasStorageProvider) {\r\n                    props.saveFlow();\r\n                }\r\n            }\r\n        }\r\n    }, [flowStore.flow, flowStore.flowHashmap]);\r\n    const onCloneNode = (node, event) => {\r\n        event.preventDefault();\r\n        let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewNode)({ ...node }, flowStore.flow);\r\n        newNode.x = newNode.x + 100;\r\n        newNode.y = newNode.y + 100;\r\n        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\r\n            x: newNode.x,\r\n            y: newNode.y\r\n        });\r\n        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(newNode.name, {\r\n            x: newNode.x,\r\n            y: newNode.y\r\n        });\r\n        flowStore.addFlowNode(newNode);\r\n        return false;\r\n    };\r\n    const onShowNodeSettings = (node, settings, event) => {\r\n        event.preventDefault();\r\n        setEditNode(node);\r\n        setEditNodeSettings(settings);\r\n        setShowNodeSettings(true);\r\n        return false;\r\n    };\r\n    const onCloseEditNodeSettings = () => {\r\n        setShowNodeSettings(false);\r\n        setEditNode(undefined);\r\n        setEditNodeSettings(undefined);\r\n    };\r\n    const onShowNodeEditor = (node, settings, event) => {\r\n        event.preventDefault();\r\n        setEditNode(node);\r\n        setEditNodeSettings(settings);\r\n        setShowNodeEdit(true);\r\n        return false;\r\n    };\r\n    const onCloseEditNode = () => {\r\n        setShowNodeEdit(false);\r\n        setEditNode(undefined);\r\n        setEditNodeSettings(undefined);\r\n    };\r\n    const downloadURI = (uri, name) => {\r\n        let link = document.createElement('a');\r\n        link.download = name;\r\n        link.href = uri;\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n    };\r\n    const exportCanvas = () => {\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            var dataURL = stageInstance.toDataURL({ pixelRatio: 6 });\r\n            downloadURI(dataURL, 'flow.png');\r\n        }\r\n    };\r\n    const onClickSetup = (node, settings, event) => {\r\n        if (node.notSelectable) {\r\n            return false;\r\n        }\r\n        event.evt.preventDefault();\r\n        setEditNode(node);\r\n        setEditNodeSettings(settings);\r\n        setShowNodeSettings(true);\r\n        return false;\r\n    };\r\n    const onMouseOver = (node, event) => {\r\n        if (node.notSelectable) {\r\n            return false;\r\n        }\r\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\r\n            if (node && node.shapeType === 'Line') {\r\n                return;\r\n            }\r\n            const allowedInputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedInputs(node.shapeType, settings);\r\n            if (allowedInputs == 0 ||\r\n                !_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveInputs(node.shapeType, settings, flowStore.flow, node, flowStore.flowHashmap)) {\r\n                document.body.style.cursor = 'not-allowed';\r\n                return false;\r\n            }\r\n        }\r\n        if (node.shapeType === \"Diamond\" && settings.altThumbPositions === 1) {\r\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top;\r\n        }\r\n        else if (node.shapeType === \"Diamond\" && !settings.altThumbPositions) {\r\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        }\r\n        document.body.style.cursor = 'pointer';\r\n    };\r\n    const onMouseOut = () => {\r\n        document.body.style.cursor = null;\r\n    };\r\n    const determineStartPosition = (group, pointerPosition, committed) => {\r\n        let newPosition = { x: 0, y: 0 };\r\n        let x = 0;\r\n        let y = 0;\r\n        if (group && group.attrs && group.attrs[\"x\"]) {\r\n            x = group.attrs[\"x\"];\r\n            y = group.attrs[\"y\"];\r\n            newPosition = { x: x, y: y };\r\n        }\r\n        else {\r\n            x = group.x;\r\n            y = group.y;\r\n            newPosition = { x: x, y: y };\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const scaleFactor = stageInstance.scaleX();\r\n                newPosition.x = ((pointerPosition.x - (stageInstance).x()) / scaleFactor);\r\n                newPosition.y = ((pointerPosition.y - (stageInstance).y()) / scaleFactor);\r\n                mouseStartX.current = newPosition.x - x;\r\n                mouseStartY.current = newPosition.y - y;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    const determineEndPosition = (group, pointerPosition) => {\r\n        let newPosition = { x: 0, y: 0 };\r\n        let x = 0;\r\n        let y = 0;\r\n        if (group && group.attrs && group.attrs[\"x\"]) {\r\n            x = group.attrs[\"x\"];\r\n            y = group.attrs[\"y\"];\r\n            newPosition = { x: x, y: y };\r\n        }\r\n        else {\r\n            x = group.x;\r\n            y = group.y;\r\n            newPosition = { x: x, y: y };\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const scaleFactor = stageInstance.scaleX();\r\n                newPosition.x = ((pointerPosition.x - (stageInstance).x()) / scaleFactor);\r\n                newPosition.y = ((pointerPosition.y - (stageInstance).y()) / scaleFactor);\r\n                mouseEndX.current = newPosition.x - x;\r\n                mouseEndY.current = newPosition.y - y;\r\n            }\r\n        }\r\n    };\r\n    const onMouseStart = (node, event) => {\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n            cancelDragStage();\r\n            return false;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            cancelDragStage();\r\n            return false;\r\n        }\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            cancelDragStage();\r\n            return false;\r\n        }\r\n        if (isPinching.current) {\r\n            cancelDragStage();\r\n            return;\r\n        }\r\n        if (!event.evt) {\r\n            event.persist();\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const touchPos = getCurrentPosition(event);\r\n                mouseStartPointerX.current = touchPos.x;\r\n                mouseStartPointerY.current = touchPos.y;\r\n            }\r\n        }\r\n        touching.current = true;\r\n        touchNode.current = node;\r\n        touchNodeGroup.current = event.currentTarget;\r\n        mouseDragging.current = false;\r\n        draggingMultipleNodes.current = [];\r\n        if (event.currentTarget) {\r\n            document.body.classList.add(\"mouse--moving\");\r\n            if (node && node.shapeType === \"Line\") {\r\n                return;\r\n            }\r\n            else {\r\n                let stageInstance = stage.current.getStage();\r\n                const scaleFactor = stageInstance.scaleX();\r\n                let _x = ((event.clientX) / scaleFactor);\r\n                let _y = ((event.clientY) / scaleFactor);\r\n                if (determineStartPosition(event.evt ? event.currentTarget : (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.id), getCurrentPosition(event), { x: stageX.current + _x, y: stageY.current + _y,\r\n                    screenX: event.clientX, screenY: event.clientY,\r\n                    canvasPointer: stageInstance.getPointerPosition() })) {\r\n                    if (node &&\r\n                        ((event.evt && !!event.evt.shiftKey) ||\r\n                            (event && !!event.shiftKey))) {\r\n                        const width = getWidthForHtmlNode(node);\r\n                        if (node.name, mouseStartX.current > (width / 2)) {\r\n                            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNodesUpstream;\r\n                            getAllConnectedNodes(node, \"output\");\r\n                        }\r\n                        else if (node.name, mouseStartX.current < (width / 2)) {\r\n                            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNodesDownstream;\r\n                            getAllConnectedNodes(node, \"input\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle) {\r\n            return false;\r\n        }\r\n        return;\r\n    };\r\n    const getAllConnectedNodes = (node, mode) => {\r\n        draggingMultipleNodes.current = [node.name];\r\n        if (mode === \"output\") {\r\n            getAllConnectedOutputNodes(node.name);\r\n        }\r\n        else if (mode === \"input\") {\r\n            getAllConnectedInputNodes(node.name);\r\n        }\r\n    };\r\n    const getAllConnectedOutputNodes = (nodeName) => {\r\n        const mappedNode = flowStore.flowHashmap.get(nodeName);\r\n        if (mappedNode) {\r\n            const outputs = mappedNode.start;\r\n            if (outputs && outputs.length > 0) {\r\n                outputs.forEach(outputIndex => {\r\n                    const outputLineNode = flowStore.flow[outputIndex];\r\n                    if (outputLineNode.endshapeid &&\r\n                        draggingMultipleNodes.current.indexOf(outputLineNode.endshapeid) < 0) {\r\n                        draggingMultipleNodes.current.push(outputLineNode.endshapeid);\r\n                        getAllConnectedOutputNodes(outputLineNode.endshapeid);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    const getAllConnectedInputNodes = (nodeName) => {\r\n        const mappedNode = flowStore.flowHashmap.get(nodeName);\r\n        if (mappedNode) {\r\n            const inputs = mappedNode.end;\r\n            if (inputs && inputs.length > 0) {\r\n                inputs.forEach(outputIndex => {\r\n                    const outputLineNode = flowStore.flow[outputIndex];\r\n                    if (outputLineNode.startshapeid &&\r\n                        draggingMultipleNodes.current.indexOf(outputLineNode.startshapeid) < 0) {\r\n                        draggingMultipleNodes.current.push(outputLineNode.startshapeid);\r\n                        getAllConnectedInputNodes(outputLineNode.startshapeid);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    const getWidthForHtmlNode = (node) => {\r\n        if (node) {\r\n            if (props.getNodeInstance) {\r\n                const shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeType(node.shapeType, node.taskType, node.isStartEnd);\r\n                if (shapeType === \"Html\") {\r\n                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n                    const instance = props.getNodeInstance(node, undefined, undefined, settings);\r\n                    if (instance && instance.getWidth && instance.getHeight) {\r\n                        let width = instance.getWidth(node);\r\n                        let element = document.querySelector(\"#\" + node.name + \" .html-plugin-node\");\r\n                        if (element) {\r\n                            const elementWidth = element.clientWidth;\r\n                            if (elementWidth > width) {\r\n                                width = elementWidth;\r\n                            }\r\n                        }\r\n                        return width;\r\n                    }\r\n                }\r\n                else {\r\n                    if (shapeType == \"Rect\") {\r\n                        return _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectWidht;\r\n                    }\r\n                    else if (shapeType == \"Diamond\") {\r\n                        return _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    const onMouseMove = (node, event) => {\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n            return;\r\n        }\r\n        if (node && touching.current && touchNode.current &&\r\n            node.name !== touchNode.current.name) {\r\n            return;\r\n        }\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            return;\r\n        }\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (node.shapeType === \"Line\" || (touchNode.current && touchNode.current.shapeType === \"Line\")) {\r\n            if (touching.current && interactionState.current !== _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNodesByConnection) {\r\n                if (node.startshapeid) {\r\n                    interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNodesByConnection;\r\n                    const shapeRef = shapeRefs.current[node.startshapeid];\r\n                    if (shapeRef) {\r\n                        determineStartPosition(shapeRef.getGroupRef(), getCurrentPosition(event));\r\n                    }\r\n                    else {\r\n                        determineStartPosition((0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.startshapeid), getCurrentPosition(event));\r\n                    }\r\n                }\r\n                if (node.endshapeid) {\r\n                    interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNodesByConnection;\r\n                    const shapeRef = shapeRefs.current[node.endshapeid];\r\n                    if (shapeRef) {\r\n                        determineEndPosition(shapeRef.getGroupRef(), getCurrentPosition(event));\r\n                    }\r\n                    else {\r\n                        determineEndPosition((0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.endshapeid), getCurrentPosition(event));\r\n                    }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            cancelDragStage();\r\n            return false;\r\n        }\r\n        if (touching.current) {\r\n            mouseDragging.current = true;\r\n            document.body.classList.add(\"mouse--moving\");\r\n            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNode;\r\n            return;\r\n        }\r\n        return;\r\n    };\r\n    const clearConnectionState = () => {\r\n        console.log(\"clearstate\");\r\n        touching.current = false;\r\n        isConnectingNodesByDraggingLocal.current = false;\r\n        connectionNodeEvent.current = false;\r\n        connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.default;\r\n        connectionNodeEventName.current = \"\";\r\n        touchNode.current = undefined;\r\n        touchNodeGroup.current = undefined;\r\n        connectionNodeThumbsLineNode.current = undefined;\r\n        interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n        const lineRef = shapeRefs.current[connectionForDraggingName];\r\n        if (lineRef) {\r\n            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                stageInstance.batchDraw();\r\n            }\r\n        }\r\n        document.body.classList.remove(\"connecting-nodes\");\r\n        mouseDragging.current = false;\r\n    };\r\n    const connectConnectionToNode = (node, thumbPositionRelativeToNode) => {\r\n        let eventHelper = undefined;\r\n        if (connectionNodeEventName !== undefined &&\r\n            connectionNodeEventName.current !== \"\" &&\r\n            !isNaN(connectionNodeEvent.current)) {\r\n            eventHelper = {};\r\n            eventHelper.event = connectionNodeEventName.current;\r\n        }\r\n        if (node && node.shapeType === \"Line\") {\r\n            return;\r\n        }\r\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n        const allowedInputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedInputs(node.shapeType, settings);\r\n        if (allowedInputs == 0 ||\r\n            !_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveInputs(node.shapeType, settings, flowStore.flow, node, flowStore.flowHashmap)) {\r\n            clearConnectionState();\r\n            return false;\r\n        }\r\n        const connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewConnection)(touchNode.current, node, props.getNodeInstance, eventHelper, connectionNodeThumbPositionRelativeToNode.current);\r\n        connection.thumbPosition = connectionNodeThumbPositionRelativeToNode.current;\r\n        if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.happyFlow) {\r\n            connection.followflow = \"onsuccess\";\r\n        }\r\n        else if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.unhappyFlow) {\r\n            connection.followflow = \"onfailure\";\r\n        }\r\n        if (thumbPositionRelativeToNode !== undefined) {\r\n            connection.thumbEndPosition = thumbPositionRelativeToNode;\r\n        }\r\n        if (node.shapeType === \"Diamond\" && settings.altThumbPositions === 1) {\r\n            connection.thumbEndPosition = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top;\r\n        }\r\n        if (connectionNodeEventName.current !== \"\" &&\r\n            !isNaN(connectionNodeEvent.current)) {\r\n            connection.event = connectionNodeEventName.current;\r\n        }\r\n        clearConnectionState();\r\n        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connection.name, {\r\n            xstart: connection.xstart,\r\n            ystart: connection.ystart,\r\n            xend: connection.xend,\r\n            yend: connection.yend\r\n        });\r\n        flowStore.addConnection(connection);\r\n        canvasMode.setConnectiongNodeCanvasMode(false);\r\n    };\r\n    const onMouseEnd = (node, event) => {\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (node.shapeType === \"Line\") {\r\n            if (interactionState.current !== _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingNodesByConnection) {\r\n                touching.current = false;\r\n                touchNode.current = undefined;\r\n                touchNodeGroup.current = undefined;\r\n                mouseDragging.current = false;\r\n                draggingMultipleNodes.current = [];\r\n                interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n                selectNode(node.name, node);\r\n            }\r\n            return;\r\n        }\r\n        selectedNodeRef.current = node;\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingConnectionEnd) {\r\n        }\r\n        document.body.style.cursor = null;\r\n        document.body.classList.remove(\"mouse--moving\");\r\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\r\n            if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\r\n                if (connectionNodeThumbsLineNode.current) {\r\n                    let clonedNode = { ...connectionNodeThumbsLineNode.current };\r\n                    clonedNode.endshapeid = node.name;\r\n                    connectionNodeThumbsLineNode.current = clonedNode;\r\n                    return;\r\n                }\r\n                connectConnectionToNode(node);\r\n            }\r\n            return false;\r\n        }\r\n        if (touchNodeGroup.current != event.currentTarget) {\r\n            return false;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (event.currentTarget && mouseDragging.current) {\r\n            return;\r\n        }\r\n        if (event.evt) {\r\n            event.evt.preventDefault();\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        else {\r\n            event.preventDefault();\r\n            event.cancelBubble = true;\r\n        }\r\n        touching.current = false;\r\n        dragTime.current = undefined;\r\n        touchNodeGroup.current = undefined;\r\n        if (event.currentTarget && mouseDragging.current) {\r\n            setNewPositionForNode(event, node, shapeRefs.current[node.name], undefined, true, false, true);\r\n            if (closestNodeAreLineNodes.current) {\r\n                connectNodeToExistingLines(node);\r\n            }\r\n        }\r\n        else {\r\n            canvasMode.setConnectiongNodeCanvasMode(false);\r\n        }\r\n        touchNode.current = undefined;\r\n        mouseDragging.current = false;\r\n        return false;\r\n    };\r\n    const connectNodeToExistingLines = (node) => {\r\n        if (closestEndNodeWhenAddingNewNode.current) {\r\n            const closestEndConnectionNode = closestEndNodeWhenAddingNewNode.current;\r\n            closestEndConnectionNode.startshapeid = node.name;\r\n            flowStore.storeFlowNode(closestEndConnectionNode, closestEndConnectionNode.name);\r\n        }\r\n        if (closestStartNodeWhenAddingNewNode.current) {\r\n            const closestStartConnectionNode = closestStartNodeWhenAddingNewNode.current;\r\n            closestStartConnectionNode.endshapeid = node.name;\r\n            flowStore.storeFlowNode(closestStartConnectionNode, closestStartConnectionNode.name);\r\n        }\r\n    };\r\n    const onStageMouseEnd = (event) => {\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.selectingNodes) {\r\n            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect;\r\n            const nodes = selectNodesForSelectRectangle(event);\r\n            canvasMode.setIsInMultiSelect(true, nodes);\r\n            return;\r\n        }\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle) {\r\n            return;\r\n        }\r\n        if (isPinching.current) {\r\n            isPinching.current = false;\r\n            return;\r\n        }\r\n        let haveMouseEventFallThrough = false;\r\n        if ((interactionState.current == _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect && touching.current) ||\r\n            touching.current || isConnectingNodesByDraggingLocal.current) {\r\n            if (stage && stage.current) {\r\n                let stageInstance = stage.current.getStage();\r\n                if (interactionState.current == _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect ||\r\n                    (connectionNodeThumbs.current === \"\" &&\r\n                        !isConnectingNodesByDraggingLocal.current &&\r\n                        mouseDragging.current && touchNode.current)) {\r\n                    if (draggingMultipleNodes.current && draggingMultipleNodes.current.length > 0) {\r\n                        if (stage && stage.current) {\r\n                            let stageInstance = stage.current.getStage();\r\n                            if (stageInstance) {\r\n                                const touchPos = getCurrentPosition(event);\r\n                                let offsetX = touchPos.x - mouseStartPointerX.current;\r\n                                let offsetY = touchPos.y - mouseStartPointerY.current;\r\n                                const scaleFactor = stageInstance.scaleX();\r\n                                let offsetPosition = {\r\n                                    x: 0,\r\n                                    y: 0\r\n                                };\r\n                                offsetPosition.x = ((offsetX) / scaleFactor);\r\n                                offsetPosition.y = ((offsetY) / scaleFactor);\r\n                                draggingMultipleNodes.current.forEach((nodeName) => {\r\n                                    let mappedNode = flowStore.flowHashmap.get(nodeName);\r\n                                    if (mappedNode) {\r\n                                        let draggingNode = flowStore.flow[mappedNode.index];\r\n                                        if (draggingNode) {\r\n                                            setNewPositionForNode(event, draggingNode, shapeRefs.current[nodeName], event.evt && event.evt.screenX ? {\r\n                                                x: event.evt.screenX,\r\n                                                y: event.evt.screenY\r\n                                            } : (event.screenX ? {\r\n                                                x: event.screenX,\r\n                                                y: event.screenY\r\n                                            } : undefined), true, false, true, false, false, offsetPosition);\r\n                                        }\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                        if (stage && stage.current) {\r\n                            let stageInstance = stage.current.getStage();\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                        updateTouchedNodes();\r\n                        canvasMode.setConnectiongNodeCanvasMode(false);\r\n                        if (props.flowrunnerConnector.hasStorageProvider) {\r\n                            props.saveFlow();\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (touchNode.current.shapeType === \"Line\") {\r\n                            let lineNode = touchNode.current;\r\n                            if (lineNode.startshapeid) {\r\n                                const startNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.startshapeid).index];\r\n                                if (startNode) {\r\n                                    setNewPositionForNode(event, startNode, shapeRefs.current[startNode.name], event.evt && event.evt.screenX ? {\r\n                                        x: event.evt.screenX,\r\n                                        y: event.evt.screenY\r\n                                    } : (event.screenX ? {\r\n                                        x: event.screenX,\r\n                                        y: event.screenY\r\n                                    } : undefined), true, false, true);\r\n                                }\r\n                            }\r\n                            if (lineNode.endshapeid) {\r\n                                const endNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.endshapeid).index];\r\n                                if (endNode) {\r\n                                    setNewPositionForNode(event, endNode, shapeRefs.current[endNode.name], event.evt && event.evt.screenX ? {\r\n                                        x: event.evt.screenX,\r\n                                        y: event.evt.screenY\r\n                                    } : (event.screenX ? {\r\n                                        x: event.screenX,\r\n                                        y: event.screenY\r\n                                    } : undefined), true, false, true, false, true);\r\n                                }\r\n                            }\r\n                        }\r\n                        setNewPositionForNode(event, touchNode.current, shapeRefs.current[touchNode.current.name], undefined, true, false, true);\r\n                        if (closestNodeAreLineNodes.current) {\r\n                            connectNodeToExistingLines(touchNode.current);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    const touchPos = getCurrentPosition(event);\r\n                    if (connectionNodeThumbs.current === \"thumbstart\") {\r\n                        const scaleFactor = stageInstance.scaleX();\r\n                        let newPosition = {\r\n                            x: 0,\r\n                            y: 0\r\n                        };\r\n                        newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\r\n                        newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\r\n                        let endPosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(connectionNodeThumbsLineNode.current.name) || {\r\n                            xend: connectionNodeThumbsLineNode.current.xend,\r\n                            yend: connectionNodeThumbsLineNode.current.yend\r\n                        };\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connectionNodeThumbsLineNode.current.name, {\r\n                            xstart: newPosition.x,\r\n                            ystart: newPosition.y,\r\n                            xend: endPosition.xend,\r\n                            yend: endPosition.yend\r\n                        });\r\n                        let endpoints = {\r\n                            ...connectionNodeThumbsLineNode.current,\r\n                            xstart: newPosition.x,\r\n                            ystart: newPosition.y,\r\n                            xend: endPosition.xend,\r\n                            yend: endPosition.yend\r\n                        };\r\n                        connectionNodeThumbsLineNode.current = endpoints;\r\n                        props.flowrunnerConnector.forcePushToFlowRunner = true;\r\n                        flowStore.storeFlowNode(connectionNodeThumbsLineNode.current, connectionNodeThumbsLineNode.current.name);\r\n                    }\r\n                    else if (connectionNodeThumbs.current === \"thumbend\") {\r\n                        const scaleFactor = stageInstance.scaleX();\r\n                        let newPosition = {\r\n                            x: 0,\r\n                            y: 0\r\n                        };\r\n                        newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\r\n                        newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\r\n                        let startPosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(connectionNodeThumbsLineNode.current.name) || {\r\n                            xstart: connectionNodeThumbsLineNode.current.xstart,\r\n                            ystart: connectionNodeThumbsLineNode.current.ystart\r\n                        };\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connectionNodeThumbsLineNode.current.name, {\r\n                            xstart: startPosition.xstart,\r\n                            ystart: startPosition.ystart,\r\n                            xend: newPosition.x,\r\n                            yend: newPosition.y,\r\n                        });\r\n                        let endpoints = {\r\n                            ...connectionNodeThumbsLineNode.current,\r\n                            xstart: startPosition.xstart,\r\n                            ystart: startPosition.ystart,\r\n                            xend: newPosition.x,\r\n                            yend: newPosition.y\r\n                        };\r\n                        connectionNodeThumbsLineNode.current = endpoints;\r\n                        props.flowrunnerConnector.forcePushToFlowRunner = true;\r\n                        flowStore.storeFlowNode(connectionNodeThumbsLineNode.current, connectionNodeThumbsLineNode.current.name);\r\n                        const nodeName = connectionNodeThumbsLineNode.current.startshapeid;\r\n                    }\r\n                    else {\r\n                        haveMouseEventFallThrough = true;\r\n                    }\r\n                }\r\n                if (!haveMouseEventFallThrough) {\r\n                    cancelDragStage();\r\n                    if (event.evt) {\r\n                        event.evt.preventDefault();\r\n                        event.evt.cancelBubble = true;\r\n                    }\r\n                    else {\r\n                        event.preventDefault();\r\n                        event.cancelBubble = true;\r\n                    }\r\n                    if (interactionState.current !== _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n                        clearConnectionState();\r\n                    }\r\n                }\r\n                dragTime.current = undefined;\r\n                touching.current = false;\r\n                touchNode.current = undefined;\r\n                touchNodeGroup.current = undefined;\r\n                isConnectingNodesByDraggingLocal.current = false;\r\n                connectionNodeEvent.current = false;\r\n                connectionNodeEventName.current = \"\";\r\n                connectionNodeThumbs.current = \"\";\r\n                connectionNodeThumbsLineNode.current = undefined;\r\n                connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.default;\r\n                document.body.classList.remove(\"connecting-nodes\");\r\n                document.body.classList.remove(\"mouse--moving\");\r\n                document.body.style.cursor = null;\r\n                if (interactionState.current !== _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n                    interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n                }\r\n                else {\r\n                    handleMultiSelectCursor(event);\r\n                    updateSelectRectangle(event);\r\n                }\r\n                const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                if (lineRef) {\r\n                    lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                }\r\n                if (stageInstance) {\r\n                    stageInstance.batchDraw();\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n    const triggerNode = (nodeName) => {\r\n        var _a;\r\n        if (nodeName) {\r\n            let mappedNode = flowStore.flowHashmap.get(nodeName);\r\n            if (mappedNode && mappedNode.index >= 0) {\r\n                let startNode = flowStore.flow[mappedNode.index];\r\n                if (startNode) {\r\n                    (_a = props.flowrunnerConnector) === null || _a === void 0 ? void 0 : _a.executeFlowNode(nodeName);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const onStageMouseLeave = (event) => {\r\n        onStageMouseEnd(event);\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.selectingNodes) {\r\n            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n            selectingRectRef.current.opacity(0);\r\n            selectedNodes.current = [];\r\n            deselectAllNodes();\r\n            touching.current = false;\r\n        }\r\n        if (event.evt) {\r\n            event.evt.preventDefault();\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        else {\r\n            event.preventDefault();\r\n            event.cancelBubble = true;\r\n        }\r\n        const lineRef = shapeRefs.current[connectionForDraggingName];\r\n        if (lineRef) {\r\n            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n            if (stage && stage.current) {\r\n                let stageInstance = stage.current.getStage();\r\n                if (stageInstance !== undefined) {\r\n                    stageInstance.batchDraw();\r\n                }\r\n            }\r\n        }\r\n        isConnectingNodesByDraggingLocal.current = false;\r\n        connectionNodeEvent.current = false;\r\n        connectionNodeEventName.current = \"\";\r\n        connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.default;\r\n        document.body.classList.remove(\"connecting-nodes\");\r\n        document.body.classList.remove(\"mouse--moving\");\r\n        document.body.style.cursor = null;\r\n        touching.current = false;\r\n        dragTime.current = undefined;\r\n        touchNode.current = undefined;\r\n        touchNodeGroup.current = undefined;\r\n        isPinching.current = false;\r\n        connectionNodeThumbsLineNode.current = undefined;\r\n        return false;\r\n    };\r\n    const onMouseLeave = (node, event) => {\r\n        return;\r\n    };\r\n    const onStageTouchStart = (event) => {\r\n        isPinching.current = false;\r\n        if (event && event.evt && !!event.evt.shiftKey) {\r\n            cancelDragStage();\r\n            selectedNodes.current = [];\r\n            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.selectingNodes;\r\n            if (stage && stage.current) {\r\n                let stageInstance = stage.current.getStage();\r\n                if (stageInstance) {\r\n                    const touchPos = getCurrentPosition(event);\r\n                    mouseStartPointerX.current = touchPos.x;\r\n                    mouseStartPointerY.current = touchPos.y;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n            if (selectedNodes.current.length > 0) {\r\n                if (stage && stage.current) {\r\n                    let stageInstance = stage.current.getStage();\r\n                    if (stageInstance) {\r\n                        const touchPos = getCurrentPosition(event);\r\n                        mouseStartPointerX.current = touchPos.x;\r\n                        mouseStartPointerY.current = touchPos.y;\r\n                    }\r\n                }\r\n                touching.current = true;\r\n                mouseDragging.current = false;\r\n                draggingMultipleNodes.current = [...selectedNodes.current];\r\n                document.body.classList.add(\"mouse--moving\");\r\n            }\r\n            else {\r\n                interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n            }\r\n            return;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            cancelDragStage();\r\n            return false;\r\n        }\r\n        if (touchNode.current && touchNodeGroup.current) {\r\n            cancelDragStage();\r\n        }\r\n        else {\r\n            if (event.evt && event.evt.touches && event.evt.touches.length > 1) {\r\n                isPinching.current = true;\r\n                cancelDragStage();\r\n                if (event.evt.touches.length == 2) {\r\n                    pinchStartPosition.current = {\r\n                        x: (event.evt.touches[0].screenX + event.evt.touches[1].screenX) / 2,\r\n                        y: (event.evt.touches[0].screenY + event.evt.touches[1].screenY) / 2\r\n                    };\r\n                    const x = event.evt.touches[0].screenX - event.evt.touches[1].screenX;\r\n                    const y = event.evt.touches[0].screenY - event.evt.touches[1].screenY;\r\n                    startDistance.current = Math.sqrt(x * x + y * y);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const showSelectRectangle = (event) => {\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const touchPos = getCurrentPosition(event);\r\n                let width = touchPos.x - mouseStartPointerX.current;\r\n                let height = touchPos.y - mouseStartPointerY.current;\r\n                const scaleFactor = stageInstance.scaleX();\r\n                selectingRectRef.current.opacity(1);\r\n                selectingRectRef.current.x((mouseStartPointerX.current - (stageInstance).x()) / scaleFactor);\r\n                selectingRectRef.current.y((mouseStartPointerY.current - (stageInstance).y()) / scaleFactor);\r\n                selectingRectRef.current.width((width) / scaleFactor);\r\n                selectingRectRef.current.height((height) / scaleFactor);\r\n                selectingRectRef.current.draw();\r\n                selectingRectInfo.current = {\r\n                    x: mouseStartPointerX.current,\r\n                    y: mouseStartPointerY.current,\r\n                    width: width,\r\n                    height: height\r\n                };\r\n                stageInstance.batchDraw();\r\n            }\r\n        }\r\n    };\r\n    const deselectAllNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\r\n        selectedNodes.current = [];\r\n        flowStore.flow.map((node, index) => {\r\n            if (node.shapeType !== \"Line\") {\r\n                const taskSettings = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getTaskSettings(node.taskType);\r\n                let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeTypeUsingSettings(node.shapeType, node.taskType, node.isStartEnd, taskSettings);\r\n                if (shapeType === \"Html\") {\r\n                    const element = document.querySelector(\"#\" + node.name);\r\n                    if (element) {\r\n                        element.classList.remove(\"selected\");\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }, [flowStore.flow]);\r\n    const selectNodesForSelectRectangle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const touchPos = getCurrentPosition(event);\r\n                let width = touchPos.x - mouseStartPointerX.current;\r\n                let height = touchPos.y - mouseStartPointerY.current;\r\n                const scaleFactor = stageInstance.scaleX();\r\n                let x = (mouseStartPointerX.current - (stageInstance).x()) / scaleFactor;\r\n                let y = (mouseStartPointerY.current - (stageInstance).y()) / scaleFactor;\r\n                let scaledWidth = width / scaleFactor;\r\n                let scaledHeight = height / scaleFactor;\r\n                let nodesInBoundary = [];\r\n                flowStore.flow.map((node, index) => {\r\n                    if (node.shapeType !== \"Line\") {\r\n                        let nodeWidth = 0;\r\n                        let nodeHeight = 0;\r\n                        const taskSettings = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getTaskSettings(node.taskType);\r\n                        let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeTypeUsingSettings(node.shapeType, node.taskType, node.isStartEnd, taskSettings);\r\n                        const position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name) || { x: node.x, y: node.y };\r\n                        if (shapeType === \"Html\") {\r\n                            if (props.getNodeInstance) {\r\n                                const instance = props.getNodeInstance(node, props.flowrunnerConnector, flowStore.flow, taskSettings);\r\n                                if (instance) {\r\n                                    if (instance.getWidth && instance.getHeight) {\r\n                                        nodeWidth = instance.getWidth(node);\r\n                                        nodeHeight = instance.getHeight(node);\r\n                                    }\r\n                                }\r\n                            }\r\n                            let element = document.querySelector(\"#\" + node.name + \" .html-plugin-node\");\r\n                            if (element) {\r\n                                const elementHeight = element.clientHeight;\r\n                                if (elementHeight > height) {\r\n                                    nodeHeight = elementHeight;\r\n                                }\r\n                                const elementWidth = element.clientWidth;\r\n                                if (elementWidth > width) {\r\n                                    nodeWidth = elementWidth;\r\n                                }\r\n                            }\r\n                            nodeWidth = (nodeWidth || node.width || 250);\r\n                            nodeHeight = (nodeHeight || node.height || 250);\r\n                        }\r\n                        else {\r\n                            nodeWidth = 100;\r\n                            nodeHeight = 50;\r\n                            if (shapeType === 'Circle') {\r\n                                nodeWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize;\r\n                                nodeHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize;\r\n                            }\r\n                            else if (shapeType === 'Diamond') {\r\n                                nodeWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize;\r\n                                nodeHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize;\r\n                            }\r\n                            else {\r\n                                nodeWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectWidht;\r\n                                nodeHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectHeight;\r\n                            }\r\n                        }\r\n                        if (x <= position.x && y <= position.y &&\r\n                            (position.x + nodeWidth < x + scaledWidth) &&\r\n                            (position.y + nodeHeight < y + scaledHeight)) {\r\n                            console.log(\"selected node:\", node.name);\r\n                            nodesInBoundary.push(node.name);\r\n                            if (shapeType === \"Html\") {\r\n                                let element = document.querySelector(\"#\" + node.name);\r\n                                if (element) {\r\n                                    element.classList.add(\"selected\");\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (shapeType === \"Html\") {\r\n                                let element = document.querySelector(\"#\" + node.name);\r\n                                if (element) {\r\n                                    element.classList.remove(\"selected\");\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                selectedNodes.current = nodesInBoundary;\r\n                return nodesInBoundary;\r\n            }\r\n        }\r\n        return [];\r\n    }, [flowStore.flow]);\r\n    const moveSelectRectangle = (event) => {\r\n        if (stage && stage.current && selectingRectInfo.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const touchPos = stageInstance.getPointerPosition();\r\n                let offsetX = touchPos.x - mouseStartPointerX.current;\r\n                let offsetY = touchPos.y - mouseStartPointerY.current;\r\n                const scaleFactor = stageInstance.scaleX();\r\n                let offsetPosition = {\r\n                    x: 0,\r\n                    y: 0\r\n                };\r\n                offsetPosition.x = ((offsetX) / scaleFactor);\r\n                offsetPosition.y = ((offsetY) / scaleFactor);\r\n                selectingRectRef.current.x((selectingRectInfo.current.x + offsetX - (stageInstance).x()) / scaleFactor);\r\n                selectingRectRef.current.y((selectingRectInfo.current.y + offsetY - (stageInstance).y()) / scaleFactor);\r\n            }\r\n        }\r\n    };\r\n    const updateSelectRectangle = (event) => {\r\n        if (stage && stage.current && selectingRectInfo.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const touchPos = stageInstance.getPointerPosition();\r\n                let offsetX = touchPos.x - mouseStartPointerX.current;\r\n                let offsetY = touchPos.y - mouseStartPointerY.current;\r\n                const scaleFactor = stageInstance.scaleX();\r\n                let offsetPosition = {\r\n                    x: 0,\r\n                    y: 0\r\n                };\r\n                offsetPosition.x = ((offsetX) / scaleFactor);\r\n                offsetPosition.y = ((offsetY) / scaleFactor);\r\n                selectingRectRef.current.x((selectingRectInfo.current.x + offsetX - (stageInstance).x()) / scaleFactor);\r\n                selectingRectRef.current.y((selectingRectInfo.current.y + offsetY - (stageInstance).y()) / scaleFactor);\r\n                selectingRectInfo.current.x = selectingRectInfo.current.x + offsetX;\r\n                selectingRectInfo.current.y = selectingRectInfo.current.y + offsetY;\r\n            }\r\n        }\r\n    };\r\n    const handleMultiSelectCursor = (event) => {\r\n        if (touching.current) {\r\n            return;\r\n        }\r\n        if (stage && stage.current && selectingRectInfo.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const touchPos = getCurrentPosition(event);\r\n                if (selectingRectInfo.current.x <= touchPos.x &&\r\n                    selectingRectInfo.current.y <= touchPos.y &&\r\n                    touchPos.x <= selectingRectInfo.current.x + selectingRectInfo.current.width &&\r\n                    touchPos.y <= selectingRectInfo.current.y + selectingRectInfo.current.height) {\r\n                    document.body.style.cursor = 'pointer';\r\n                }\r\n                else {\r\n                    document.body.style.cursor = 'default';\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const onStageTouchMove = (event) => {\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle) {\r\n                    return;\r\n                }\r\n                if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.selectingNodes) {\r\n                    showSelectRectangle(event);\r\n                    return;\r\n                }\r\n                if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n                    handleMultiSelectCursor(event);\r\n                }\r\n                if (isConnectingNodesByDraggingLocal.current) {\r\n                    if (event.evt) {\r\n                        event.evt.cancelBubble = true;\r\n                    }\r\n                    else {\r\n                        event.cancelBubble = true;\r\n                    }\r\n                    const touchPos = getCurrentPosition(event);\r\n                    const scaleFactor = stageInstance.scaleX();\r\n                    let newPosition = {\r\n                        x: 0,\r\n                        y: 0\r\n                    };\r\n                    newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\r\n                    newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\r\n                    if (connectionNodeThumbs.current === \"\") {\r\n                        const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                        if (lineRef) {\r\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(connectionXStart.current, connectionYStart.current, newPosition.x, newPosition.y, connectionNodeThumbPositionRelativeToNode.current, connectionNodeThumbPositionRelativeToEndNode.current);\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [connectionXStart.current, connectionYStart.current,\r\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                    newPosition.x, newPosition.y] });\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (connectionNodeThumbs.current === \"thumbstart\" && connectionNodeThumbsLineNode.current) {\r\n                            const lineRef = shapeRefs.current[connectionNodeThumbsLineNode.current.name];\r\n                            if (lineRef) {\r\n                                let lineEndPosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(connectionNodeThumbsLineNode.current.name);\r\n                                let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(newPosition.x, newPosition.y, (lineEndPosition && lineEndPosition.xend) || connectionNodeThumbsLineNode.current.xend, (lineEndPosition && lineEndPosition.yend) || connectionNodeThumbsLineNode.current.yend, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [\r\n                                        newPosition.x, newPosition.y,\r\n                                        controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                        controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                        (lineEndPosition && lineEndPosition.xend) || connectionNodeThumbsLineNode.current.xend,\r\n                                        (lineEndPosition && lineEndPosition.yend) || connectionNodeThumbsLineNode.current.yend\r\n                                    ] });\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                            }\r\n                            const thumbRef = shapeRefs.current[\"thumbstart_line_\" + connectionNodeThumbsLineNode.current.name];\r\n                            if (thumbRef) {\r\n                                thumbRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, newPosition);\r\n                            }\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                        else if (connectionNodeThumbs.current === \"thumbend\" && connectionNodeThumbsLineNode.current) {\r\n                            const lineRef = shapeRefs.current[connectionNodeThumbsLineNode.current.name];\r\n                            if (lineRef) {\r\n                                let lineStartPosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(connectionNodeThumbsLineNode.current.name);\r\n                                let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)((lineStartPosition && lineStartPosition.xstart) || connectionNodeThumbsLineNode.current.xstart, (lineStartPosition && lineStartPosition.ystart) || connectionNodeThumbsLineNode.current.ystart, newPosition.x, newPosition.y, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [\r\n                                        (lineStartPosition && lineStartPosition.xstart) || connectionNodeThumbsLineNode.current.xstart,\r\n                                        (lineStartPosition && lineStartPosition.ystart) || connectionNodeThumbsLineNode.current.ystart,\r\n                                        controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                        controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                        newPosition.x, newPosition.y\r\n                                    ] });\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                            }\r\n                            const thumbRef = shapeRefs.current[\"thumb_line_\" + connectionNodeThumbsLineNode.current.name];\r\n                            if (thumbRef) {\r\n                                thumbRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, newPosition);\r\n                            }\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                    }\r\n                    cancelDragStage();\r\n                    return;\r\n                }\r\n                if (!!canvasMode.isConnectingNodes) {\r\n                    cancelDragStage();\r\n                    return false;\r\n                }\r\n                if ((interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect && touching.current) || (touchNode.current && touchNodeGroup.current && !isPinching.current)) {\r\n                    if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n                        moveSelectRectangle(event);\r\n                    }\r\n                    document.body.classList.add(\"mouse--moving\");\r\n                    document.body.style.cursor = 'pointer';\r\n                    mouseDragging.current = true;\r\n                    if (touchNode.current && touchNode.current.shapeType === \"Line\") {\r\n                        let lineNode = touchNode.current;\r\n                        if (lineNode.startshapeid) {\r\n                            const startNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.startshapeid).index];\r\n                            if (startNode) {\r\n                                setNewPositionForNode(event, startNode, shapeRefs.current[startNode.name], event.evt && event.evt.screenX ? {\r\n                                    x: event.evt.screenX,\r\n                                    y: event.evt.screenY\r\n                                } : (event.screenX ? {\r\n                                    x: event.screenX,\r\n                                    y: event.screenY\r\n                                } : undefined), false, false, true);\r\n                            }\r\n                        }\r\n                        if (lineNode.endshapeid) {\r\n                            const endNode = flowStore.flow[flowStore.flowHashmap.get(lineNode.endshapeid).index];\r\n                            if (endNode) {\r\n                                setNewPositionForNode(event, endNode, shapeRefs.current[endNode.name], event.evt && event.evt.screenX ? {\r\n                                    x: event.evt.screenX,\r\n                                    y: event.evt.screenY\r\n                                } : (event.screenX ? {\r\n                                    x: event.screenX,\r\n                                    y: event.screenY\r\n                                } : undefined), false, false, true, false, true);\r\n                            }\r\n                        }\r\n                        cancelDragStage();\r\n                        return;\r\n                    }\r\n                    if (event.evt) {\r\n                        event.evt.preventDefault();\r\n                        event.evt.cancelBubble = true;\r\n                    }\r\n                    else {\r\n                        event.preventDefault();\r\n                        event.cancelBubble = true;\r\n                    }\r\n                    if (draggingMultipleNodes.current && draggingMultipleNodes.current.length > 0) {\r\n                        const touchPos = stageInstance.getPointerPosition();\r\n                        let offsetX = touchPos.x - mouseStartPointerX.current;\r\n                        let offsetY = touchPos.y - mouseStartPointerY.current;\r\n                        const scaleFactor = stageInstance.scaleX();\r\n                        let offsetPosition = {\r\n                            x: 0,\r\n                            y: 0\r\n                        };\r\n                        offsetPosition.x = ((offsetX) / scaleFactor);\r\n                        offsetPosition.y = ((offsetY) / scaleFactor);\r\n                        draggingMultipleNodes.current.forEach((nodeName) => {\r\n                            let mappedNode = flowStore.flowHashmap.get(nodeName);\r\n                            if (mappedNode) {\r\n                                let draggingNode = flowStore.flow[mappedNode.index];\r\n                                if (draggingNode) {\r\n                                    setNewPositionForNode(event, draggingNode, shapeRefs.current[nodeName], event.evt && event.evt.screenX ? {\r\n                                        x: event.evt.screenX,\r\n                                        y: event.evt.screenY\r\n                                    } : (event.screenX ? {\r\n                                        x: event.screenX,\r\n                                        y: event.screenY\r\n                                    } : undefined), false, false, true, false, false, offsetPosition);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        if (touchNode.current) {\r\n                            setNewPositionForNode(event, touchNode.current, shapeRefs.current[touchNode.current.name], event.evt && event.evt.screenX ? {\r\n                                x: event.evt.screenX,\r\n                                y: event.evt.screenY\r\n                            } : (event.screenX ? {\r\n                                x: event.screenX,\r\n                                y: event.screenY\r\n                            } : undefined), false, false, true);\r\n                            if (stage && stage.current) {\r\n                                let stageInstance = stage.current.getStage();\r\n                                if (stageInstance) {\r\n                                    const touchPos = getCurrentPosition(event);\r\n                                    if (touchPos) {\r\n                                        const scaleFactor = stageInstance.scaleX();\r\n                                        let x = ((touchPos.x - (stageInstance).x()) / scaleFactor) - mouseStartX.current;\r\n                                        let y = ((touchPos.y - (stageInstance).y()) / scaleFactor) - mouseStartY.current;\r\n                                        x = x - (x % gridSize.current);\r\n                                        y = y - (y % gridSize.current);\r\n                                        movingExistingOrNewNodeOnCanvas(x, y, true, touchNode.current, true);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    cancelDragStage();\r\n                    return false;\r\n                }\r\n                else {\r\n                    if (isPinching.current && event.evt && event.evt.touches && event.evt.touches.length > 1) {\r\n                        cancelDragStage();\r\n                        if (event.evt) {\r\n                            event.evt.preventDefault();\r\n                            event.evt.cancelBubble = true;\r\n                        }\r\n                        else {\r\n                            event.preventDefault();\r\n                            event.cancelBubble = true;\r\n                        }\r\n                        if (event.evt && event.evt.touches.length == 2) {\r\n                            const x = event.evt.touches[0].screenX - event.evt.touches[1].screenX;\r\n                            const y = event.evt.touches[0].screenY - event.evt.touches[1].screenY;\r\n                            let newDistance = Math.sqrt(x * x + y * y);\r\n                            wheelEvent({\r\n                                deltaY: newDistance - startDistance.current,\r\n                                toElement: undefined\r\n                            }, pinchStartPosition.current);\r\n                        }\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const cancelDragStage = () => {\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                stageInstance.stopDrag();\r\n            }\r\n        }\r\n    };\r\n    const getCurrentPosition = (event) => {\r\n        let x = 0;\r\n        let y = 0;\r\n        if (!event || event.evt) {\r\n            const stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                x = stageInstance.getPointerPosition().x;\r\n                y = stageInstance.getPointerPosition().y;\r\n            }\r\n        }\r\n        else {\r\n            x = event.clientX;\r\n            y = event.clientY;\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    };\r\n    const onTouchStart = (node, event) => {\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            return false;\r\n        }\r\n        touching.current = true;\r\n        if (event.evt) {\r\n            event.evt.preventDefault();\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        else {\r\n            event.cancelBubble = true;\r\n        }\r\n        touchNode.current = node;\r\n        touchNodeGroup.current = event.currentTarget;\r\n        mouseDragging.current = false;\r\n        cancelDragStage();\r\n        if (event.currentTarget) {\r\n            determineStartPosition(event.currentTarget, getCurrentPosition(event));\r\n        }\r\n        return false;\r\n    };\r\n    const onTouchMove = (node, event) => {\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            return false;\r\n        }\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (touchNodeGroup.current != event.currentTarget) {\r\n            return false;\r\n        }\r\n        touching.current = true;\r\n        if (event.evt) {\r\n            event.evt.preventDefault();\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        else {\r\n            event.cancelBubble = true;\r\n        }\r\n        if (node.shapeType !== \"Line\") {\r\n            mouseDragging.current = true;\r\n            setNewPositionForNode(event, node, shapeRefs.current[node.name], event.evt.touches.length > 0 ? {\r\n                x: event.evt.touches[0].screenX,\r\n                y: event.evt.touches[0].screenY\r\n            } : undefined, false, false, true);\r\n        }\r\n        return false;\r\n    };\r\n    const onTouchEnd = (node, event) => {\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            return false;\r\n        }\r\n        if (touchNodeGroup.current != event.currentTarget) {\r\n            return false;\r\n        }\r\n        touching.current = false;\r\n        dragTime.current = undefined;\r\n        touchNode.current = undefined;\r\n        touchNodeGroup.current = undefined;\r\n        if (event.evt) {\r\n            event.evt.preventDefault();\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        else {\r\n            event.cancelBubble = true;\r\n        }\r\n        if (event.currentTarget) {\r\n            if (mouseDragging.current) {\r\n                setNewPositionForNode(event, node, shapeRefs.current[node.name], event.evt.changedTouches.length > 0 ? {\r\n                    x: event.evt.changedTouches[0].screenX,\r\n                    y: event.evt.changedTouches[0].screenY\r\n                } : undefined, false, false, true);\r\n            }\r\n            else {\r\n                selectNode(node.name, node);\r\n                canvasMode.setConnectiongNodeCanvasMode(false);\r\n            }\r\n        }\r\n        mouseDragging.current = false;\r\n        return false;\r\n    };\r\n    const onMouseConnectionStartOver = (node, nodeEvent, event) => {\r\n        if (node.notSelectable) {\r\n            return false;\r\n        }\r\n        if (node && node.shapeType === \"Line\") {\r\n            document.body.style.cursor = 'pointer';\r\n            return;\r\n        }\r\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n        const allowedOutputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedOutputs(node.shapeType, settings);\r\n        if (allowedOutputs == 0 ||\r\n            !_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveOutputs(node.shapeType, settings, flowStore.flow, node, flowStore.flowHashmap)) {\r\n            return false;\r\n        }\r\n        document.body.style.cursor = 'pointer';\r\n    };\r\n    const onMouseConnectionStartOut = (node, nodeEvent, event) => {\r\n        document.body.style.cursor = null;\r\n    };\r\n    const onMouseConnectionStartStart = (node, nodeEvent, nodeEventName, followFlow, thumbPositionRelativeToNode, event) => {\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            return false;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (node && touching.current && touchNode.current) {\r\n            return;\r\n        }\r\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n        if (node && node.shapeType !== \"Line\") {\r\n            const allowedOutputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedOutputs(node.shapeType, settings);\r\n            if (allowedOutputs == 0 ||\r\n                !_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveOutputs(node.shapeType, settings, flowStore.flow, node, flowStore.flowHashmap)) {\r\n                return false;\r\n            }\r\n        }\r\n        interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.addingNewConnection;\r\n        isConnectingNodesByDraggingLocal.current = true;\r\n        connectionNodeEvent.current = nodeEvent;\r\n        connectionNodeEventName.current = nodeEventName;\r\n        connectionNodeThumbs.current = \"\";\r\n        connectionNodeThumbsLineNode.current = undefined;\r\n        connectionNodeFollowFlow.current = followFlow;\r\n        connectionNodeThumbPositionRelativeToNode.current = thumbPositionRelativeToNode;\r\n        connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        if (thumbPositionRelativeToNode == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.bottom) {\r\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top;\r\n        }\r\n        document.body.classList.add(\"connecting-nodes\");\r\n        touchNode.current = node;\r\n        touchNodeGroup.current = event.currentTarget;\r\n        let newPosition = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stage) {\r\n                var touchPos = getCurrentPosition(event);\r\n                const scaleFactor = stageInstance.scaleX();\r\n                newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\r\n                newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\r\n                connectionXStart.current = newPosition.x;\r\n                connectionYStart.current = newPosition.y;\r\n            }\r\n        }\r\n        if (node && node.shapeType === 'Line') {\r\n            connectionNodeThumbs.current = \"thumbstart\";\r\n            connectionNodeThumbsLineNode.current = node;\r\n        }\r\n        if (!event.evt) {\r\n            event.preventDefault();\r\n        }\r\n        return false;\r\n    };\r\n    const onMouseConnectionStartMove = (node, nodeEvent, event) => {\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (node && touching.current && touchNode.current) {\r\n            return;\r\n        }\r\n        if (event.evt) {\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        else {\r\n            event.cancelBubble = true;\r\n        }\r\n    };\r\n    const onMouseConnectionStartEnd = (node, nodeEvent, thumbPositionRelativeToNode, event) => {\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (node && touching.current && touchNode.current) {\r\n            return;\r\n        }\r\n    };\r\n    const onMouseConnectionEndOver = (node, nodeEvent, event, thumbPositionRelativeToNode) => {\r\n        if (interactionState.current == _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingConnectionEnd) {\r\n            return;\r\n        }\r\n        if (node.notSelectable) {\r\n            return false;\r\n        }\r\n        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(node.taskType, node);\r\n        if (node && node.shapeType !== \"Line\" &&\r\n            touching.current && touchNode.current) {\r\n            const allowedInputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedInputs(node.shapeType, settings);\r\n            if (allowedInputs == 0 ||\r\n                !_helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveInputs(node.shapeType, settings, flowStore.flow, node, flowStore.flowHashmap)) {\r\n                document.body.style.cursor = 'not-allowed';\r\n                return false;\r\n            }\r\n        }\r\n        document.body.style.cursor = 'pointer';\r\n        if (thumbPositionRelativeToNode) {\r\n            connectionNodeThumbPositionRelativeToEndNode.current = thumbPositionRelativeToNode;\r\n        }\r\n        else {\r\n            connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        }\r\n    };\r\n    const onMouseConnectionEndOut = (node, nodeEvent, event) => {\r\n        document.body.style.cursor = null;\r\n    };\r\n    const onMouseConnectionEndStart = (node, nodeEvent, event) => {\r\n        if (interactionState.current != _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle) {\r\n            if (!event.evt) {\r\n                event.preventDefault();\r\n            }\r\n            return false;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            if (!event.evt) {\r\n                event.preventDefault();\r\n            }\r\n            return false;\r\n        }\r\n        if (node && touching.current && touchNode.current && !isConnectingNodesByDraggingLocal.current) {\r\n            return;\r\n        }\r\n        if (node && node.shapeType === 'Line') {\r\n            connectionNodeThumbsLineNode.current = node;\r\n            touchNode.current = node;\r\n            touchNodeGroup.current = event.currentTarget;\r\n            interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.addingNewConnection;\r\n        }\r\n        else {\r\n            const mappedNode = flowStore.flowHashmap.get(node.name);\r\n            if (mappedNode) {\r\n                if (mappedNode.end.length > 0) {\r\n                    const lineNode = flowStore.flow[mappedNode.end[0]];\r\n                    if (!lineNode) {\r\n                        return;\r\n                    }\r\n                    connectionNodeThumbsLineNode.current = lineNode;\r\n                    touchNode.current = lineNode;\r\n                    touchNodeGroup.current = shapeRefs.current[lineNode.name];\r\n                    interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.draggingConnectionEnd;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n        isConnectingNodesByDraggingLocal.current = true;\r\n        connectionNodeEvent.current = nodeEvent;\r\n        connectionNodeEventName.current = \"\";\r\n        connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.default;\r\n        connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        connectionNodeThumbPositionRelativeToEndNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n        document.body.classList.add(\"connecting-nodes\");\r\n        let newPosition = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stage) {\r\n                var touchPos = getCurrentPosition(event);\r\n                const scaleFactor = stageInstance.scaleX();\r\n                newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\r\n                newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\r\n                connectionXStart.current = newPosition.x;\r\n                connectionYStart.current = newPosition.y;\r\n            }\r\n        }\r\n        connectionNodeThumbs.current = \"thumbend\";\r\n        if (!event.evt) {\r\n            event.preventDefault();\r\n        }\r\n        return false;\r\n    };\r\n    const onMouseConnectionEndMove = (node, nodeEvent, event) => {\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            if (!event.evt) {\r\n                event.preventDefault();\r\n            }\r\n            return false;\r\n        }\r\n        if (node && touching.current && touchNode.current && !isConnectingNodesByDraggingLocal.current) {\r\n            return;\r\n        }\r\n    };\r\n    const onMouseConnectionEndEnd = (node, nodeEvent, event, thumbPositionRelativeToNode) => {\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            if (!event.evt) {\r\n                event.preventDefault();\r\n            }\r\n            return false;\r\n        }\r\n        if (node && touching.current && touchNode.current && !isConnectingNodesByDraggingLocal.current) {\r\n            return;\r\n        }\r\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\r\n            if (connectionNodeThumbsLineNode.current) {\r\n                let clonedNode = { ...connectionNodeThumbsLineNode.current };\r\n                clonedNode.endshapeid = node.name;\r\n                connectionNodeThumbsLineNode.current = clonedNode;\r\n                return;\r\n            }\r\n            connectConnectionToNode(node, thumbPositionRelativeToNode);\r\n        }\r\n    };\r\n    const onMouseConnectionEndLeave = (node, nodeEvent, event) => {\r\n    };\r\n    let draggingWhileTouching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\r\n    const onDragStart = (node, event) => {\r\n        if (touching.current) {\r\n            draggingWhileTouching.current = true;\r\n            if (event.evt && event.evt.cancelBubble) {\r\n                event.evt.cancelBubble = true;\r\n            }\r\n            if (event && event.cancelBubble) {\r\n                event.cancelBubble = true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n    const onDragMove = (node, event) => {\r\n        if (touching.current) {\r\n            draggingWhileTouching.current = true;\r\n            return false;\r\n        }\r\n        setNewPositionForNode(event, node, shapeRefs.current[node.name], false, false, true);\r\n    };\r\n    const onDragEnd = (node, event) => {\r\n        if (touching.current || draggingWhileTouching.current) {\r\n            draggingWhileTouching.current = false;\r\n            return false;\r\n        }\r\n        dragTime.current = undefined;\r\n        setNewPositionForNode(event, node, shapeRefs.current[node.name]);\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            stageInstance.batchDraw();\r\n        }\r\n        updateTouchedNodes();\r\n    };\r\n    const onClickShape = (node, event) => {\r\n        console.log(\"onclickshape\", node.name);\r\n        event.cancelBubble = true;\r\n        if (event.evt) {\r\n            event.evt.preventDefault();\r\n        }\r\n        else {\r\n            event.preventDefault();\r\n        }\r\n        cancelDragStage();\r\n        if (isConnectingNodesByDraggingLocal.current && touchNode.current && node) {\r\n            connectConnectionToNode(node);\r\n            return false;\r\n        }\r\n        if ((!!canvasMode.isConnectingNodes || !!shiftDown.current) &&\r\n            selectedNodeRef.current !== undefined &&\r\n            selectedNodeRef.current.shapeType !== \"Line\") {\r\n            const connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewConnection)(selectedNodeRef.current, node, props.getNodeInstance, connectionNodeThumbPositionRelativeToNode.current);\r\n            if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.happyFlow) {\r\n                connection.followflow = \"onsuccess\";\r\n            }\r\n            else if (connectionNodeFollowFlow.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.unhappyFlow) {\r\n                connection.followflow = \"onfailure\";\r\n            }\r\n            flowStore.addConnection(connection);\r\n            canvasMode.setConnectiongNodeCanvasMode(false);\r\n        }\r\n        selectedNodeRef.current = node;\r\n        selectNode(node.name, node);\r\n        if (canvasMode.isConnectingNodes) {\r\n            canvasMode.setConnectiongNodeCanvasMode(false);\r\n        }\r\n        return false;\r\n    };\r\n    const onClickLine = (node, event) => {\r\n        console.log(\"onClickLine\", node);\r\n        event.cancelBubble = true;\r\n        event.evt.preventDefault();\r\n        cancelDragStage();\r\n        if (node.notSelectable) {\r\n            return false;\r\n        }\r\n        canvasMode.setConnectiongNodeCanvasMode(false);\r\n        selectNode(node.name, node);\r\n        return false;\r\n    };\r\n    const onDragStageMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (interactionState.current !== _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle) {\r\n            return false;\r\n        }\r\n        if (touching.current || draggingWhileTouching.current) {\r\n            if (event.target && event.target.stopDrag) {\r\n            }\r\n            if (event.evt && event.evt.cancelBubble) {\r\n                event.evt.cancelBubble = true;\r\n            }\r\n            if (event && event.cancelBubble) {\r\n                event.cancelBubble = true;\r\n            }\r\n            return false;\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                stageX.current = stageInstance.x();\r\n                stageY.current = stageInstance.y();\r\n                stageScale.current = stageInstance.scale().x;\r\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\r\n            }\r\n        }\r\n    }, [flowStore.flow]);\r\n    const onDragStageEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\r\n        if (isPinching.current) {\r\n            return;\r\n        }\r\n        if (!!canvasMode.isConnectingNodes) {\r\n            return false;\r\n        }\r\n        if (interactionState.current !== _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle) {\r\n            return false;\r\n        }\r\n        if (event.evt && event.evt.cancelBubble) {\r\n            event.evt.cancelBubble = true;\r\n        }\r\n        if (event && event.cancelBubble) {\r\n            event.cancelBubble = true;\r\n        }\r\n        if (touching.current || draggingWhileTouching.current) {\r\n            return false;\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                stageX.current = stageInstance.x();\r\n                stageY.current = stageInstance.y();\r\n                stageScale.current = stageInstance.scale().x;\r\n                setHtmlElementsPositionAndScale(stageX.current, stageY.current, stageScale.current);\r\n            }\r\n        }\r\n    }, [flowStore.flow]);\r\n    const setHtmlElementsPositionAndScale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((stageX, stageY, stageScale, newX, newY, node, repositionSingleNode) => {\r\n        flowStore.flow.map((flowNode) => {\r\n            if (flowNode.shapeType !== \"Line\") {\r\n                const element = elementRefs.current[flowNode.name];\r\n                if (element) {\r\n                    let x = parseFloat(element.getAttribute(\"data-x\") || \"\");\r\n                    let y = parseFloat(element.getAttribute(\"data-y\") || \"\");\r\n                    const clientElementHeight = element.clientHeight;\r\n                    if (node && element.getAttribute(\"data-node\") == node.name) {\r\n                        if (newX && !isNaN(newX)) {\r\n                            x = newX;\r\n                        }\r\n                        if (newY && !isNaN(newY)) {\r\n                            y = newY;\r\n                        }\r\n                        element.setAttribute(\"data-x\", x.toString());\r\n                        element.setAttribute(\"data-y\", y.toString());\r\n                    }\r\n                    const nodeName = element.getAttribute(\"data-node\") || \"\";\r\n                    setHtmlElementStyle(element, 0, 0, 1, x, y);\r\n                }\r\n            }\r\n        });\r\n        setHtmlGlobalScale(stageX, stageY, stageScale);\r\n    }, [flowStore.flow]);\r\n    const setHtmlGlobalScale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((stageX, stageY, stageScale) => {\r\n        if (htmlWrapper && htmlWrapper.current) {\r\n            htmlWrapper.current.style.transform =\r\n                \"translate(\" + (stageX) + \"px,\" + (stageY) + \"px) \" +\r\n                    \"scale(\" + (stageScale) + \",\" + (stageScale) + \") \";\r\n        }\r\n    }, [flowStore.flow]);\r\n    const setHtmlElementStyle = (element, stageX, stageY, stageScale, x, y) => {\r\n        element.style.transform =\r\n            \"translate(\" + (stageX + x * stageScale) + \"px,\" +\r\n                (stageY + y * stageScale) + \"px) \" +\r\n                \"scale(\" + (stageScale) + \",\" + (stageScale) + \") \";\r\n    };\r\n    const fitStage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node, doBatchdraw, doSetHtmlElementsPositionAndScale, doAnimate) => {\r\n        let xMin;\r\n        let yMin;\r\n        let xMax;\r\n        let yMax;\r\n        let containsHtmlShape = false;\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance !== undefined) {\r\n                flowStore.flow.map((shape, index) => {\r\n                    if (node !== undefined) {\r\n                        if (node.id !== shape.id) {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (shape.shapeType != \"Line\") {\r\n                        const taskSettings = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getTaskSettings(shape.taskType);\r\n                        let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeTypeUsingSettings(shape.shapeType, shape.taskType, shape.isStartEnd, taskSettings);\r\n                        const RealShape = _shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes[shapeType];\r\n                        let addWidth = 0;\r\n                        let addHeight = 0;\r\n                        let subtractWidth = 0;\r\n                        let subtractHeight = 0;\r\n                        if (shapeType === \"Html\") {\r\n                            containsHtmlShape = true;\r\n                            let width = undefined;\r\n                            let height = undefined;\r\n                            if (props.getNodeInstance) {\r\n                                const instance = props.getNodeInstance(shape, props.flowrunnerConnector, flowStore.flow, taskSettings);\r\n                                if (instance) {\r\n                                    if (instance.getWidth && instance.getHeight) {\r\n                                        width = instance.getWidth(shape);\r\n                                        height = instance.getHeight(shape);\r\n                                    }\r\n                                }\r\n                            }\r\n                            let element = document.querySelector(\"#\" + shape.name + \" .html-plugin-node\");\r\n                            if (element) {\r\n                                const elementHeight = element.clientHeight;\r\n                                if (elementHeight > height) {\r\n                                    height = elementHeight;\r\n                                }\r\n                                const elementWidth = element.clientWidth;\r\n                                if (elementWidth > width) {\r\n                                    width = elementWidth;\r\n                                }\r\n                            }\r\n                            subtractWidth = 0;\r\n                            subtractHeight = 0;\r\n                            addWidth = (width || shape.width || 250);\r\n                            addHeight = (height || shape.height || 250);\r\n                        }\r\n                        else {\r\n                            addWidth = 100;\r\n                            addHeight = 50;\r\n                            if (shapeType === 'Circle') {\r\n                                addWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize;\r\n                                addHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize;\r\n                            }\r\n                            else if (shapeType === 'Diamond') {\r\n                                addWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize;\r\n                                addHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize;\r\n                            }\r\n                            else {\r\n                                addWidth = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectWidht;\r\n                                addHeight = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectHeight;\r\n                            }\r\n                        }\r\n                        if (xMin === undefined) {\r\n                            xMin = shape.x - subtractWidth;\r\n                        }\r\n                        if (yMin === undefined) {\r\n                            yMin = shape.y - subtractHeight;\r\n                        }\r\n                        if (xMax === undefined) {\r\n                            xMax = shape.x + addWidth;\r\n                        }\r\n                        if (yMax === undefined) {\r\n                            yMax = shape.y + addHeight;\r\n                        }\r\n                        if (shape.x - subtractWidth < xMin) {\r\n                            xMin = shape.x - subtractWidth;\r\n                        }\r\n                        if (shape.x + addWidth > xMax) {\r\n                            xMax = shape.x + addWidth;\r\n                        }\r\n                        if (shape.y - subtractHeight < yMin) {\r\n                            yMin = shape.y - subtractHeight;\r\n                        }\r\n                        if (shape.y + addHeight > yMax) {\r\n                            yMax = shape.y + addHeight;\r\n                        }\r\n                    }\r\n                });\r\n                if (flowStore.flow.length > 0 &&\r\n                    xMin !== undefined && yMin !== undefined && xMax !== undefined && yMax !== undefined) {\r\n                    let scale = 1;\r\n                    let flowWidth = Math.abs(xMax - xMin);\r\n                    let flowHeight = Math.abs(yMax - yMin);\r\n                    const stageContainerElement = document.querySelector(\"body .canvas-controller__scroll-container\");\r\n                    const bodyElement = document.querySelector(\"body\");\r\n                    if (stageContainerElement !== null && bodyElement !== null) {\r\n                        let subtractWidth = 128;\r\n                        if (stageContainerElement.clientWidth < 1024) {\r\n                            subtractWidth = 0;\r\n                        }\r\n                        let realStageWidth = stageContainerElement.clientWidth - subtractWidth;\r\n                        let realStageHeight = bodyElement.clientHeight - 64;\r\n                        if (realStageHeight < 500) {\r\n                        }\r\n                        if (flowStore.flow.length === 1) {\r\n                            scale = 1;\r\n                            if (stageContainerElement.clientWidth < 1024) {\r\n                                scale = 0.5;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (flowWidth !== 0) {\r\n                                scale = realStageWidth / flowWidth;\r\n                            }\r\n                            if (flowHeight * scale > realStageHeight) {\r\n                                scale = realStageHeight / flowHeight;\r\n                            }\r\n                            scale = scale * 0.7;\r\n                        }\r\n                        if (node !== undefined) {\r\n                            if (containsHtmlShape) {\r\n                                scale = scale * 0.5;\r\n                            }\r\n                            else {\r\n                                scale = scale * 0.15;\r\n                            }\r\n                        }\r\n                        stageInstance.scale({ x: scale, y: scale });\r\n                        const newPos = {\r\n                            x: 0,\r\n                            y: 0\r\n                        };\r\n                        let offsetX = 64;\r\n                        let stageWidth = stageContainerElement.clientWidth;\r\n                        let stageHeight = bodyElement.clientHeight;\r\n                        if (stageWidth < 1024) {\r\n                            offsetX = 0;\r\n                        }\r\n                        newPos.x = offsetX + (-(xMin) * scale) + (stageWidth) / 2 - ((flowWidth * scale)) / 2;\r\n                        newPos.y = (-(yMin) * scale) + (stageHeight + 64) / 2 - ((flowHeight * scale)) / 2;\r\n                        stageInstance.position(newPos);\r\n                        if (!!doBatchdraw) {\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                        stageX.current = newPos.x;\r\n                        stageY.current = newPos.y;\r\n                        stageScale.current = scale;\r\n                        if (doSetHtmlElementsPositionAndScale === undefined || !!doSetHtmlElementsPositionAndScale) {\r\n                            setHtmlElementsPositionAndScale(newPos.x, newPos.y, scale);\r\n                        }\r\n                        setCanvasOpacity(1);\r\n                        let stopAnimation = false;\r\n                        if (window.localStorage && !!doAnimate) {\r\n                            let as = localStorage.getItem('animation') || \"\";\r\n                            animationScript.current = undefined;\r\n                            if (as) {\r\n                                animationScript.current = JSON.parse(as);\r\n                            }\r\n                            let canvas = document.querySelector(\"canvas\");\r\n                            if (canvas) {\r\n                                canvas.requestPointerLock();\r\n                            }\r\n                            let stageInstance = stage.current.getStage();\r\n                            if (animationScript.current) {\r\n                                let nodesToAnimate = animationScript.current.nodes;\r\n                                if (animationScript.current.zoom && stageInstance) {\r\n                                    scale = animationScript.current.zoom;\r\n                                    stageInstance.autoDrawEnabled = false;\r\n                                    konva__WEBPACK_IMPORTED_MODULE_29__.default.autoDrawEnabled = false;\r\n                                    if (layer && layer.current) {\r\n                                        layer.current.listening(false);\r\n                                        layer.current.batchDraw();\r\n                                    }\r\n                                }\r\n                                animationScript.current.loop = 0;\r\n                                if (animationScript.current.loop < nodesToAnimate.length) {\r\n                                    let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(nodesToAnimate[animationScript.current.loop]);\r\n                                    if (stageInstance && position) {\r\n                                        if (stageGroup && stageGroup.current) {\r\n                                            stageGroup.current.cache();\r\n                                        }\r\n                                        let zoom = animationScript.current.zoom;\r\n                                        const triggerAnimation = () => {\r\n                                            let isDrawing = false;\r\n                                            newPos.x = offsetX + (-position.x * scale) + (stageWidth) / 2 - (150 * scale);\r\n                                            newPos.y = (-position.y * scale) + (stageHeight + 64) / 2 - (150 * scale);\r\n                                            ;\r\n                                            let tween = (0,_konva_Tween__WEBPACK_IMPORTED_MODULE_30__.animateTo)(stageInstance, {\r\n                                                x: newPos.x,\r\n                                                y: newPos.y,\r\n                                                scaleX: zoom,\r\n                                                scaleY: zoom,\r\n                                                duration: animationScript.current.duration || 3,\r\n                                                easing: konva__WEBPACK_IMPORTED_MODULE_29__.default.Easings.EaseInOut,\r\n                                                onUpdate: () => {\r\n                                                    if (isDrawing) {\r\n                                                        return false;\r\n                                                    }\r\n                                                    isDrawing = true;\r\n                                                    stageX.current = stageInstance.x();\r\n                                                    stageY.current = stageInstance.y();\r\n                                                    stageScale.current = stageInstance.scale().x;\r\n                                                    stageInstance.draw();\r\n                                                    setHtmlGlobalScale(stageX.current, stageY.current, stageScale.current);\r\n                                                    isDrawing = false;\r\n                                                    return false;\r\n                                                },\r\n                                                onFinish: () => {\r\n                                                    tween.destroy();\r\n                                                    if (!stopAnimation) {\r\n                                                        animationScript.current.loop++;\r\n                                                        if (animationScript.current.loop < nodesToAnimate.length) {\r\n                                                            position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(nodesToAnimate[animationScript.current.loop]);\r\n                                                            if (position) {\r\n                                                                triggerAnimation();\r\n                                                            }\r\n                                                        }\r\n                                                        else {\r\n                                                            stageInstance.autoDrawEnabled = true;\r\n                                                            konva__WEBPACK_IMPORTED_MODULE_29__.default.autoDrawEnabled = true;\r\n                                                            if (layer && layer.current) {\r\n                                                                stageGroup.current.clearCache();\r\n                                                                layer.current.listening(true);\r\n                                                                layer.current.batchDraw();\r\n                                                            }\r\n                                                            document.exitPointerLock();\r\n                                                        }\r\n                                                    }\r\n                                                },\r\n                                            });\r\n                                        };\r\n                                        triggerAnimation();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    const newPos = {\r\n                        x: 0,\r\n                        y: 0\r\n                    };\r\n                    let scale = 1;\r\n                    const stageContainerElement = document.querySelector(\".canvas-controller__scroll-container\");\r\n                    if (stageContainerElement !== null) {\r\n                        if (stageContainerElement.clientWidth < 1024) {\r\n                            scale = 0.5;\r\n                        }\r\n                    }\r\n                    stageInstance.position(newPos);\r\n                    if (!!doBatchdraw) {\r\n                        stageInstance.batchDraw();\r\n                    }\r\n                    stageX.current = newPos.x;\r\n                    stageY.current = newPos.y;\r\n                    stageScale.current = scale;\r\n                    setHtmlElementsPositionAndScale(newPos.x, newPos.y, scale);\r\n                    setCanvasOpacity(1);\r\n                }\r\n            }\r\n        }\r\n    }, [flowStore.flow]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        console.log(\"useEffect AFTER fitstage\", flowStore.flowId, performance.now());\r\n    }, [flowStore.flow]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        gridSize.current = canvasMode.snapToGrid ? 50 : 1;\r\n    }, [canvasMode.snapToGrid]);\r\n    const clickStage = (event) => {\r\n        if (isConnectingNodesByDraggingLocal.current) {\r\n            event.evt.preventDefault();\r\n            if (touchNode.current) {\r\n                if (stage && stage.current) {\r\n                    let stageInstance = stage.current.getStage();\r\n                    const touchPos = stageInstance.getPointerPosition();\r\n                    const scaleFactor = stageInstance.scaleX();\r\n                    let newPosition = {\r\n                        x: 0,\r\n                        y: 0\r\n                    };\r\n                    newPosition.x = ((touchPos.x - (stageInstance).x()) / scaleFactor);\r\n                    newPosition.y = ((touchPos.y - (stageInstance).y()) / scaleFactor);\r\n                    const connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewConnection)(touchNode.current, undefined, props.getNodeInstance, undefined, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default, newPosition.x, newPosition.y);\r\n                    clearConnectionState();\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connection.name, {\r\n                        xstart: connection.xstart,\r\n                        ystart: connection.ystart,\r\n                        xend: connection.xend,\r\n                        yend: connection.yend\r\n                    });\r\n                    flowStore.addConnection(connection);\r\n                    canvasMode.setConnectiongNodeCanvasMode(false);\r\n                }\r\n            }\r\n            isConnectingNodesByDraggingLocal.current = false;\r\n            connectionNodeEvent.current = false;\r\n            connectionNodeEventName.current = \"\";\r\n            connectionNodeThumbPositionRelativeToNode.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n            connectionNodeFollowFlow.current = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbFollowFlow.default;\r\n            touchNode.current = undefined;\r\n            touchNodeGroup.current = undefined;\r\n            document.body.classList.remove(\"connecting-nodes\");\r\n            document.body.classList.remove(\"mouse--moving\");\r\n            document.body.style.cursor = null;\r\n            const lineRef = shapeRefs.current[connectionForDraggingName];\r\n            if (lineRef) {\r\n                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                if (stage && stage.current) {\r\n                    let stageInstance = stage.current.getStage();\r\n                    if (stageInstance !== undefined) {\r\n                        stageInstance.batchDraw();\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        if (touchNode.current && touchNodeGroup.current) {\r\n            event.evt.preventDefault();\r\n            return false;\r\n        }\r\n        const nodeIsSelected = !!selectedNodeRef.current;\r\n        if (!nodeIsSelected && canvasMode.selectedTask !== undefined &&\r\n            canvasMode.selectedTask !== \"\") {\r\n            if (!canvasMode.isConnectingNodes) {\r\n                if (stage && stage.current) {\r\n                    let stageInstance = stage.current.getStage();\r\n                    const position = stageInstance.getPointerPosition();\r\n                    const scaleFactor = stageInstance.scaleX();\r\n                    const taskType = canvasMode.selectedTask || \"TraceConsoleTask\";\r\n                    let presetValues = {};\r\n                    const shapeSetting = (0,_config__WEBPACK_IMPORTED_MODULE_5__.getTaskConfigForTask)(taskType);\r\n                    if (shapeSetting && shapeSetting.presetValues) {\r\n                        presetValues = shapeSetting.presetValues;\r\n                    }\r\n                    let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewNode)({\r\n                        name: canvasMode.selectedTask,\r\n                        id: canvasMode.selectedTask,\r\n                        taskType: taskType,\r\n                        shapeType: canvasMode.selectedTask == \"IfConditionTask\" ? \"Diamond\" : (shapeSetting.shapeType ? shapeSetting.shapeType : \"Rect\"),\r\n                        x: ((position.x - (stageInstance).x()) / scaleFactor),\r\n                        y: ((position.y - (stageInstance).y()) / scaleFactor),\r\n                        ...presetValues\r\n                    }, flowStore.flow);\r\n                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(newNode.taskType, newNode);\r\n                    let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeType(newNode.shapeType, newNode.taskType, newNode.isStartEnd);\r\n                    let centerXCorrection = 0;\r\n                    let centerYCorrection = 0;\r\n                    if (shapeType == \"Rect\" || shapeType == \"Ellipse\") {\r\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectWidht / 2;\r\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectHeight / 2;\r\n                    }\r\n                    else if (shapeType == \"Circle\") {\r\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize / 2;\r\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize / 2;\r\n                    }\r\n                    else if (shapeType == \"Diamond\") {\r\n                        centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize / 2;\r\n                        centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize / 2;\r\n                    }\r\n                    newNode.x = newNode.x - centerXCorrection;\r\n                    newNode.y = newNode.y - centerYCorrection;\r\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                    if (lineRef) {\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                        if (stage && stage.current) {\r\n                            let stageInstance = stage.current.getStage();\r\n                            if (stageInstance !== undefined) {\r\n                                stageInstance.batchDraw();\r\n                            }\r\n                        }\r\n                    }\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\r\n                        x: newNode.x,\r\n                        y: newNode.y\r\n                    });\r\n                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(newNode.name, {\r\n                        x: newNode.x,\r\n                        y: newNode.y\r\n                    });\r\n                    flowStore.addFlowNode(newNode);\r\n                }\r\n            }\r\n        }\r\n        selectNode(\"\", undefined);\r\n        canvasMode.setConnectiongNodeCanvasMode(false);\r\n        canvasMode.setSelectedTask(\"\");\r\n        if (interactionState.current === _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.multiSelect) {\r\n            canvasMode.setIsInMultiSelect(false, []);\r\n        }\r\n        touching.current = false;\r\n        deselectAllNodes();\r\n        interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n        selectingRectRef.current.opacity(0);\r\n        return false;\r\n    };\r\n    const getNodeByName = (nodeName) => {\r\n        const nodes = flowStore.flow.filter((node, index) => {\r\n            return node.name === nodeName;\r\n        });\r\n        if (nodes.length > 0) {\r\n            return nodes[0];\r\n        }\r\n        return null;\r\n    };\r\n    const getNodeByVariableName = (nodeName) => {\r\n        const nodes = flowStore.flow.filter((node, index) => {\r\n            return node.variableName === nodeName && node.taskType;\r\n        });\r\n        if (nodes.length > 0) {\r\n            return nodes[0];\r\n        }\r\n        return null;\r\n    };\r\n    const getDependentConnections = () => {\r\n        const nodeIsSelected = !!selectedNodeRef.current && selectedNodeRef.current.name;\r\n        try {\r\n            let connections = [];\r\n            if (props.getNodeDependencies) {\r\n                const nodeConnections = props.getNodeDependencies(selectedNodeRef.current.name);\r\n                nodeConnections.forEach((nodeDependency, index) => {\r\n                    let breakOut = false;\r\n                    if (nodeIsSelected &&\r\n                        nodeDependency.startNodeName !== selectedNodeRef.current.name &&\r\n                        nodeDependency.endNodeName !== selectedNodeRef.current.name) {\r\n                        breakOut = true;\r\n                    }\r\n                    if (!breakOut) {\r\n                        const startNode = getNodeByName(nodeDependency.startNodeName);\r\n                        const endNode = getNodeByName(nodeDependency.endNodeName);\r\n                        const startPositionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(startNode.name) || startNode;\r\n                        const endPositionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(endNode.name) || endNode;\r\n                        const startPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(startNode, { x: startPositionNode.x, y: startPositionNode.y }, undefined, props.getNodeInstance);\r\n                        const endPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(endNode, { x: endPositionNode.x, y: endPositionNode.y }, undefined, props.getNodeInstance);\r\n                        let connection = {\r\n                            shapeType: \"Line\",\r\n                            name: \"_dc\" + index,\r\n                            id: \"_dc\" + index,\r\n                            xstart: startPosition.x,\r\n                            ystart: startPosition.y,\r\n                            xend: endPosition.x,\r\n                            yend: endPosition.y,\r\n                            notSelectable: true,\r\n                            startshapeid: startNode.name,\r\n                            endshapeid: endNode.name,\r\n                            isConnectionWithVariable: !!nodeDependency.isVariable,\r\n                            isConnectionWithFunction: !!nodeDependency.isFunction\r\n                        };\r\n                        connections.push(connection);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                flowStore.flow.forEach((node, index) => {\r\n                    if (node.shapeType !== \"Line\") {\r\n                        const nodeJson = JSON.stringify(node);\r\n                        let nodeMatches = nodeJson.match(/(\"node\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        const getVariableNodeMatches = nodeJson.match(/(\"getVariable\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (getVariableNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(getVariableNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = getVariableNodeMatches;\r\n                            }\r\n                        }\r\n                        const setVariableNodeMatches = nodeJson.match(/(\"setVariable\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (setVariableNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(setVariableNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = setVariableNodeMatches;\r\n                            }\r\n                        }\r\n                        const datasourceNodeMatches = nodeJson.match(/(\"datasourceNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (datasourceNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(datasourceNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = datasourceNodeMatches;\r\n                            }\r\n                        }\r\n                        const functionCallNodeMatches = nodeJson.match(/(\"functionnodeid\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (functionCallNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(functionCallNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = functionCallNodeMatches;\r\n                            }\r\n                        }\r\n                        const detailNodeMatches = nodeJson.match(/(\"detailNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (detailNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(detailNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = detailNodeMatches;\r\n                            }\r\n                        }\r\n                        const deleteNodeMatches = nodeJson.match(/(\"deleteNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (deleteNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(deleteNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = deleteNodeMatches;\r\n                            }\r\n                        }\r\n                        const listFromNodeMatches = nodeJson.match(/(\"useListFromNode\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                        if (listFromNodeMatches) {\r\n                            if (nodeMatches) {\r\n                                nodeMatches = nodeMatches.concat(listFromNodeMatches);\r\n                            }\r\n                            else {\r\n                                nodeMatches = listFromNodeMatches;\r\n                            }\r\n                        }\r\n                        if (node.taskType && node.taskType.indexOf(\"Type\") < 0) {\r\n                            const variableNodeMatches = nodeJson.match(/(\"variableName\":\\ ?\"[a-zA-Z0-9\\- :]*\")/g);\r\n                            if (variableNodeMatches) {\r\n                                if (nodeMatches) {\r\n                                    nodeMatches = nodeMatches.concat(variableNodeMatches);\r\n                                }\r\n                                else {\r\n                                    nodeMatches = variableNodeMatches;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (nodeMatches) {\r\n                            nodeMatches.map((match, index) => {\r\n                                let isNodeByName = match.indexOf('\"node\":') >= 0;\r\n                                let isGetVariable = match.indexOf('\"getVariable\":') >= 0;\r\n                                let isSetVariable = match.indexOf('\"setVariable\":') >= 0;\r\n                                let isFunctionCall = match.indexOf('\"functionnodeid\":') >= 0;\r\n                                let isUseListFromNode = match.indexOf('\"useListFromNode\":') >= 0;\r\n                                isNodeByName = isNodeByName || isUseListFromNode || isFunctionCall;\r\n                                let nodeName = match.replace('\"node\":', \"\");\r\n                                nodeName = nodeName.replace('\"variableName\":', \"\");\r\n                                nodeName = nodeName.replace('\"getVariable\":', \"\");\r\n                                nodeName = nodeName.replace('\"setVariable\":', \"\");\r\n                                nodeName = nodeName.replace('\"datasourceNode\":', \"\");\r\n                                nodeName = nodeName.replace('\"functionnodeid\":', \"\");\r\n                                nodeName = nodeName.replace('\"detailNode\":', \"\");\r\n                                nodeName = nodeName.replace('\"deleteNode\":', \"\");\r\n                                nodeName = nodeName.replace('\"useListFromNode\":', \"\");\r\n                                nodeName = nodeName.replace(/\\ /g, \"\");\r\n                                nodeName = nodeName.replace(/\\\"/g, \"\");\r\n                                let nodeEnd;\r\n                                let startToEnd = true;\r\n                                let isConnectionWithVariable = false;\r\n                                if (isNodeByName && !isGetVariable && !isSetVariable) {\r\n                                    nodeEnd = getNodeByName(nodeName);\r\n                                    if (nodeEnd && !!nodeEnd.hasVariableAttached) {\r\n                                        isConnectionWithVariable = true;\r\n                                    }\r\n                                    if (nodeEnd && nodeEnd.variableName && node.getVariable) {\r\n                                        nodeEnd = undefined;\r\n                                    }\r\n                                }\r\n                                if (isGetVariable || isSetVariable) {\r\n                                    nodeEnd = getNodeByVariableName(nodeName);\r\n                                    if (nodeEnd) {\r\n                                        isConnectionWithVariable = true;\r\n                                    }\r\n                                    if (isGetVariable) {\r\n                                        startToEnd = false;\r\n                                    }\r\n                                }\r\n                                if (nodeEnd) {\r\n                                    if (nodeIsSelected &&\r\n                                        node.name !== selectedNodeRef.current.name &&\r\n                                        nodeEnd.name !== selectedNodeRef.current.name) {\r\n                                        console.log(\"getdeps\", selectedNodeRef.current, node.name, nodeEnd.name);\r\n                                        return;\r\n                                    }\r\n                                    const startPositionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name) || node;\r\n                                    const endPositionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(nodeEnd.name) || nodeEnd;\r\n                                    let startPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(node, { x: startPositionNode.x, y: startPositionNode.y }, undefined, props.getNodeInstance);\r\n                                    let endPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(nodeEnd, { x: endPositionNode.x, y: endPositionNode.y }, undefined, props.getNodeInstance);\r\n                                    if (!startToEnd) {\r\n                                        startPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(nodeEnd, { x: endPositionNode.x, y: endPositionNode.y }, undefined, props.getNodeInstance);\r\n                                        endPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(node, { x: startPositionNode.x, y: startPositionNode.y }, undefined, props.getNodeInstance);\r\n                                    }\r\n                                    let connection = {\r\n                                        shapeType: \"Line\",\r\n                                        name: \"_dc\" + index,\r\n                                        id: \"_dc\" + index,\r\n                                        xstart: startPosition.x,\r\n                                        ystart: startPosition.y,\r\n                                        xend: endPosition.x,\r\n                                        yend: endPosition.y,\r\n                                        notSelectable: true,\r\n                                        startshapeid: (startToEnd ? node.name : nodeEnd.name),\r\n                                        endshapeid: (startToEnd ? nodeEnd.name : node.name),\r\n                                        isConnectionWithVariable: isConnectionWithVariable,\r\n                                        isConnectionWithFunction: isFunctionCall\r\n                                    };\r\n                                    connections.push(connection);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return connections;\r\n        }\r\n        catch (err) {\r\n            console.log(err);\r\n            return [];\r\n        }\r\n    };\r\n    const onDropTask = (event) => {\r\n        event.preventDefault();\r\n        let taskClassName = event.dataTransfer.getData(\"data-task\");\r\n        addTaskToCanvas(event, taskClassName);\r\n    };\r\n    const addFlowFromRepoToCanvas = (repositoryItem, draggableElementRect) => {\r\n        if (repositoryItem) {\r\n            let repoFlow = JSON.parse(repositoryItem.flow);\r\n            if (stage && stage.current) {\r\n                let stageInstance = stage.current.getStage();\r\n                const position = stageInstance.getPointerPosition();\r\n                const scaleFactor = stageInstance.scaleX();\r\n                const x = (position.x - (stageInstance).x()) / scaleFactor;\r\n                const y = (position.y - (stageInstance).y()) / scaleFactor;\r\n                let renameIdMap = {};\r\n                repoFlow = repoFlow.map((node) => {\r\n                    if (node.shapeType !== \"Line\") {\r\n                        renameIdMap[node.name] = \"node_\" + uuidV4();\r\n                        return { ...node,\r\n                            name: renameIdMap[node.name],\r\n                            id: renameIdMap[node.name]\r\n                        };\r\n                    }\r\n                    return node;\r\n                });\r\n                repoFlow = repoFlow.map((node) => {\r\n                    if (node.shapeType === \"Line\") {\r\n                        renameIdMap[node.name] = \"node_\" + uuidV4();\r\n                        return { ...node,\r\n                            name: renameIdMap[node.name],\r\n                            id: renameIdMap[node.name],\r\n                            startshapeid: renameIdMap[node.startshapeid],\r\n                            endshapeid: renameIdMap[node.endshapeid]\r\n                        };\r\n                    }\r\n                    return node;\r\n                });\r\n                repoFlow.forEach((node) => {\r\n                    if (node.shapeType === \"Line\") {\r\n                        node.xstart += x;\r\n                        node.ystart += y;\r\n                        node.xend += x;\r\n                        node.yend += y;\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                            xstart: node.xstart,\r\n                            ystart: node.ystart,\r\n                            xend: node.xend,\r\n                            yend: node.yend\r\n                        });\r\n                    }\r\n                    else {\r\n                        node.x += x;\r\n                        node.y += y;\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                            x: node.x,\r\n                            y: node.y\r\n                        });\r\n                    }\r\n                });\r\n                flowStore.addFlowNodes(repoFlow);\r\n            }\r\n        }\r\n    };\r\n    const loadRepoItemFromModuleAndAdd = (taskClassName, draggableElementRect) => {\r\n        const element = document.getElementById(\"task_\" + taskClassName);\r\n        if (element) {\r\n            const taskId = element.getAttribute('data-id');\r\n            fetch(`/api/modulecontent?moduleId=repository&id=${taskId}`)\r\n                .then(res => {\r\n                if (res.status >= 400) {\r\n                    throw new Error(\"Bad response from server\");\r\n                }\r\n                return res.json();\r\n            })\r\n                .then(repositoryItem => {\r\n                console.log(\"repositoryItem\", repositoryItem);\r\n                addFlowFromRepoToCanvas(repositoryItem, draggableElementRect);\r\n            })\r\n                .catch(err => {\r\n                console.error(err);\r\n            });\r\n        }\r\n    };\r\n    const loadCustomNodeFromModuleAndAdd = (event, taskClassName, draggableElementRect) => {\r\n        const element = document.getElementById(\"task_\" + taskClassName);\r\n        if (element) {\r\n            const taskId = element.getAttribute('data-id');\r\n            fetch(`/api/modulecontent?moduleId=customNodes&id=${taskId}`)\r\n                .then(res => {\r\n                if (res.status >= 400) {\r\n                    throw new Error(\"Bad response from server\");\r\n                }\r\n                return res.json();\r\n            })\r\n                .then(customNode => {\r\n                console.log(\"customNode\", customNode);\r\n                if (customNode.taskName) {\r\n                    addTaskClassNameToCanvas(event, \"CustomNodeTask\", {\r\n                        nodeTask: customNode.taskName,\r\n                        htmlPlugin: 'customNode',\r\n                        config: customNode\r\n                    }, draggableElementRect);\r\n                }\r\n            })\r\n                .catch(err => {\r\n                console.error(err);\r\n            });\r\n        }\r\n    };\r\n    const addTaskClassNameToCanvas = (event, taskClassName, extraNodeProperties, draggableElementRect) => {\r\n        if (stage && stage.current) {\r\n            const stageInstance = stage.current.getStage();\r\n            if (lastMousePositionRef.current) {\r\n                console.log(\"lastMousePositionRef.current\", lastMousePositionRef.current);\r\n                stageInstance.setPointersPositions(lastMousePositionRef.current);\r\n            }\r\n            selectNode(\"\", undefined);\r\n            canvasMode.setConnectiongNodeCanvasMode(false);\r\n            if (taskClassName && taskClassName !== \"\") {\r\n                if (!canvasMode.isConnectingNodes) {\r\n                    if (stage && stage.current) {\r\n                        interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.addingNewNode;\r\n                        const position = stageInstance.getPointerPosition();\r\n                        console.log(\"add task position info\", position, stageInstance.x(), stageInstance.y());\r\n                        const scaleFactor = stageInstance.scaleX();\r\n                        const taskType = taskClassName;\r\n                        let presetValues = {};\r\n                        const shapeSetting = (0,_config__WEBPACK_IMPORTED_MODULE_5__.getTaskConfigForTask)(taskType);\r\n                        if (shapeSetting && shapeSetting.presetValues) {\r\n                            presetValues = shapeSetting.presetValues;\r\n                        }\r\n                        let newNode = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewNode)({\r\n                            name: taskClassName,\r\n                            id: taskClassName,\r\n                            taskType: taskType,\r\n                            shapeType: taskClassName === \"IfConditionTask\" ? \"Diamond\" : (shapeSetting.shapeType ? shapeSetting.shapeType : \"Rect\"),\r\n                            x: ((position.x || 0) - (stageInstance).x() || 0) / scaleFactor,\r\n                            y: ((position.y || 0) - (stageInstance).y() || 0) / scaleFactor,\r\n                            ...presetValues,\r\n                            ...extraNodeProperties\r\n                        }, flowStore.flow);\r\n                        console.log(\"getnewnode pos\", newNode.x, newNode.y);\r\n                        const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(newNode.taskType, newNode);\r\n                        let shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getShapeType(newNode.shapeType, newNode.taskType, newNode.isStartEnd);\r\n                        if (shapeType === \"Html\" && draggableElementRect) {\r\n                            if (props.getNodeInstance) {\r\n                                const left = Math.round((draggableElementRect.left + draggableElementRect.right) / 2);\r\n                                let result = props.getNodeInstance(newNode, props.flowrunnerConnector, undefined, settings);\r\n                                if (result && result.getWidth) {\r\n                                    newNode.x = (left - (stageInstance).x()) / scaleFactor;\r\n                                    newNode.y = (draggableElementRect.top - (stageInstance).y()) / scaleFactor;\r\n                                    newNode.x -= (result.getWidth(newNode) || newNode.width || 250) / 2;\r\n                                }\r\n                            }\r\n                        }\r\n                        let centerXCorrection = 0;\r\n                        let centerYCorrection = 0;\r\n                        if (shapeType === \"Rect\" || shapeType === \"Ellipse\") {\r\n                            centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectWidht / 2;\r\n                            centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.rectHeight / 2;\r\n                        }\r\n                        else if (shapeType === \"Circle\") {\r\n                            centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize / 2;\r\n                            centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.circleSize / 2;\r\n                        }\r\n                        else if (shapeType === \"Diamond\") {\r\n                            centerXCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize / 2;\r\n                            centerYCorrection = _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_10__.ShapeMeasures.diamondSize / 2;\r\n                        }\r\n                        newNode.x = newNode.x - centerXCorrection;\r\n                        newNode.y = newNode.y - centerYCorrection;\r\n                        const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                        if (lineRef) {\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(newNode.name, {\r\n                            x: newNode.x,\r\n                            y: newNode.y\r\n                        });\r\n                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(newNode.name, {\r\n                            x: newNode.x,\r\n                            y: newNode.y\r\n                        });\r\n                        flowStore.addFlowNode(newNode);\r\n                        if (closestNodeAreLineNodes.current) {\r\n                            if (closestEndNodeWhenAddingNewNode.current) {\r\n                                const closestEndConnectionNode = closestEndNodeWhenAddingNewNode.current;\r\n                                closestEndConnectionNode.startshapeid = newNode.name;\r\n                                flowStore.storeFlowNode(closestEndConnectionNode, closestEndConnectionNode.name);\r\n                            }\r\n                            if (closestStartNodeWhenAddingNewNode.current) {\r\n                                const closestStartConnectionNode = closestStartNodeWhenAddingNewNode.current;\r\n                                closestStartConnectionNode.endshapeid = newNode.name;\r\n                                flowStore.storeFlowNode(closestStartConnectionNode, closestStartConnectionNode.name);\r\n                            }\r\n                        }\r\n                        else {\r\n                            let closestNode = closestNodeWhenAddingNewNode.current;\r\n                            if (closestNode) {\r\n                                let connection;\r\n                                const orientationIsLeft = orientationClosestNodeWhenAddingNewNode.current;\r\n                                if (orientationIsLeft && closestNode.shapeType !== \"Diamond\") {\r\n                                    connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewConnection)(closestNode, newNode, props.getNodeInstance, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                }\r\n                                else {\r\n                                    if (nodeOrientationClosestNodeWhenAddingNewNode.current === _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default) {\r\n                                        connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewConnection)(newNode, closestNode, props.getNodeInstance, false, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                    }\r\n                                    else {\r\n                                        connection = (0,_helpers_flow_methods__WEBPACK_IMPORTED_MODULE_9__.getNewConnection)(closestNode, newNode, props.getNodeInstance, false, nodeOrientationClosestNodeWhenAddingNewNode.current);\r\n                                        if (nodeOrientationClosestNodeWhenAddingNewNode.current == _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top) {\r\n                                            connection.followflow = \"onsuccess\";\r\n                                        }\r\n                                        else {\r\n                                            connection.followflow = \"onfailure\";\r\n                                        }\r\n                                        connection.thumbPosition = nodeOrientationClosestNodeWhenAddingNewNode.current;\r\n                                    }\r\n                                }\r\n                                (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(connection.name, {\r\n                                    xstart: connection.xstart,\r\n                                    ystart: connection.ystart,\r\n                                    xend: connection.xend,\r\n                                    yend: connection.yend\r\n                                });\r\n                                (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setCommittedPosition)(connection.name, {\r\n                                    xstart: connection.xstart,\r\n                                    ystart: connection.ystart,\r\n                                    xend: connection.xend,\r\n                                    yend: connection.yend\r\n                                });\r\n                                flowStore.addConnection(connection);\r\n                            }\r\n                        }\r\n                        if (props.flowrunnerConnector.hasStorageProvider) {\r\n                            props.saveFlow();\r\n                        }\r\n                        interactionState.current = _canvas_types_interaction_state__WEBPACK_IMPORTED_MODULE_31__.InteractionState.idle;\r\n                        clearConnectionState();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                alert(\"select task!!\");\r\n            }\r\n        }\r\n    };\r\n    const addTaskToCanvas = (event, taskClassName) => {\r\n        if (lastMousePositionRef.current) {\r\n            const stageInstance = stage.current.getStage();\r\n            stageInstance.setPointersPositions(lastMousePositionRef.current);\r\n        }\r\n        let element = document.querySelector(\".taskbar__task-dragging\");\r\n        if (element) {\r\n            const rect = element.getBoundingClientRect();\r\n            if (taskClassName.indexOf(\"repo-item\") === 0) {\r\n                loadRepoItemFromModuleAndAdd(taskClassName, rect);\r\n                return;\r\n            }\r\n            if (taskClassName.indexOf(\"custom-node\") === 0) {\r\n                console.log(\"lastMousePositionRef.current\", lastMousePositionRef.current);\r\n                loadCustomNodeFromModuleAndAdd(event, taskClassName, rect);\r\n                return;\r\n            }\r\n            addTaskClassNameToCanvas(event, taskClassName, undefined, rect);\r\n        }\r\n        return false;\r\n    };\r\n    const getDistance = (node, position) => {\r\n        const x = node.x - position.x;\r\n        const y = node.y - position.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    };\r\n    const onAllowDrop = (event) => {\r\n        event.preventDefault();\r\n        movingExistingOrNewNodeOnCanvas(event.clientX, event.clientY, false);\r\n    };\r\n    const movingExistingOrNewNodeOnCanvas = (dropX, dropY, isConnectingToExistingNode, existingNode, noScale) => {\r\n        if (!!isConnectingToExistingNode && existingNode) {\r\n            const mappedNode = flowStore.flowHashmap.get(existingNode.name);\r\n            if (mappedNode.start.length > 0 && mappedNode.end.length > 0) {\r\n                console.log(\"movingExistingOrNewNodeOnCanvas mappedNode.start.length > 0 && mappedNode.end.length > 0\");\r\n                return;\r\n            }\r\n        }\r\n        if (stage && stage.current) {\r\n            let stageInstance = stage.current.getStage();\r\n            if (stageInstance) {\r\n                const scaleFactor = stageInstance.scaleX();\r\n                let position = {\r\n                    x: 0,\r\n                    y: 0\r\n                };\r\n                position.x = ((dropX - (stageInstance).x()) / scaleFactor);\r\n                position.y = ((dropY - (stageInstance).y()) / scaleFactor);\r\n                if (noScale !== undefined && !!noScale) {\r\n                    position.x = dropX;\r\n                    position.y = dropY;\r\n                }\r\n                const minDistanceForAutoConnect = 750;\r\n                let minDistance = -1;\r\n                let closestNode;\r\n                let closestStartNode;\r\n                let closestEndNode;\r\n                let orientationIsLeft = false;\r\n                let nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                closestNodeWhenAddingNewNode.current = undefined;\r\n                nodeOrientationClosestNodeWhenAddingNewNode.current = nodeOrientation;\r\n                closestNodeAreLineNodes.current = false;\r\n                closestStartNodeWhenAddingNewNode.current = undefined;\r\n                closestEndNodeWhenAddingNewNode.current = undefined;\r\n                let isInputToNode = false;\r\n                let isOutputToNode = false;\r\n                let isNodeConnection = false;\r\n                flowStore.flow.forEach((node) => {\r\n                    if (node.shapeType === 'Line') {\r\n                        if (node.startshapeid === undefined) {\r\n                            if (isConnectingToExistingNode && existingNode && node.endshapeid === existingNode.name) {\r\n                                return;\r\n                            }\r\n                            let nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                            if (!nodePosition) {\r\n                                nodePosition = {\r\n                                    xstart: node.xstart,\r\n                                    ystart: node.ystart,\r\n                                    xend: node.xend,\r\n                                    yend: node.yend\r\n                                };\r\n                            }\r\n                            let leftPosition = {\r\n                                x: nodePosition.xstart,\r\n                                y: nodePosition.ystart\r\n                            };\r\n                            const distance = getDistance(position, leftPosition);\r\n                            if (distance >= 0) {\r\n                                if (distance < (400)) {\r\n                                    closestEndNode = node;\r\n                                    closestNode = undefined;\r\n                                    orientationIsLeft = false;\r\n                                    nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                                    isOutputToNode = true;\r\n                                    isNodeConnection = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (node.endshapeid === undefined) {\r\n                            if (isConnectingToExistingNode && existingNode && node.startshapeid === existingNode.name) {\r\n                                return;\r\n                            }\r\n                            let nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                            if (!nodePosition) {\r\n                                nodePosition = {\r\n                                    xstart: node.xstart,\r\n                                    ystart: node.ystart,\r\n                                    xend: node.xend,\r\n                                    yend: node.yend\r\n                                };\r\n                            }\r\n                            let rightPosition = {\r\n                                x: nodePosition.xend,\r\n                                y: nodePosition.yend\r\n                            };\r\n                            const distance = getDistance(position, rightPosition);\r\n                            if (distance >= 0) {\r\n                                if (distance < (400)) {\r\n                                    closestStartNode = node;\r\n                                    closestNode = undefined;\r\n                                    orientationIsLeft = false;\r\n                                    nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                                    isInputToNode = true;\r\n                                    isNodeConnection = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (node.shapeType !== 'Line') {\r\n                        if (!!isConnectingToExistingNode && existingNode) {\r\n                            return;\r\n                            if (node.name === existingNode.name) {\r\n                                return;\r\n                            }\r\n                        }\r\n                        const nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                        const rightPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(node, {\r\n                            x: nodePosition.x,\r\n                            y: nodePosition.y\r\n                        }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                        const bottomPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(node, {\r\n                            x: nodePosition.x,\r\n                            y: nodePosition.y\r\n                        }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.bottom);\r\n                        const leftPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(node, {\r\n                            x: nodePosition.x,\r\n                            y: nodePosition.y\r\n                        }, undefined, props.getNodeInstance);\r\n                        const topPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(node, {\r\n                            x: nodePosition.x,\r\n                            y: nodePosition.y\r\n                        }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top);\r\n                        let distanceTop = -1;\r\n                        let distanceBottom = -1;\r\n                        if (node.shapeType === \"Diamond\") {\r\n                            const topPositionDiamond = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(node, {\r\n                                x: nodePosition.x,\r\n                                y: nodePosition.y\r\n                            }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top);\r\n                            const bottomPositionDiamond = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(node, {\r\n                                x: nodePosition.x,\r\n                                y: nodePosition.y\r\n                            }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.bottom);\r\n                            distanceTop = getDistance(position, topPositionDiamond);\r\n                            distanceBottom = getDistance(position, bottomPositionDiamond);\r\n                        }\r\n                        else {\r\n                        }\r\n                        const distanceLeft = getDistance(position, leftPosition);\r\n                        const distanceRight = getDistance(position, rightPosition);\r\n                        if (minDistance == -1 || distanceLeft < minDistance) {\r\n                            if (distanceLeft < minDistanceForAutoConnect) {\r\n                                minDistance = distanceLeft;\r\n                                closestNode = node;\r\n                                orientationIsLeft = false;\r\n                                nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                                isNodeConnection = false;\r\n                                closestStartNode = undefined;\r\n                                closestEndNode = undefined;\r\n                                if (node.shapeType === \"Diamond\") {\r\n                                    isInputToNode = true;\r\n                                    isOutputToNode = false;\r\n                                }\r\n                                else {\r\n                                    isInputToNode = true;\r\n                                    isOutputToNode = false;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (distanceTop >= 0 && (minDistance == -1 || distanceTop < minDistance)) {\r\n                            if (distanceTop < minDistanceForAutoConnect) {\r\n                                minDistance = distanceTop;\r\n                                closestNode = node;\r\n                                orientationIsLeft = false;\r\n                                nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.top;\r\n                                closestStartNode = undefined;\r\n                                closestEndNode = undefined;\r\n                                isNodeConnection = false;\r\n                                isInputToNode = false;\r\n                                isOutputToNode = true;\r\n                            }\r\n                        }\r\n                        if (distanceBottom >= 0 && (minDistance == -1 || distanceBottom < minDistance)) {\r\n                            if (distanceBottom < minDistanceForAutoConnect) {\r\n                                minDistance = distanceBottom;\r\n                                closestNode = node;\r\n                                orientationIsLeft = false;\r\n                                nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.bottom;\r\n                                closestStartNode = undefined;\r\n                                closestEndNode = undefined;\r\n                                isNodeConnection = false;\r\n                                isInputToNode = false;\r\n                                isOutputToNode = true;\r\n                            }\r\n                        }\r\n                        if (node.shapeType !== \"Diamond\") {\r\n                            if (minDistance == -1 || distanceRight < minDistance) {\r\n                                if (distanceRight < minDistanceForAutoConnect) {\r\n                                    minDistance = distanceRight;\r\n                                    closestNode = node;\r\n                                    orientationIsLeft = true;\r\n                                    nodeOrientation = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                                    closestStartNode = undefined;\r\n                                    closestEndNode = undefined;\r\n                                    isNodeConnection = false;\r\n                                    isInputToNode = false;\r\n                                    isOutputToNode = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                if (isNodeConnection) {\r\n                    closestNodeAreLineNodes.current = true;\r\n                    if (isOutputToNode && closestEndNode) {\r\n                        closestEndNodeWhenAddingNewNode.current = closestEndNode;\r\n                        const lineRef = shapeRefs.current[closestEndNode.name];\r\n                        if (lineRef) {\r\n                            const nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(closestEndNode.name);\r\n                            if (isConnectingToExistingNode && existingNode) {\r\n                                const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(existingNode.name) || existingNode;\r\n                                let newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(existingNode, {\r\n                                    x: positionNode.x,\r\n                                    y: positionNode.y\r\n                                }, closestEndNode, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                position.x = newStartPosition.x;\r\n                                position.y = newStartPosition.y;\r\n                            }\r\n                            else {\r\n                                position.x += 100;\r\n                            }\r\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(position.x, position.y, nodePosition.xend, nodePosition.yend, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [\r\n                                    position.x, position.y,\r\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                    nodePosition.xend, nodePosition.yend,\r\n                                ] });\r\n                            const thumbRef = shapeRefs.current[\"thumbstart_line_\" + closestEndNode.name];\r\n                            if (thumbRef) {\r\n                                thumbRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, position);\r\n                            }\r\n                            const thumbEndRef = shapeRefs.current[\"thumb_line_\" + closestEndNode.name];\r\n                            if (thumbEndRef) {\r\n                                thumbEndRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, {\r\n                                    x: nodePosition.xend,\r\n                                    y: nodePosition.yend\r\n                                });\r\n                            }\r\n                            const connectionForDraggingRef = shapeRefs.current[connectionForDraggingName];\r\n                            if (connectionForDraggingRef) {\r\n                                connectionForDraggingRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                            }\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                    }\r\n                    if (isInputToNode && closestStartNode) {\r\n                        closestStartNodeWhenAddingNewNode.current = closestStartNode;\r\n                        const lineRef = shapeRefs.current[closestStartNode.name];\r\n                        if (lineRef) {\r\n                            const nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(closestStartNode.name);\r\n                            if (isConnectingToExistingNode && existingNode) {\r\n                                const positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(existingNode.name) || existingNode;\r\n                                let newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(existingNode, {\r\n                                    x: positionNode.x,\r\n                                    y: positionNode.y\r\n                                }, closestStartNode, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                position.x = newEndPosition.x;\r\n                                position.y = newEndPosition.y;\r\n                            }\r\n                            else {\r\n                                position.x -= 200;\r\n                            }\r\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(nodePosition.xstart, nodePosition.ystart, position.x, position.y, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [\r\n                                    nodePosition.xstart, nodePosition.ystart,\r\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                    position.x, position.y,\r\n                                ] });\r\n                            const thumbRef = shapeRefs.current[\"thumbstart_line_\" + closestStartNode.name];\r\n                            if (thumbRef) {\r\n                                thumbRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, {\r\n                                    x: nodePosition.xend,\r\n                                    y: nodePosition.yend\r\n                                });\r\n                            }\r\n                            const thumbEndRef = shapeRefs.current[\"thumb_line_\" + closestStartNode.name];\r\n                            if (thumbEndRef) {\r\n                                thumbEndRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetXY, position);\r\n                            }\r\n                            const connectionForDraggingRef = shapeRefs.current[connectionForDraggingName];\r\n                            if (connectionForDraggingRef) {\r\n                                connectionForDraggingRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                            }\r\n                            stageInstance.batchDraw();\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n                else if (!isNodeConnection && closestNode) {\r\n                    closestNodeAreLineNodes.current = false;\r\n                    const settings = _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_6__.ShapeSettings.getShapeSettings(closestNode.taskType, closestNode);\r\n                    if (!isNodeConnection && isInputToNode) {\r\n                        const allowedInputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedInputs(closestNode.shapeType, settings);\r\n                        const canHaveInputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveInputs(closestNode.shapeType, settings, flowStore.flow, closestNode, flowStore.flowHashmap);\r\n                        if (allowedInputs === 0 || !canHaveInputs) {\r\n                            const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                            if (lineRef) {\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                                stageInstance.batchDraw();\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    if (!isNodeConnection && isOutputToNode) {\r\n                        const allowedOutputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getAllowedOutputs(closestNode.shapeType, settings);\r\n                        const canHaveOutputs = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.canHaveOutputs(closestNode.shapeType, settings, flowStore.flow, closestNode, flowStore.flowHashmap);\r\n                        if (allowedOutputs === 0 || !canHaveOutputs) {\r\n                            const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                            if (lineRef) {\r\n                                lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                                stageInstance.batchDraw();\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    closestNodeWhenAddingNewNode.current = closestNode;\r\n                    orientationClosestNodeWhenAddingNewNode.current = orientationIsLeft;\r\n                    nodeOrientationClosestNodeWhenAddingNewNode.current = nodeOrientation;\r\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                    if (!isNodeConnection && lineRef) {\r\n                        let thumbPosition = _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default;\r\n                        let lineStartPosition;\r\n                        const nodePosition = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(closestNode.name);\r\n                        if (closestNode.shapeType === \"Diamond\" && nodeOrientation !== _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default) {\r\n                            lineStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(closestNode, {\r\n                                x: nodePosition.x,\r\n                                y: nodePosition.y\r\n                            }, undefined, props.getNodeInstance, nodeOrientation);\r\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(lineStartPosition.x, lineStartPosition.y, position.x, position.y, nodeOrientation);\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [lineStartPosition.x, lineStartPosition.y,\r\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                    position.x, position.y] });\r\n                        }\r\n                        else if (orientationIsLeft) {\r\n                            lineStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getStartPointForLine(closestNode, {\r\n                                x: nodePosition.x,\r\n                                y: nodePosition.y\r\n                            }, undefined, props.getNodeInstance, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(lineStartPosition.x, lineStartPosition.y, position.x, position.y, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [lineStartPosition.x, lineStartPosition.y,\r\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                    position.x, position.y] });\r\n                        }\r\n                        else {\r\n                            lineStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(closestNode, {\r\n                                x: nodePosition.x,\r\n                                y: nodePosition.y\r\n                            }, undefined, props.getNodeInstance);\r\n                            let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_12__.calculateLineControlPoints)(position.x, position.y, lineStartPosition.x, lineStartPosition.y, _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                            lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetPoints, { points: [position.x, position.y,\r\n                                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                                    lineStartPosition.x, lineStartPosition.y] });\r\n                        }\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 1 });\r\n                        stageInstance.batchDraw();\r\n                    }\r\n                }\r\n                else {\r\n                    const lineRef = shapeRefs.current[connectionForDraggingName];\r\n                    if (lineRef) {\r\n                        lineRef.modifyShape(_shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ModifyShapeEnum.SetOpacity, { opacity: 0 });\r\n                        stageInstance.batchDraw();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const onInput = (event) => {\r\n        if (event.target && (event.target.tagName || \"\").toLowerCase() == \"input\") {\r\n            return;\r\n        }\r\n        if (event.target && (event.target.tagName || \"\").toLowerCase() == \"textarea\") {\r\n            return;\r\n        }\r\n        if (event.target && event.target.attributes && event.target.attributes[\"role\"]\r\n            && event.target.attributes[\"role\"].value == \"textbox\") {\r\n            return;\r\n        }\r\n        if (event.keyCode == fKey || event.keyCode == fKeyCapt) {\r\n            if (selectedNodeRef.current) {\r\n                event.preventDefault();\r\n                fitStage(undefined, false, false, true);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        if (event.keyCode == shiftKey) {\r\n            shiftDown.current = true;\r\n            return true;\r\n        }\r\n        if (event.keyCode == ctrlKey || event.keyCode == cmdKey) {\r\n            ctrlDown.current = true;\r\n            return true;\r\n        }\r\n        if (!!ctrlDown.current && event.keyCode == pasteKey) {\r\n            return true;\r\n        }\r\n    };\r\n    const onKeyUp = (event) => {\r\n        ctrlDown.current = false;\r\n        shiftDown.current = false;\r\n    };\r\n    const onStoreFlowNode = (node, orgNodeName) => {\r\n        flowStore.storeFlowNode(node, orgNodeName);\r\n    };\r\n    const handleDragStart = (event) => {\r\n        setActiveId(event.active.id);\r\n    };\r\n    const handleDragEnd = (event) => {\r\n        console.log(\"event\", event);\r\n        if (activeId) {\r\n            addTaskToCanvas(event, activeId);\r\n        }\r\n        setActiveId(undefined);\r\n    };\r\n    const handleDragMove = (event) => {\r\n        if ((activeId === null || activeId === void 0 ? void 0 : activeId.indexOf(\"repo-item\")) == 0) {\r\n            return \"\";\r\n        }\r\n        if ((activeId === null || activeId === void 0 ? void 0 : activeId.indexOf(\"custom-node\")) == 0) {\r\n            return \"\";\r\n        }\r\n        let element = document.querySelector(\".taskbar__task-dragging\");\r\n        if (element) {\r\n            let rect = element.getBoundingClientRect();\r\n            movingExistingOrNewNodeOnCanvas(Math.round((rect.left + rect.right) / 2), Math.round((rect.top + rect.bottom) / 2), false);\r\n        }\r\n    };\r\n    const canvasHasSelectedNode = !!selectedNodeRef.current;\r\n    const connections = canvasMode.showDependencies ? getDependentConnections() : [];\r\n    let nodesConnectedToSelectedNode = {};\r\n    const flowMemo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\r\n        return flowStore.flow;\r\n    }, [flowStore.flow]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_dnd_kit_core__WEBPACK_IMPORTED_MODULE_7__.DndContext, { id: \"canvas-dndcontext\", modifiers: [_dnd_kit_modifiers__WEBPACK_IMPORTED_MODULE_27__.restrictToWindowEdges], onDragStart: handleDragStart, onDragMove: handleDragMove, onDragEnd: handleDragEnd },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_taskbar__WEBPACK_IMPORTED_MODULE_26__.Taskbar, { flowrunnerConnector: props.flowrunnerConnector, isDragging: activeId !== undefined, hasCustomNodesAndRepository: props.hasCustomNodesAndRepository }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_dnd_kit_core__WEBPACK_IMPORTED_MODULE_7__.DragOverlay, { className: \"taskbar__task-dragging\", zIndex: 20000, dropAnimation: null }, activeId ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(_dragging_task__WEBPACK_IMPORTED_MODULE_8__.DragginTask, { id: activeId, style: {}, children: {}, listeners: {} }) : null),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"stage-layer-wrapper-\" + canvasKey, ref: ref => (canvasWrapper.current = ref), style: { opacity: canvasOpacity }, className: \"canvas-controller__scroll-container\", tabIndex: 0, onInput: onInput, onKeyDown: onInput, onKeyUp: onKeyUp, onWheel: wheelEvent, onMouseLeave: onStageMouseLeave },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_helpers_error__WEBPACK_IMPORTED_MODULE_28__.ErrorBoundary, null,\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: setNodeRef, style: droppableStyle },\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Stage, { onClick: clickStage, draggable: true, pixelRatio: 1, width: stageWidth, height: stageHeight, ref: ref => (stage.current = ref), onDragMove: onDragStageMove, onDragEnd: onDragStageEnd, onMouseDown: onStageTouchStart, onTouchStart: onStageTouchStart, onTouchMove: onStageTouchMove, onMouseMove: onStageTouchMove, onTouchEnd: onStageMouseEnd, onMouseUp: onStageMouseEnd, onTap: clickStage, className: \"stage-container\" },\r\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Layer, { key: \"stage-layer-\" + canvasKey, ref: ref => (layer.current = ref) },\r\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { ref: ref => (stageGroup.current = ref) },\r\n                                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect, { x: 0, y: 0, width: 1024, height: 750 }),\r\n                                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect, { x: 0, y: 0, width: 0, height: 0, listening: false, stroke: \"#202020\", hitStrokeWidth: 0, strokeWidth: 4, dash: [5, 10], opacity: 0, ref: ref => (selectingRectRef.current = ref) }),\r\n                                    connections.length > 0 && connections.map((node, index) => {\r\n                                        if (canvasHasSelectedNode && selectedNodeRef.current) {\r\n                                            if (node.startshapeid === selectedNodeRef.current.name) {\r\n                                                nodesConnectedToSelectedNode[node.endshapeid] = true;\r\n                                            }\r\n                                            if (node.endshapeid === selectedNodeRef.current.name) {\r\n                                                nodesConnectedToSelectedNode[node.startshapeid] = true;\r\n                                            }\r\n                                        }\r\n                                        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes.Line, { key: \"cn-node-\" + index, onMouseOver: (event) => onMouseOver(node, event), onMouseOut: (event) => onMouseOut(), onMouseStart: undefined, onMouseMove: undefined, onMouseEnd: undefined, onClickLine: (event) => onClickLine(node, event), isSelected: false, isAltColor: true, canvasHasSelectedNode: canvasHasSelectedNode, isConnectionWithVariable: node.isConnectionWithVariable, isConnectionWithFunction: node.isConnectionWithFunction, xstart: node.xstart, ystart: node.ystart, xend: node.xend, yend: node.yend, selectedNodeName: canvasHasSelectedNode ? selectedNodeRef.current.name : \"\", startNodeName: node.startshapeid, endNodeName: node.endshapeid, noMouseEvents: true });\r\n                                    }),\r\n                                    flowMemo.map((node, index) => {\r\n                                        if (node.shapeType !== \"Line\") {\r\n                                            let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                                            if (!position) {\r\n                                                if (node.shapeType !== \"Line\") {\r\n                                                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                                                        x: node.x,\r\n                                                        y: node.y\r\n                                                    });\r\n                                                }\r\n                                                else {\r\n                                                    (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                                                        xstart: node.xstart,\r\n                                                        ystart: node.ystart,\r\n                                                        xend: node.xend,\r\n                                                        yend: node.yend\r\n                                                    });\r\n                                                }\r\n                                                position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                                            }\r\n                                            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes_lines_for_shape__WEBPACK_IMPORTED_MODULE_3__.LinesForShape, { key: \"node-linshahe-\" + index, x: position.x, y: position.y, name: node.name, flow: flowMemo, taskType: node.taskType, node: node, flowHash: flowStore.flowHashmap, shapeRefs: shapeRefs, positions: _services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition, canvasHasSelectedNode: canvasHasSelectedNode, nodeState: \"\", selectedNode: selectedNodeRef.current, onLineMouseOver: onMouseOver, onLineMouseOut: onMouseOut, onClickLine: onClickLine, onClickSetup: undefined, onMouseOver: (event) => onMouseOver(node, event), onMouseOut: onMouseOut, onDragStart: (event) => onDragStart(node, event), onDragEnd: (event) => onDragEnd(node, event), onDragMove: (event) => onDragMove(node, event), onTouchStart: (event) => onTouchStart(node, event), onTouchEnd: (event) => onTouchEnd(node, event), onTouchMove: (event) => onTouchMove(node, event), onClickShape: (event) => onClickShape(node, event), onMouseStart: onMouseStart, onMouseMove: onMouseMove, onMouseEnd: onMouseEnd, onMouseLeave: (event) => onMouseLeave(node, event), isSelected: selectedNodeRef.current.name === node.name, isConnectedToSelectedNode: false, getNodeInstance: props.getNodeInstance, touchedNodes: touchedNodesStore.nodesTouched, onMouseConnectionStartOver: onMouseConnectionStartOver, onMouseConnectionStartOut: onMouseConnectionStartOut, onMouseConnectionStartStart: onMouseConnectionStartStart, onMouseConnectionStartMove: onMouseConnectionStartMove, onMouseConnectionStartEnd: onMouseConnectionStartEnd, onMouseConnectionEndOver: onMouseConnectionEndOver, onMouseConnectionEndOut: onMouseConnectionEndOut, onMouseConnectionEndStart: onMouseConnectionEndStart, onMouseConnectionEndMove: onMouseConnectionEndMove, onMouseConnectionEndEnd: onMouseConnectionEndEnd, onMouseConnectionEndLeave: onMouseConnectionEndLeave });\r\n                                        }\r\n                                        else {\r\n                                            if (node.shapeType === \"Line\") {\r\n                                                if (node.startshapeid === undefined) {\r\n                                                    let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                                                    if (!position) {\r\n                                                        (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.setPosition)(node.name, {\r\n                                                            xstart: node.xstart,\r\n                                                            ystart: node.ystart,\r\n                                                            xend: node.xend,\r\n                                                            yend: node.yend\r\n                                                        });\r\n                                                        position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.name);\r\n                                                    }\r\n                                                    if (node.endshapeid !== undefined) {\r\n                                                        const endIndex = flowStore.flowHashmap.get(node.endshapeid).index;\r\n                                                        if (endIndex >= 0) {\r\n                                                            const endNode = flowMemo[endIndex];\r\n                                                            if (endNode) {\r\n                                                                let positionNode = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_17__.getPosition)(node.endshapeid) || endNode;\r\n                                                                let newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_4__.FlowToCanvas.getEndPointForLine(endNode, {\r\n                                                                    x: positionNode.x,\r\n                                                                    y: positionNode.y\r\n                                                                }, endNode, props.getNodeInstance, node.thumbEndPosition || _shapes_shape_types__WEBPACK_IMPORTED_MODULE_22__.ThumbPositionRelativeToNode.default);\r\n                                                                position.xend = newEndPosition.x;\r\n                                                                position.yend = newEndPosition.y;\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes.Line, { key: \"ln-node-\" + index, ref: ref => (shapeRefs.current[node.name] = ref), onMouseOver: (event) => onMouseOver(node, event), onMouseOut: onMouseOut, onClickLine: (event) => onClickLine(node, event), isSelected: false, isAltColor: true, canvasHasSelectedNode: canvasHasSelectedNode, xstart: position.xstart, ystart: position.ystart, xend: position.xend, yend: position.yend, selectedNodeName: canvasHasSelectedNode ? selectedNodeRef.current.name : \"\", startNodeName: node.startshapeid, endNodeName: node.endshapeid, noMouseEvents: false, lineNode: node, shapeRefs: shapeRefs.current, getNodeInstance: props.getNodeInstance, hasStartThumb: true, onMouseStart: onMouseStart, onMouseMove: onMouseMove, onMouseEnd: onMouseEnd, hasEndThumb: node.endshapeid === undefined, onMouseConnectionStartOver: onMouseConnectionStartOver, onMouseConnectionStartOut: onMouseConnectionStartOut, onMouseConnectionStartStart: onMouseConnectionStartStart, onMouseConnectionStartMove: onMouseConnectionStartMove, onMouseConnectionStartEnd: onMouseConnectionStartEnd, onMouseConnectionEndOver: onMouseConnectionEndOver, onMouseConnectionEndOut: onMouseConnectionEndOut, onMouseConnectionEndStart: onMouseConnectionEndStart, onMouseConnectionEndMove: onMouseConnectionEndMove, onMouseConnectionEndEnd: onMouseConnectionEndEnd, onMouseConnectionEndLeave: onMouseConnectionEndLeave });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        return null;\r\n                                    }),\r\n                                    flowMemo.map((node, index) => {\r\n                                        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_canvas_components_konva_node__WEBPACK_IMPORTED_MODULE_16__.KonvaNode, { key: \"konva_\" + node.name + props.flowId, node: node, hasTaskNameAsNodeTitle: props.hasTaskNameAsNodeTitle, flowrunnerConnector: props.flowrunnerConnector, nodesStateLocal: nodesStateLocal.current[node.name] || \"\", getNodeInstance: props.getNodeInstance, onCloneNode: onCloneNode, canvasHasSelectedNode: canvasHasSelectedNode, onFocus: _html_plugins_form_controls_helpers_focus__WEBPACK_IMPORTED_MODULE_23__.onFocus, onShowNodeSettings: onShowNodeSettings, renderHtmlNode: props.renderHtmlNode, flowId: props.flowId, flowMemo: flowMemo, nodesConnectedToSelectedNode: nodesConnectedToSelectedNode, shapeRefs: shapeRefs, onMouseStart: onMouseStart, onMouseOver: onMouseOver, onMouseOut: onMouseOut, onClickLine: onClickLine, onClickSetup: onClickSetup, onClickShape: onClickShape, onDragStart: onDragStart, onDragEnd: onDragEnd, onDragMove: onDragMove, onTouchStart: onTouchStart, onMouseEnd: onMouseEnd, onMouseMove: onMouseMove, onMouseLeave: onMouseLeave, onMouseConnectionStartOver: onMouseConnectionStartOver, onMouseConnectionStartOut: onMouseConnectionStartOut, onMouseConnectionStartStart: onMouseConnectionStartStart, onMouseConnectionStartMove: onMouseConnectionStartMove, onMouseConnectionStartEnd: onMouseConnectionStartEnd, onMouseConnectionEndOver: onMouseConnectionEndOver, onMouseConnectionEndOut: onMouseConnectionEndOut, onMouseConnectionEndStart: onMouseConnectionEndStart, onMouseConnectionEndMove: onMouseConnectionEndMove, onMouseConnectionEndEnd: onMouseConnectionEndEnd, onMouseConnectionEndLeave: onMouseConnectionEndLeave });\r\n                                    }),\r\n                                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shapes__WEBPACK_IMPORTED_MODULE_2__.Shapes.Line, { ref: ref => (shapeRefs.current[connectionForDraggingName] = ref), onMouseOver: undefined, onMouseOut: undefined, onClickLine: undefined, isSelected: false, isAltColor: true, canvasHasSelectedNode: canvasHasSelectedNode, isConnectionWithVariable: false, xstart: connectionX, ystart: connectionY, xend: connectionX, yend: connectionY, selectedNodeName: \"\", startNodeName: \"\", endNodeName: \"\", opacity: 0, noMouseEvents: true, onMouseStart: undefined, onMouseMove: undefined, onMouseEnd: undefined, isNodeConnectorHelper: true })))))),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: ref => (htmlWrapper.current = ref), key: \"html_wrapper_\" + props.flowId, style: { transform: \"translate(\" + (stageX) + \"px,\" + (stageY) + \"px) \" +\r\n                            \"scale(\" + (stageScale) + \",\" + (stageScale) + \") \" }, className: \"canvas__html-elements\", onMouseMove: onStageTouchMove, onMouseUp: onStageMouseEnd }, flowMemo.map((node, index) => {\r\n                    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_canvas_components_html_node__WEBPACK_IMPORTED_MODULE_15__.HtmlNode, { key: \"html_\" + node.name + flowStore.flowId, ref: ref => (elementRefs.current[node.name] = ref), hasTaskNameAsNodeTitle: props.hasTaskNameAsNodeTitle, node: node, flowrunnerConnector: props.flowrunnerConnector, nodesStateLocal: nodesStateLocal.current[node.name] || \"\", getNodeInstance: props.getNodeInstance, onCloneNode: onCloneNode, canvasHasSelectedNode: canvasHasSelectedNode, onFocus: _html_plugins_form_controls_helpers_focus__WEBPACK_IMPORTED_MODULE_23__.onFocus, onShowNodeSettings: onShowNodeSettings, onShowNodeEditor: onShowNodeEditor, renderHtmlNode: props.renderHtmlNode, flowId: flowStore.flowId, flowMemo: flowMemo, formNodesubject: props.formNodesubject, onMouseStart: onMouseStart, onMouseOver: onMouseOver, onMouseOut: onMouseOut, onClickShape: onClickShape, onTouchStart: onTouchStart, onMouseEnd: onMouseEnd, onMouseMove: onMouseMove, onMouseLeave: onMouseLeave, onMouseConnectionStartOver: onMouseConnectionStartOver, onMouseConnectionStartOut: onMouseConnectionStartOut, onMouseConnectionStartStart: onMouseConnectionStartStart, onMouseConnectionStartMove: onMouseConnectionStartMove, onMouseConnectionStartEnd: onMouseConnectionStartEnd, onMouseConnectionEndOver: onMouseConnectionEndOver, onMouseConnectionEndOut: onMouseConnectionEndOut, onMouseConnectionEndStart: onMouseConnectionEndStart, onMouseConnectionEndMove: onMouseConnectionEndMove, onMouseConnectionEndEnd: onMouseConnectionEndEnd, onMouseConnectionEndLeave: onMouseConnectionEndLeave });\r\n                })))),\r\n        showNodeSettings && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_edit_node_settings__WEBPACK_IMPORTED_MODULE_13__.EditNodeSettings, { modalSize: props.modalSize, hasTaskNameAsNodeTitle: props.hasTaskNameAsNodeTitle, node: editNode, settings: editNodeSettings, flowrunnerConnector: props.flowrunnerConnector, onClose: onCloseEditNodeSettings }),\r\n        showNodeEdit && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_edit_node__WEBPACK_IMPORTED_MODULE_14__.EditNodePopup, { node: editNode, modalSize: props.modalSize, hasTaskNameAsNodeTitle: props.hasTaskNameAsNodeTitle, formNodesubject: props.formNodesubject, settings: editNodeSettings, flowrunnerConnector: props.flowrunnerConnector, onClose: onCloseEditNode }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_flow__WEBPACK_IMPORTED_MODULE_11__.Flow, { flow: flowStore.flow, flowId: flowStore.flowId, flowrunnerConnector: props.flowrunnerConnector }));\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/index.tsx?");

/***/ }),

/***/ "./src/components/canvas/konva/Tween.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tween\": () => (/* binding */ Tween),\n/* harmony export */   \"animateTo\": () => (/* binding */ animateTo),\n/* harmony export */   \"Easings\": () => (/* binding */ Easings)\n/* harmony export */ });\n/* harmony import */ var konva__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/konva/lib/index.js\");\n\r\nvar blacklist = {\r\n    node: 1,\r\n    duration: 1,\r\n    easing: 1,\r\n    onFinish: 1,\r\n    yoyo: 1,\r\n    onUpdate: 1,\r\n}, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter = 0, colorAttrs = ['fill', 'stroke', 'shadowColor'];\r\nclass TweenEngine {\r\n    constructor(prop, propFunc, func, begin, finish, duration, yoyo) {\r\n        this.prop = prop;\r\n        this.propFunc = propFunc;\r\n        this.begin = begin;\r\n        this._pos = begin;\r\n        this.duration = duration;\r\n        this._change = 0;\r\n        this.prevPos = 0;\r\n        this.yoyo = yoyo;\r\n        this._time = 0;\r\n        this._position = 0;\r\n        this._startTime = 0;\r\n        this._finish = 0;\r\n        this.func = func;\r\n        this._change = finish - this.begin;\r\n        this.state = 0;\r\n        this.pause();\r\n    }\r\n    fire(str) {\r\n        var handler = this[str];\r\n        if (handler) {\r\n            handler();\r\n        }\r\n    }\r\n    setTime(t) {\r\n        if (t > this.duration) {\r\n            if (this.yoyo) {\r\n                this._time = this.duration;\r\n                this.reverse();\r\n            }\r\n            else {\r\n                this.finish();\r\n            }\r\n        }\r\n        else if (t < 0) {\r\n            if (this.yoyo) {\r\n                this._time = 0;\r\n                this.play();\r\n            }\r\n            else {\r\n                this.reset();\r\n            }\r\n        }\r\n        else {\r\n            this._time = Math.floor(t);\r\n            this.update();\r\n        }\r\n    }\r\n    getTime() {\r\n        return this._time;\r\n    }\r\n    setPosition(p) {\r\n        this.prevPos = this._pos;\r\n        this.propFunc(p);\r\n        this._pos = p;\r\n    }\r\n    getPosition(t) {\r\n        if (t === undefined) {\r\n            t = this._time;\r\n        }\r\n        return this.func(t, this.begin, this._change, this.duration);\r\n    }\r\n    play() {\r\n        this.state = PLAYING;\r\n        this._startTime = this.getTimer() - this._time;\r\n        this.onEnterFrame(0);\r\n        this.fire('onPlay');\r\n    }\r\n    reverse() {\r\n        this.state = REVERSING;\r\n        this._time = this.duration - this._time;\r\n        this._startTime = this.getTimer() - this._time;\r\n        this.fire('onReverse');\r\n    }\r\n    seek(t) {\r\n        this.pause();\r\n        this._time = t;\r\n        this.update();\r\n        this.fire('onSeek');\r\n    }\r\n    reset() {\r\n        this.pause();\r\n        this._time = 0;\r\n        this.update();\r\n        this.fire('onReset');\r\n    }\r\n    finish() {\r\n        this.pause();\r\n        this._time = this.duration;\r\n        this.update();\r\n        this.fire('onFinish');\r\n    }\r\n    update() {\r\n        this.setPosition(this.getPosition(this._time));\r\n        this.fire('onUpdate');\r\n    }\r\n    onEnterFrame(frame) {\r\n        let t = frame ? frame.time : this.getTimer() - this._startTime;\r\n        if (this.state === PLAYING) {\r\n            this.setTime(t);\r\n        }\r\n        else if (this.state === REVERSING) {\r\n            this.setTime(this.duration - t);\r\n        }\r\n    }\r\n    pause() {\r\n        this.state = PAUSED;\r\n        this.fire('onPause');\r\n    }\r\n    getTimer() {\r\n        return performance.now();\r\n    }\r\n}\r\nclass Tween {\r\n    constructor(config) {\r\n        let that = this, node = config.node, nodeId = node._id, duration, easing = config.easing || Easings.Linear, yoyo = !!config.yoyo, key;\r\n        if (typeof config.duration === 'undefined') {\r\n            duration = 0.3;\r\n        }\r\n        else if (config.duration === 0) {\r\n            duration = 0.001;\r\n        }\r\n        else {\r\n            duration = config.duration;\r\n        }\r\n        this.node = node;\r\n        this._id = idCounter++;\r\n        var layers = node.getLayers();\r\n        if (!layers) {\r\n            konva__WEBPACK_IMPORTED_MODULE_0__.default.Util.error('Tween constructor have `node` that is not in a layer. Please add node into layer first.');\r\n        }\r\n        this.anim = new konva__WEBPACK_IMPORTED_MODULE_0__.default.Animation(function (frame) {\r\n            that.tween.onEnterFrame(frame);\r\n            return false;\r\n        }, layers);\r\n        this.tween = new TweenEngine(key, function (i) {\r\n            that._tweenFunc(i);\r\n        }, easing, 0, 1, duration * 1000, yoyo);\r\n        this._addListeners();\r\n        if (!Tween.attrs[nodeId]) {\r\n            Tween.attrs[nodeId] = {};\r\n        }\r\n        if (!Tween.attrs[nodeId][this._id]) {\r\n            Tween.attrs[nodeId][this._id] = {};\r\n        }\r\n        if (!Tween.tweens[nodeId]) {\r\n            Tween.tweens[nodeId] = {};\r\n        }\r\n        for (key in config) {\r\n            if (blacklist[key] === undefined) {\r\n                this._addAttr(key, config[key]);\r\n            }\r\n        }\r\n        this.reset();\r\n        this.onFinish = config.onFinish;\r\n        this.onReset = config.onReset;\r\n        this.onUpdate = config.onUpdate;\r\n    }\r\n    _addAttr(key, end) {\r\n        let node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;\r\n        tweenId = Tween.tweens[nodeId][key];\r\n        if (tweenId) {\r\n            delete Tween.attrs[nodeId][tweenId][key];\r\n        }\r\n        start = node.getAttr(key);\r\n        if (konva__WEBPACK_IMPORTED_MODULE_0__.default.Util._isArray(end)) {\r\n            diff = [];\r\n            len = Math.max(end.length, start.length);\r\n            if (key === 'points' && end.length !== start.length) {\r\n                if (end.length > start.length) {\r\n                    trueStart = start;\r\n                    start = konva__WEBPACK_IMPORTED_MODULE_0__.default.Util._prepareArrayForTween(start, end, node.closed());\r\n                }\r\n                else {\r\n                    trueEnd = end;\r\n                    end = konva__WEBPACK_IMPORTED_MODULE_0__.default.Util._prepareArrayForTween(end, start, node.closed());\r\n                }\r\n            }\r\n            if (key.indexOf('fill') === 0) {\r\n                for (n = 0; n < len; n++) {\r\n                    if (n % 2 === 0) {\r\n                        diff.push(end[n] - start[n]);\r\n                    }\r\n                    else {\r\n                        var startRGBA = konva__WEBPACK_IMPORTED_MODULE_0__.default.Util.colorToRGBA(start[n]);\r\n                        endRGBA = konva__WEBPACK_IMPORTED_MODULE_0__.default.Util.colorToRGBA(end[n]);\r\n                        start[n] = startRGBA;\r\n                        diff.push({\r\n                            r: endRGBA.r - startRGBA.r,\r\n                            g: endRGBA.g - startRGBA.g,\r\n                            b: endRGBA.b - startRGBA.b,\r\n                            a: endRGBA.a - startRGBA.a,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (n = 0; n < len; n++) {\r\n                    diff.push(end[n] - start[n]);\r\n                }\r\n            }\r\n        }\r\n        else if (colorAttrs.indexOf(key) !== -1) {\r\n            start = konva__WEBPACK_IMPORTED_MODULE_0__.default.Util.colorToRGBA(start);\r\n            endRGBA = konva__WEBPACK_IMPORTED_MODULE_0__.default.Util.colorToRGBA(end);\r\n            diff = {\r\n                r: endRGBA.r - start.r,\r\n                g: endRGBA.g - start.g,\r\n                b: endRGBA.b - start.b,\r\n                a: endRGBA.a - start.a,\r\n            };\r\n        }\r\n        else {\r\n            diff = end - start;\r\n        }\r\n        Tween.attrs[nodeId][this._id][key] = {\r\n            start: start,\r\n            diff: diff,\r\n            end: end,\r\n            trueEnd: trueEnd,\r\n            trueStart: trueStart,\r\n        };\r\n        Tween.tweens[nodeId][key] = this._id;\r\n    }\r\n    _tweenFunc(i) {\r\n        var node = this.node, attrs = Tween.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;\r\n        for (key in attrs) {\r\n            attr = attrs[key];\r\n            start = attr.start;\r\n            diff = attr.diff;\r\n            end = attr.end;\r\n            if (konva__WEBPACK_IMPORTED_MODULE_0__.default.Util._isArray(start)) {\r\n                newVal = [];\r\n                len = Math.max(start.length, end.length);\r\n                if (key.indexOf('fill') === 0) {\r\n                    for (n = 0; n < len; n++) {\r\n                        if (n % 2 === 0) {\r\n                            newVal.push((start[n] || 0) + diff[n] * i);\r\n                        }\r\n                        else {\r\n                            newVal.push('rgba(' +\r\n                                Math.round(start[n].r + diff[n].r * i) +\r\n                                ',' +\r\n                                Math.round(start[n].g + diff[n].g * i) +\r\n                                ',' +\r\n                                Math.round(start[n].b + diff[n].b * i) +\r\n                                ',' +\r\n                                (start[n].a + diff[n].a * i) +\r\n                                ')');\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (n = 0; n < len; n++) {\r\n                        newVal.push((start[n] || 0) + diff[n] * i);\r\n                    }\r\n                }\r\n            }\r\n            else if (colorAttrs.indexOf(key) !== -1) {\r\n                newVal =\r\n                    'rgba(' +\r\n                        Math.round(start.r + diff.r * i) +\r\n                        ',' +\r\n                        Math.round(start.g + diff.g * i) +\r\n                        ',' +\r\n                        Math.round(start.b + diff.b * i) +\r\n                        ',' +\r\n                        (start.a + diff.a * i) +\r\n                        ')';\r\n            }\r\n            else {\r\n                newVal = start + diff * i;\r\n            }\r\n            node.setAttr(key, newVal);\r\n        }\r\n    }\r\n    _addListeners() {\r\n        this.tween.onPlay = () => {\r\n            this.anim.start();\r\n        };\r\n        this.tween.onReverse = () => {\r\n            this.anim.start();\r\n        };\r\n        this.tween.onPause = () => {\r\n            this.anim.stop();\r\n        };\r\n        this.tween.onFinish = () => {\r\n            var node = this.node;\r\n            var attrs = Tween.attrs[node._id][this._id];\r\n            if (attrs.points && attrs.points.trueEnd) {\r\n                node.setAttr('points', attrs.points.trueEnd);\r\n            }\r\n            if (this.onFinish) {\r\n                this.onFinish.call(this);\r\n            }\r\n        };\r\n        this.tween.onReset = () => {\r\n            var node = this.node;\r\n            var attrs = Tween.attrs[node._id][this._id];\r\n            if (attrs.points && attrs.points.trueStart) {\r\n                node.points(attrs.points.trueStart);\r\n            }\r\n            if (this.onReset) {\r\n                this.onReset();\r\n            }\r\n        };\r\n        this.tween.onUpdate = () => {\r\n            if (this.onUpdate) {\r\n                this.onUpdate.call(this);\r\n            }\r\n        };\r\n    }\r\n    play() {\r\n        this.tween.play();\r\n        return this;\r\n    }\r\n    reverse() {\r\n        this.tween.reverse();\r\n        return this;\r\n    }\r\n    reset() {\r\n        this.tween.reset();\r\n        return this;\r\n    }\r\n    seek(t) {\r\n        this.tween.seek(t * 1000);\r\n        return this;\r\n    }\r\n    pause() {\r\n        this.tween.pause();\r\n        return this;\r\n    }\r\n    finish() {\r\n        this.tween.finish();\r\n        return this;\r\n    }\r\n    destroy() {\r\n        var nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId], key;\r\n        this.pause();\r\n        for (key in attrs) {\r\n            delete Tween.tweens[nodeId][key];\r\n        }\r\n        delete Tween.attrs[nodeId][thisId];\r\n    }\r\n}\r\nTween.attrs = {};\r\nTween.tweens = {};\r\nconst animateTo = function (node, params) {\r\n    var onFinish = params.onFinish;\r\n    params.node = node;\r\n    params.onFinish = function () {\r\n        this.destroy();\r\n        if (onFinish) {\r\n            onFinish();\r\n        }\r\n    };\r\n    var tween = new Tween(params);\r\n    tween.play();\r\n    return tween;\r\n};\r\nconst Easings = {\r\n    BackEaseIn(t, b, c, d) {\r\n        var s = 1.70158;\r\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\r\n    },\r\n    BackEaseOut(t, b, c, d) {\r\n        var s = 1.70158;\r\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\r\n    },\r\n    BackEaseInOut(t, b, c, d) {\r\n        var s = 1.70158;\r\n        if ((t /= d / 2) < 1) {\r\n            return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\r\n        }\r\n        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\r\n    },\r\n    ElasticEaseIn(t, b, c, d, a, p) {\r\n        var s = 0;\r\n        if (t === 0) {\r\n            return b;\r\n        }\r\n        if ((t /= d) === 1) {\r\n            return b + c;\r\n        }\r\n        if (!p) {\r\n            p = d * 0.3;\r\n        }\r\n        if (!a || a < Math.abs(c)) {\r\n            a = c;\r\n            s = p / 4;\r\n        }\r\n        else {\r\n            s = (p / (2 * Math.PI)) * Math.asin(c / a);\r\n        }\r\n        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;\r\n    },\r\n    ElasticEaseOut(t, b, c, d, a, p) {\r\n        var s = 0;\r\n        if (t === 0) {\r\n            return b;\r\n        }\r\n        if ((t /= d) === 1) {\r\n            return b + c;\r\n        }\r\n        if (!p) {\r\n            p = d * 0.3;\r\n        }\r\n        if (!a || a < Math.abs(c)) {\r\n            a = c;\r\n            s = p / 4;\r\n        }\r\n        else {\r\n            s = (p / (2 * Math.PI)) * Math.asin(c / a);\r\n        }\r\n        return a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;\r\n    },\r\n    ElasticEaseInOut(t, b, c, d, a, p) {\r\n        var s = 0;\r\n        if (t === 0) {\r\n            return b;\r\n        }\r\n        if ((t /= d / 2) === 2) {\r\n            return b + c;\r\n        }\r\n        if (!p) {\r\n            p = d * (0.3 * 1.5);\r\n        }\r\n        if (!a || a < Math.abs(c)) {\r\n            a = c;\r\n            s = p / 4;\r\n        }\r\n        else {\r\n            s = (p / (2 * Math.PI)) * Math.asin(c / a);\r\n        }\r\n        if (t < 1) {\r\n            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;\r\n        }\r\n        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) * 0.5 + c + b;\r\n    },\r\n    BounceEaseOut(t, b, c, d) {\r\n        if ((t /= d) < 1 / 2.75) {\r\n            return c * (7.5625 * t * t) + b;\r\n        }\r\n        else if (t < 2 / 2.75) {\r\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\r\n        }\r\n        else if (t < 2.5 / 2.75) {\r\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\r\n        }\r\n        else {\r\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\r\n        }\r\n    },\r\n    BounceEaseIn(t, b, c, d) {\r\n        return c - Easings.BounceEaseOut(d - t, 0, c, d) + b;\r\n    },\r\n    BounceEaseInOut(t, b, c, d) {\r\n        if (t < d / 2) {\r\n            return Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;\r\n        }\r\n        else {\r\n            return Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\r\n        }\r\n    },\r\n    EaseIn(t, b, c, d) {\r\n        return c * (t /= d) * t + b;\r\n    },\r\n    EaseOut(t, b, c, d) {\r\n        return -c * (t /= d) * (t - 2) + b;\r\n    },\r\n    EaseInOut(t, b, c, d) {\r\n        if ((t /= d / 2) < 1) {\r\n            return (c / 2) * t * t + b;\r\n        }\r\n        return (-c / 2) * (--t * (t - 2) - 1) + b;\r\n    },\r\n    StrongEaseIn(t, b, c, d) {\r\n        return c * (t /= d) * t * t * t * t + b;\r\n    },\r\n    StrongEaseOut(t, b, c, d) {\r\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\r\n    },\r\n    StrongEaseInOut(t, b, c, d) {\r\n        if ((t /= d / 2) < 1) {\r\n            return (c / 2) * t * t * t * t * t + b;\r\n        }\r\n        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;\r\n    },\r\n    Linear(t, b, c, d) {\r\n        return (c * t) / d + b;\r\n    },\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/konva/Tween.ts?");

/***/ }),

/***/ "./src/components/canvas/shapes/circle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst Circle = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        getGroupRef: () => {\r\n            return groupRef.current;\r\n        },\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"rect\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, \"data-id\": props.name, draggable: false, onDragStart: props.onDragStart, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, onClick: props.onClickShape, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onMouseLeave: props.onMouseLeave, opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1, transformsEnabled: \"position\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize / 2, radius: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, stroke: settings.strokeColor, strokeWidth: 4, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, fill: props.isSelected ? settings.fillSelectedColor : settings.fillColor, transformsEnabled: \"position\", perfectDrawEnabled: false }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { x: 0, y: 0, text: props.node && props.node.label ? props.node.label : props.name, align: 'center', width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.circleSize, verticalAlign: \"middle\", listening: false, wrap: \"none\", fontSize: 18, ellipsis: true, fill: settings.textColor, transformsEnabled: \"position\", perfectDrawEnabled: false })));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/circle.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/diamond.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Diamond\": () => (/* binding */ Diamond)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n/* harmony import */ var _helpers_replace_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/helpers/replace-values.ts\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/use-image/index.js\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(use_image__WEBPACK_IMPORTED_MODULE_6__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst Diamond = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const [image] = use_image__WEBPACK_IMPORTED_MODULE_6___default()(\"/svg/cog.svg\");\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const regularPolygonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const shapeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        getGroupRef: () => {\r\n            return groupRef.current;\r\n        },\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"diamond\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                        if (settings.subShapeType === \"Loop\") {\r\n                        }\r\n                        else {\r\n                            regularPolygonRef.current.to({\r\n                                duration: 0.05,\r\n                                opacity: parameters.opacity\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\r\n                    if (settings.subShapeType === \"Loop\") {\r\n                    }\r\n                    else {\r\n                        if (regularPolygonRef && regularPolygonRef.current && parameters) {\r\n                            if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Selected) {\r\n                                regularPolygonRef.current.to({\r\n                                    duration: 0.15,\r\n                                    stroke: settings.strokeColor,\r\n                                    fill: settings.fillSelectedColor\r\n                                });\r\n                            }\r\n                            else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Default) {\r\n                                regularPolygonRef.current.to({\r\n                                    duration: 0.15,\r\n                                    stroke: settings.strokeColor,\r\n                                    fill: settings.fillColor\r\n                                });\r\n                            }\r\n                            else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Error) {\r\n                                regularPolygonRef.current.to({\r\n                                    duration: 0.15,\r\n                                    stroke: \"#f00000\",\r\n                                    fill: \"#ff9d9d\"\r\n                                });\r\n                            }\r\n                            else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ShapeStateEnum.Ok) {\r\n                                regularPolygonRef.current.to({\r\n                                    duration: 0.15,\r\n                                    stroke: \"#00e000\",\r\n                                    fill: \"#9dff9d\"\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    let labelText = props.node && props.node.label ? props.node.label : props.name;\r\n    if (settings.label && (0,_helpers_replace_values__WEBPACK_IMPORTED_MODULE_5__.hasReplacebleValuesExistingInPayload)(settings.label, props.node)) {\r\n        labelText = (0,_helpers_replace_values__WEBPACK_IMPORTED_MODULE_5__.replaceValuesExpressions)(settings.label, props.node, \"-\");\r\n    }\r\n    else if (!!props.hasTaskNameAsNodeTitle) {\r\n        labelText = props.node.taskType;\r\n    }\r\n    let textDecoration = \"\";\r\n    let strokeColor = settings.strokeColor;\r\n    let fillColor = props.isSelected ? settings.fillSelectedColor : settings.fillColor;\r\n    if (props.nodeState === \"error\") {\r\n        strokeColor = props.isSelected ? \"#f00000\" : \"#e00000\";\r\n        fillColor = props.isSelected ? \"#ff5454\" : \"#ff9d9d\";\r\n    }\r\n    else if (props.nodeState === \"ok\") {\r\n        strokeColor = props.isSelected ? \"#00f000\" : \"#00e000\";\r\n        fillColor = props.isSelected ? \"#54ff54\" : \"#9dff9d\";\r\n    }\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, draggable: false, transformsEnabled: \"position\", onClick: props.onClickShape, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, settings.subShapeType === \"Loop\" ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, radius: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, strokeWidth: 0, opacity: 1, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, fill: props.isSelected ? settings.fillSelectedColor : settings.fillColor, transformsEnabled: \"position\", perfectDrawEnabled: false }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Shape, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, stroke: strokeColor, strokeWidth: 4, ref: shapeRef, transformsEnabled: \"position\", sceneFunc: (context, shape) => {\r\n                        context.beginPath();\r\n                        context.lineWidth = 3;\r\n                        context.arc(0, 0, _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, 1.5 * Math.PI, 0.95 * Math.PI, false);\r\n                        context.stroke();\r\n                    } }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Arrow, { x: 0.25, y: 12 + (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2), points: [\r\n                        0.5,\r\n                        0,\r\n                        0,\r\n                        -4\r\n                    ], stroke: \"#000000\", strokeWidth: 1, pointerLength: 10, pointerWidth: 10, lineCap: \"round\", lineJoin: \"round\", opacity: 1, transformsEnabled: \"position\", fill: \"#000000\", perfectDrawEnabled: false, hitStrokeWidth: 0, noMouseEvents: true, shadowForStrokeEnabled: false })) :\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.RegularPolygon, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2, stroke: strokeColor, strokeWidth: 4, cornerRadius: 4, sides: 4, transformsEnabled: \"position\", ref: regularPolygonRef, radius: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, fill: fillColor, perfectDrawEnabled: false })),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { x: 10, y: 0, text: labelText, align: 'center', width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize - 20, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize, verticalAlign: \"middle\", listening: false, wrap: \"word\", transformsEnabled: \"position\", textDecoration: textDecoration, fontSize: 18, ellipsis: true, fill: settings.textColor, perfectDrawEnabled: false }),\r\n            !!settings.hasConfigMenu && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Image, { image: image, pathColor: settings.textColor, width: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 8), height: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 8), keepRatio: true, x: Math.round((_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 2) - _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.diamondSize / 16), y: 16, perfectDrawEnabled: false, transformsEnabled: \"position\", onClick: props.onClickSetup })));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/diamond.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/ellipse.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ellipse\": () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst Ellipse = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        getGroupRef: () => {\r\n            return groupRef.current;\r\n        },\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"ellipse\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, draggable: false, onClick: props.onClickShape, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, transformsEnabled: \"position\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Ellipse, { x: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht / 2, y: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectHeight / 2, radiusX: 100, radiusY: 50, stroke: settings.strokeColor, strokeWidth: 4, transformsEnabled: \"position\", cornerRadius: settings.cornerRadius, width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectHeight, fill: props.isSelected ? settings.fillSelectedColor : settings.fillColor, perfectDrawEnabled: false }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { x: 0, y: 0, text: props.node && props.node.label ? props.node.label : props.name, align: 'center', width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectHeight, verticalAlign: \"middle\", transformsEnabled: \"position\", listening: false, wrap: \"none\", fontSize: 18, ellipsis: true, fill: settings.textColor, perfectDrawEnabled: false })));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/ellipse.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/html.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Html\": () => (/* binding */ Html)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst Html = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        getGroupRef: () => {\r\n            return groupRef.current;\r\n        },\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"html\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\r\n        if (props.getNodeInstance) {\r\n            const instance = props.getNodeInstance(props.node, undefined, undefined, settings);\r\n            if (instance && instance.getWidth && instance.getHeight) {\r\n                setWidth(instance.getWidth(props.node));\r\n                setHeight(instance.getHeight(props.node));\r\n            }\r\n        }\r\n    }, [props.node]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { x: props.x, y: props.y, ref: groupRef, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, draggable: false, transformsEnabled: \"position\", onClick: props.onClickShape, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect, { x: 0, y: 0, strokeWidth: 0, cornerRadius: settings.cornerRadius, width: width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth, height: (height || props.node.height || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlHeight) + 5, fill: \"#000000\", opacity: 0, transformsEnabled: \"position\", perfectDrawEnabled: false })));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/html.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shapes\": () => (/* binding */ Shapes)\n/* harmony export */ });\n/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/components/canvas/shapes/circle.tsx\");\n/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/rect.tsx\");\n/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/line.tsx\");\n/* harmony import */ var _diamond__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/diamond.tsx\");\n/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/components/canvas/shapes/ellipse.tsx\");\n/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/components/canvas/shapes/html.tsx\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst Shapes = {\r\n    Circle: _circle__WEBPACK_IMPORTED_MODULE_0__.Circle, Rect: _rect__WEBPACK_IMPORTED_MODULE_1__.Rect, Line: _line__WEBPACK_IMPORTED_MODULE_2__.Line, Diamond: _diamond__WEBPACK_IMPORTED_MODULE_3__.Diamond, Ellipse: _ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse, Html: _html__WEBPACK_IMPORTED_MODULE_5__.Html\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/index.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/line-helper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineHelper\": () => (/* binding */ LineHelper),\n/* harmony export */   \"Lines\": () => (/* binding */ Lines)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/line.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _services_position_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/services/position-service.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst LineHelper = (props) => {\r\n    const endNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\r\n        const endIndex = props.flowHash.get(props.endshapeid).index;\r\n        if (endIndex < 0) {\r\n            return false;\r\n        }\r\n        return props.flow[endIndex];\r\n    }, [props.node.name, props.flow, props.flowHash, props.endshapeid]);\r\n    let newEndPosition = {\r\n        x: 0,\r\n        y: 0\r\n    };\r\n    if (endNode) {\r\n        let positionNode = props.positions(endNode.name) || endNode;\r\n        newEndPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getEndPointForLine(endNode, {\r\n            x: positionNode.x,\r\n            y: positionNode.y\r\n        }, endNode, props.getNodeInstance, props.lineNode.thumbEndPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default);\r\n    }\r\n    else {\r\n        let position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.getPosition)(props.lineNode.name);\r\n        if (!position) {\r\n            (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.setPosition)(props.lineNode.name, {\r\n                xstart: props.lineNode.xstart,\r\n                ystart: props.lineNode.ystart,\r\n                xend: props.lineNode.xend,\r\n                yend: props.lineNode.yend\r\n            });\r\n            position = (0,_services_position_service__WEBPACK_IMPORTED_MODULE_4__.getPosition)(props.lineNode.name);\r\n        }\r\n        newEndPosition = {\r\n            x: position.xend,\r\n            y: position.yend\r\n        };\r\n    }\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_line__WEBPACK_IMPORTED_MODULE_1__.Line, { ref: ref => (props.shapeRefs.current[props.lineNode.name] = ref), onMouseOver: (event) => props.onLineMouseOver(props.lineNode, event), onMouseOut: (event) => props.onLineMouseOut(props.lineNode, event), onClickLine: (event) => props.onClickLine(props.lineNode, event), canvasHasSelectedNode: props.canvasHasSelectedNode, isSelected: false, onMouseStart: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseEnd: props.onMouseEnd, lineNode: props.lineNode, shapeRefs: props.shapeRefs.current, isErrorColor: props.lineNode.followflow === 'onfailure', isSuccessColor: props.lineNode.followflow === 'onsuccess', xstart: props.newStartPosition.x, ystart: props.newStartPosition.y, xend: newEndPosition.x, yend: newEndPosition.y, isEventNode: props.lineNode.event !== undefined && props.lineNode.event !== \"\", selectedNodeName: \"\", startNodeName: props.lineNode.startshapeid, endNodeName: props.lineNode.endshapeid, hasEndThumb: props.endshapeid === undefined, noMouseEvents: false, touchedNodes: props.touchedNodes, name: props.lineNode.name, thumbPosition: props.lineNode.thumbPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default, thumbEndPosition: props.lineNode.thumbEndPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default, onMouseConnectionStartOver: props.onMouseConnectionStartOver, onMouseConnectionStartOut: props.onMouseConnectionStartOut, onMouseConnectionStartStart: props.onMouseConnectionStartStart, onMouseConnectionStartMove: props.onMouseConnectionStartMove, onMouseConnectionStartEnd: props.onMouseConnectionStartEnd, onMouseConnectionEndOver: props.onMouseConnectionEndOver, onMouseConnectionEndOut: props.onMouseConnectionEndOut, onMouseConnectionEndStart: props.onMouseConnectionEndStart, onMouseConnectionEndMove: props.onMouseConnectionEndMove, onMouseConnectionEndEnd: props.onMouseConnectionEndEnd, onMouseConnectionEndLeave: props.onMouseConnectionEndLeave });\r\n};\r\nconst Lines = (props) => {\r\n    const lines = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\r\n        return props.flowHash.get(props.node.name).start.map((lineIndex, index) => {\r\n            return props.flow[lineIndex];\r\n        });\r\n    }, [props.node.name, props.flow, props.flowHash]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, lines.map((lineNode, index) => {\r\n        let newPosition = { x: props.node.x, y: props.node.y };\r\n        newPosition = props.positions(props.node.name) || newPosition;\r\n        const newStartPosition = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_2__.FlowToCanvas.getStartPointForLine(props.node, newPosition, lineNode, props.getNodeInstance, lineNode.thumbPosition || _shape_types__WEBPACK_IMPORTED_MODULE_3__.ThumbPositionRelativeToNode.default);\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: index },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(LineHelper, { flow: props.flow, flowHash: props.flowHash, positions: props.positions, endshapeid: lineNode.endshapeid, node: props.node, lineNode: lineNode, getNodeInstance: props.getNodeInstance, canvasHasSelectedNode: props.canvasHasSelectedNode, isSelected: props.isSelected, selectedNode: props.selectedNode, shapeRefs: props.shapeRefs, onLineMouseOver: props.onLineMouseOver, onLineMouseOut: props.onLineMouseOut, onClickLine: props.onClickLine, onMouseStart: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseEnd: props.onMouseEnd, onMouseConnectionStartOver: props.onMouseConnectionStartOver, onMouseConnectionStartOut: props.onMouseConnectionStartOut, onMouseConnectionStartStart: props.onMouseConnectionStartStart, onMouseConnectionStartMove: props.onMouseConnectionStartMove, onMouseConnectionStartEnd: props.onMouseConnectionStartEnd, onMouseConnectionEndOver: props.onMouseConnectionEndOver, onMouseConnectionEndOut: props.onMouseConnectionEndOut, onMouseConnectionEndStart: props.onMouseConnectionEndStart, onMouseConnectionEndMove: props.onMouseConnectionEndMove, onMouseConnectionEndEnd: props.onMouseConnectionEndEnd, onMouseConnectionEndLeave: props.onMouseConnectionEndLeave, touchedNodes: props.touchedNodes, newStartPosition: newStartPosition }));\r\n    }));\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/line-helper.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/line.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line\": () => (/* binding */ Line)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _helpers_line_points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/helpers/line-points.ts\");\n/* harmony import */ var _thumbs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/thumbs.tsx\");\n/* harmony import */ var _thumbsstart__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/components/canvas/shapes/thumbsstart.tsx\");\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst KonvaLine = react_konva__WEBPACK_IMPORTED_MODULE_1__.Arrow;\r\n\r\n\r\nconst Line = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const [fillColor, setFillColor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.isConnectionWithVariable ? \"#e08000\" :\r\n        props.isConnectionWithFunction ? \"#0080e0\" : \"#000000\");\r\n    const [strokeWidth, setStrokeWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(2);\r\n    const [opacity, setOpacity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [dash, setDash] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.touchedNodes && props.name && props.touchedNodes[props.name] ? [5, 10] : [1, 1]);\r\n    const lineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const bgLineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        let _fillColor = props.isSelected ? \"#606060\" : \"#000000\";\r\n        let _strokeWidth = 4;\r\n        if (props.isErrorColor) {\r\n            _fillColor = props.isSelected ? \"#800000\" : \"#e00000\";\r\n        }\r\n        if (props.isSuccessColor) {\r\n            _fillColor = props.isSelected ? \"#004000\" : \"#008300\";\r\n        }\r\n        if (props.isAltColor) {\r\n            _fillColor = \"#a0a0a0\";\r\n        }\r\n        if (props.isConnectionWithVariable) {\r\n            _fillColor = \"#e08000\";\r\n        }\r\n        if (props.isConnectionWithFunction) {\r\n            _fillColor = \"#0080e0\";\r\n        }\r\n        if (props.isEventNode) {\r\n            _fillColor = \"#a000a0\";\r\n            _strokeWidth = 4;\r\n        }\r\n        let _opacity = 1;\r\n        if (props.isNodeConnectorHelper !== undefined && !!props.isNodeConnectorHelper) {\r\n            _opacity = 0;\r\n            if (lineRef.current) {\r\n                lineRef.current.pointerWidth(0);\r\n                lineRef.current.pointerLength(0);\r\n            }\r\n        }\r\n        if (!props.isSelected && props.canvasHasSelectedNode) {\r\n            if (props.selectedNodeName != props.startNodeName &&\r\n                props.selectedNodeName != props.endNodeName) {\r\n            }\r\n        }\r\n        let dash = [];\r\n        if (props.touchedNodes && props.name && props.touchedNodes[props.name]) {\r\n            dash = [5, 10];\r\n            _strokeWidth = 8;\r\n        }\r\n        else {\r\n        }\r\n        if (lineRef.current) {\r\n            lineRef.current.to({\r\n                duration: 0.15,\r\n                fill: _fillColor,\r\n                stroke: _fillColor,\r\n                strokeWidth: _strokeWidth,\r\n                opacity: _opacity\r\n            });\r\n        }\r\n        else {\r\n            setFillColor(_fillColor);\r\n            setStrokeWidth(_strokeWidth);\r\n        }\r\n        if (props.touchedNodes && props.name && props.touchedNodes[props.name]) {\r\n            setDash([5, 10]);\r\n        }\r\n        else {\r\n            setDash([]);\r\n        }\r\n    }, [props.isSelected,\r\n        props.isErrorColor,\r\n        props.isSuccessColor,\r\n        props.isAltColor,\r\n        props.isConnectionWithVariable,\r\n        props.isConnectionWithFunction,\r\n        props.isEventNode,\r\n        props.canvasHasSelectedNode,\r\n        props.selectedNodeName,\r\n        props.startNodeName,\r\n        props.endNodeName,\r\n        props.touchedNodes\r\n    ]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_6__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"line\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_6__.ModifyShapeEnum.GetXY: {\r\n                    if (lineRef && lineRef.current) {\r\n                        return {\r\n                            x: lineRef.current.x(),\r\n                            y: lineRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_6__.ModifyShapeEnum.SetXY: {\r\n                    if (lineRef && lineRef.current && parameters) {\r\n                        lineRef.current.x(parameters.x);\r\n                        lineRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_6__.ModifyShapeEnum.SetOpacity: {\r\n                    if (lineRef && lineRef.current && parameters) {\r\n                        lineRef.current.opacity(parameters.opacity);\r\n                        if (props.isNodeConnectorHelper !== undefined && !!props.isNodeConnectorHelper) {\r\n                            if (bgLineRef && bgLineRef.current) {\r\n                                bgLineRef.current.opacity(parameters.opacity);\r\n                            }\r\n                            if (lineRef.current) {\r\n                                if (parameters.opacity > 0) {\r\n                                    lineRef.current.pointerWidth(10);\r\n                                    lineRef.current.pointerLength(10);\r\n                                }\r\n                                else {\r\n                                    lineRef.current.pointerWidth(0);\r\n                                    lineRef.current.pointerLength(0);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_6__.ModifyShapeEnum.SetPoints: {\r\n                    if (lineRef && lineRef.current && parameters) {\r\n                        lineRef.current.points(parameters.points);\r\n                    }\r\n                    if (bgLineRef && bgLineRef.current && parameters) {\r\n                        bgLineRef.current.points(parameters.points);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_6__.ModifyShapeEnum.SetState: {\r\n                    if (lineRef && lineRef.current && parameters) {\r\n                        if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_6__.ShapeStateEnum.Touched) {\r\n                            lineRef.current.dash([5, 10]);\r\n                            lineRef.current.to({\r\n                                duration: 0.15,\r\n                                strokeWidth: 8,\r\n                                opacity: 1\r\n                            });\r\n                            if (bgLineRef.current) {\r\n                                bgLineRef.current.to({\r\n                                    duration: 0.15,\r\n                                    strokeWidth: (8 + 12),\r\n                                    opacity: 1\r\n                                });\r\n                            }\r\n                        }\r\n                        else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_6__.ShapeStateEnum.Default) {\r\n                            lineRef.current.dash([]);\r\n                            lineRef.current.to({\r\n                                duration: 0.15,\r\n                                strokeWidth: 4,\r\n                                opacity: 1\r\n                            });\r\n                            if (bgLineRef.current) {\r\n                                bgLineRef.current.to({\r\n                                    duration: 0.15,\r\n                                    strokeWidth: (4 + 12),\r\n                                    opacity: 1\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    let controlPoints = (0,_helpers_line_points__WEBPACK_IMPORTED_MODULE_2__.calculateLineControlPoints)(props.xstart, props.ystart, props.xend, props.yend, props.thumbPosition || _shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, props.thumbEndPosition || _shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { listening: !props.noMouseEvents, transformsEnabled: \"position\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaLine, { ref: bgLineRef, points: [props.xstart, props.ystart,\r\n                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                    props.xend, props.yend], stroke: \"#e2e2e2\", strokeWidth: strokeWidth + 12, pointerLength: 10, pointerWidth: 10, lineCap: \"round\", lineJoin: \"round\", dash: dash, transformsEnabled: \"position\", fill: \"#e2e2e2\", opacity: props.opacity !== undefined ? props.opacity : opacity, tension: 0, bezier: true, perfectDrawEnabled: false, hitStrokeWidth: 0, noMouseEvents: true, shadowForStrokeEnabled: false }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaLine, { ref: lineRef, points: [props.xstart, props.ystart,\r\n                    controlPoints.controlPointx1, controlPoints.controlPointy1,\r\n                    controlPoints.controlPointx2, controlPoints.controlPointy2,\r\n                    props.xend, props.yend], stroke: fillColor, strokeWidth: strokeWidth + 2, pointerLength: 10, pointerWidth: 10, transformsEnabled: \"position\", lineCap: \"round\", lineJoin: \"round\", hitStrokeWidth: 16, dash: dash, fill: fillColor, opacity: props.opacity !== undefined ? props.opacity : 1, tension: 0, bezier: true, perfectDrawEnabled: false, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onMouseDown: (event) => props.onMouseStart(props.lineNode, event), onMouseMove: (event) => props.onMouseMove(props.lineNode, event), onMouseUp: (event) => props.onMouseEnd(props.lineNode, event), onClick: props.onClickLine, onTap: props.onClickLine, shadowForStrokeEnabled: false })),\r\n        props.hasStartThumb !== undefined && !!props.hasStartThumb && props.shapeRefs && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_thumbsstart__WEBPACK_IMPORTED_MODULE_4__.ThumbsStart, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_5__.FlowToCanvas.getThumbStartPosition(\"\", { x: props.xstart, y: props.ystart }, 0), name: \"\", taskType: \"\", shapeType: \"\", node: props.lineNode, ref: ref => {\r\n                if (props.shapeRefs) {\r\n                    props.shapeRefs[\"thumbstart_line_\" + props.lineNode.name] = ref;\r\n                }\r\n            }, isSelected: false, isConnectedToSelectedNode: false, canvasHasSelectedNode: false, thumbPositionRelativeToNode: _shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, onMouseConnectionStartOver: (event) => props.onMouseConnectionStartOver(props.lineNode, false, event), onMouseConnectionStartOut: (event) => props.onMouseConnectionStartOut(props.lineNode, false, event), onMouseConnectionStartStart: (event) => props.onMouseConnectionStartStart(props.lineNode, false, \"\", _shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbFollowFlow.default, _shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, event), onMouseConnectionStartMove: (event) => props.onMouseConnectionStartMove(props.lineNode, false, event), onMouseConnectionStartEnd: (event) => props.onMouseConnectionStartEnd(props.lineNode, false, _shape_types__WEBPACK_IMPORTED_MODULE_6__.ThumbPositionRelativeToNode.default, event), getNodeInstance: props.getNodeInstance }),\r\n        props.hasEndThumb !== undefined && !!props.hasEndThumb && props.shapeRefs && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_thumbs__WEBPACK_IMPORTED_MODULE_3__.Thumbs, { position: _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_5__.FlowToCanvas.getThumbEndPosition(\"\", { x: props.xend, y: props.yend }), name: \"\", taskType: \"\", shapeType: \"\", node: undefined, ref: ref => {\r\n                if (props.shapeRefs) {\r\n                    props.shapeRefs[\"thumb_line_\" + props.lineNode.name] = ref;\r\n                }\r\n            }, isSelected: false, isConnectedToSelectedNode: false, canvasHasSelectedNode: false, onMouseConnectionEndOver: (event) => props.onMouseConnectionEndOver(props.lineNode, false, event), onMouseConnectionEndOut: (event) => props.onMouseConnectionEndOut(props.lineNode, false, event), onMouseConnectionEndStart: (event) => props.onMouseConnectionEndStart(props.lineNode, false, event), onMouseConnectionEndMove: (event) => props.onMouseConnectionEndMove(props.lineNode, false, event), onMouseConnectionEndEnd: (event) => props.onMouseConnectionEndEnd(props.lineNode, false, event), onMouseConnectionEndLeave: (event) => props.onMouseConnectionEndLeave(props.lineNode, false, event), getNodeInstance: props.getNodeInstance }));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/line.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/lines-for-shape.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LinesForShape\": () => (/* binding */ LinesForShape)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _line_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/line-helper.tsx\");\n\r\n\r\nconst LinesForShape = (props) => {\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_line_helper__WEBPACK_IMPORTED_MODULE_1__.Lines, { flow: props.flow, node: props.node, getNodeInstance: props.getNodeInstance, canvasHasSelectedNode: props.canvasHasSelectedNode, selectedNode: props.selectedNode, isSelected: props.isSelected, shapeRefs: props.shapeRefs, onLineMouseOver: props.onLineMouseOver, onLineMouseOut: props.onLineMouseOut, onClickLine: props.onClickLine, touchedNodes: props.touchedNodes, positions: props.positions, flowHash: props.flowHash, onMouseStart: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseEnd: props.onMouseEnd, onMouseConnectionStartOver: props.onMouseConnectionStartOver, onMouseConnectionStartOut: props.onMouseConnectionStartOut, onMouseConnectionStartStart: props.onMouseConnectionStartStart, onMouseConnectionStartMove: props.onMouseConnectionStartMove, onMouseConnectionStartEnd: props.onMouseConnectionStartEnd, onMouseConnectionEndOver: props.onMouseConnectionEndOver, onMouseConnectionEndOut: props.onMouseConnectionEndOut, onMouseConnectionEndStart: props.onMouseConnectionEndStart, onMouseConnectionEndMove: props.onMouseConnectionEndMove, onMouseConnectionEndEnd: props.onMouseConnectionEndEnd, onMouseConnectionEndLeave: props.onMouseConnectionEndLeave });\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/lines-for-shape.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/rect.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rect\": () => (/* binding */ Rect)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/use-image/index.js\");\n/* harmony import */ var use_image__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(use_image__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst getStrokeColor = (backgroundColorString, settings) => {\r\n    switch (backgroundColorString) {\r\n        case \"background-yellow\": {\r\n            return \"#f0e938\";\r\n        }\r\n        case \"background-orange\": {\r\n            return \"#f8a523\";\r\n        }\r\n        case \"background-blue\": {\r\n            return \"#36a4f9\";\r\n        }\r\n        case \"background-green\": {\r\n            return \"#3bee76\";\r\n        }\r\n        case \"background-purple\": {\r\n            return \"#cc8aee\";\r\n        }\r\n        default: {\r\n            return settings.strokeColor;\r\n        }\r\n    }\r\n};\r\nconst getFillColor = (backgroundColorString, settings) => {\r\n    switch (backgroundColorString) {\r\n        case \"background-yellow\": {\r\n            return \"#fbf791\";\r\n        }\r\n        case \"background-orange\": {\r\n            return \"#f4c67d\";\r\n        }\r\n        case \"background-blue\": {\r\n            return \"#86c6f8\";\r\n        }\r\n        case \"background-green\": {\r\n            return \"#7df4a4\";\r\n        }\r\n        case \"background-purple\": {\r\n            return \"#e2bcf5\";\r\n        }\r\n        default: {\r\n            return settings.fillColor;\r\n        }\r\n    }\r\n};\r\nconst Rect = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_5__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    const [image] = use_image__WEBPACK_IMPORTED_MODULE_1___default()(\"/svg/layout.svg\");\r\n    const [cogImage] = use_image__WEBPACK_IMPORTED_MODULE_1___default()(\"/svg/cog.svg\");\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    let textRef = undefined;\r\n    let skewX = 0;\r\n    let skewXOffset = 0;\r\n    let includeSvgIcon = false;\r\n    if (settings.isSkewed) {\r\n        skewX = -0.5;\r\n        skewXOffset = (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8);\r\n    }\r\n    if (props.node && props.node.objectSchema) {\r\n        if (props.node.objectSchema == \"layout\") {\r\n            includeSvgIcon = true;\r\n        }\r\n    }\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        if (rect && rect.current) {\r\n            rect.current.skew({\r\n                x: skewX,\r\n                y: 0\r\n            });\r\n        }\r\n        if (textRef) {\r\n            textRef.cache();\r\n        }\r\n    });\r\n    const setRef = (ref) => {\r\n        rect.current = ref;\r\n        if (rect.current) {\r\n            rect.current.skew({\r\n                x: skewX,\r\n                y: 0\r\n            });\r\n        }\r\n    };\r\n    const setTextRef = (ref) => {\r\n        textRef = ref;\r\n    };\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        getGroupRef: () => {\r\n            return groupRef.current;\r\n        },\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"rect\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_3__.ModifyShapeEnum.SetState: {\r\n                    if (rect && rect.current && parameters) {\r\n                        if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_3__.ShapeStateEnum.Selected) {\r\n                            rect.current.to({\r\n                                duration: 0.15,\r\n                                stroke: settings.strokeColor,\r\n                                fill: settings.fillSelectedColor\r\n                            });\r\n                        }\r\n                        else if (parameters.state == _shape_types__WEBPACK_IMPORTED_MODULE_3__.ShapeStateEnum.Default) {\r\n                            let strokeColor = settings.strokeColor;\r\n                            let fillColor = settings.fillColor;\r\n                            if (settings.background) {\r\n                                strokeColor = getStrokeColor(settings.background, settings);\r\n                                fillColor = getFillColor(settings.background, settings);\r\n                            }\r\n                            rect.current.to({\r\n                                duration: 0.15,\r\n                                stroke: strokeColor,\r\n                                fill: fillColor\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    let strokeColor = settings.strokeColor;\r\n    let fillColor = props.isSelected ? settings.fillSelectedColor : settings.fillColor;\r\n    if (!props.isSelected && settings.background) {\r\n        strokeColor = getStrokeColor(settings.background, settings);\r\n        fillColor = getFillColor(settings.background, settings);\r\n    }\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Group, { ref: groupRef, x: props.x, y: props.y, transformsEnabled: settings.isSkewed ? \"all\" : \"position\", draggable: false, order: 0, onTouchStart: props.onTouchStart, onTouchMove: props.onTouchMove, onTouchEnd: props.onTouchEnd, onDragStart: props.onDragStart, onDragMove: props.onDragMove, onDragEnd: props.onDragEnd, onMouseOver: props.onMouseOver, onMouseOut: props.onMouseOut, onMouseDown: props.onMouseStart, onMouseMove: props.onMouseMove, onMouseUp: props.onMouseEnd, onMouseLeave: props.onMouseLeave, onClick: props.onClickShape, listening: true, opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, { ref: ref => (setRef(ref)), x: skewXOffset, y: 0, stroke: strokeColor, hitStrokeWidth: 0, strokeWidth: 4, listening: true, cornerRadius: settings.cornerRadius, transformsEnabled: settings.isSkewed ? \"all\" : \"position\", width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectHeight, fill: fillColor, perfectDrawEnabled: false }),\r\n            settings.subShapeType && settings.subShapeType == \"Model\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Line, { points: [skewXOffset, 10, (skewXOffset + _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht), 10], stroke: settings.strokeColor, transformsEnabled: \"position\", listening: false, perfectDrawEnabled: false, strokeWidth: 4 }),\r\n            includeSvgIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Image, { image: image, pathColor: settings.textColor, width: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 4), height: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 4), keepRatio: true, listening: false, perfectDrawEnabled: false, transformsEnabled: \"position\", x: Math.round((_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 2) - (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8)), y: 8 }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Text, { ref: ref => (setTextRef(ref)), x: 0, y: includeSvgIcon ? Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8) : 0, text: !!props.hasTaskNameAsNodeTitle ? props.node.taskType : props.node && props.node.label ? props.node.label : props.name, align: 'center', fontSize: 18, transformsEnabled: \"position\", width: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht, height: _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectHeight, verticalAlign: \"middle\", listening: false, wrap: \"none\", ellipsis: true, fill: settings.textColor, perfectDrawEnabled: false }),\r\n            !!settings.hasConfigMenu && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_2__.Image, { image: cogImage, pathColor: settings.textColor, transformsEnabled: \"position\", listening: true, perfectDrawEnabled: false, width: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8), height: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8), keepRatio: true, x: Math.round(_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht - (_helpers_shape_measures__WEBPACK_IMPORTED_MODULE_4__.ShapeMeasures.rectWidht / 8) - 4), y: 4, onClick: props.onClickSetup })));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/rect.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/thumbs.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Thumbs\": () => (/* binding */ Thumbs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\r\n\r\n\r\n\r\nconst KonvaRect = react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect;\r\nconst KonvaCircle = react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle;\r\n\r\n\r\n\r\n\r\nconst Thumbs = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"thumbs\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\r\n        if (props.getNodeInstance) {\r\n            const instance = props.getNodeInstance(props.node, undefined, undefined, settings);\r\n            if (instance && instance.getWidth && instance.getHeight) {\r\n                setWidth(instance.getWidth(props.node));\r\n                let bodyElement = document.querySelector(\"#\" + props.name + \" .html-plugin-node\");\r\n                let element = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-thumb-startbottom\");\r\n                if (!bodyElement) {\r\n                    bodyElement = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-body\");\r\n                }\r\n                if (element && bodyElement) {\r\n                    setHeight(instance.getHeight(bodyElement.clientHeight + 20));\r\n                }\r\n                else {\r\n                    setHeight(instance.getHeight(props.node));\r\n                }\r\n            }\r\n        }\r\n    }, [props.isSelected, props.isConnectedToSelectedNode, props.node]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { ref: groupRef, x: props.position.x, y: props.position.y, onMouseOver: props.onMouseConnectionEndOver, onMouseOut: props.onMouseConnectionEndOut, onMouseDown: props.onMouseConnectionEndStart, onMouseMove: props.onMouseConnectionEndMove, onMouseUp: props.onMouseConnectionEndEnd, onMouseLeave: props.onMouseConnectionEndLeave, onTouchStart: props.onMouseConnectionEndStart, onTouchMove: props.onMouseConnectionEndMove, onTouchEnd: props.onMouseConnectionEndEnd, width: 12, height: 12, transformsEnabled: \"position\" },\r\n            (props.shapeType === \"\" || props.shapeType === \"Rect\" || props.shapeType === \"Diamond\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: 0, y: props.shapeType === \"\" ? 0 : 12, radius: 8, listening: false, transformsEnabled: \"position\", perfectDrawEnabled: false, fill: \"#000000\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: 0, y: props.shapeType === \"\" ? 0 : 12, radius: 6, listening: false, perfectDrawEnabled: false, transformsEnabled: \"position\", fill: \"#ffffff\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: 0, y: props.shapeType === \"\" ? 0 : 12, radius: 12, listening: true, transformsEnabled: \"position\", opacity: 0, perfectDrawEnabled: false })),\r\n            props.shapeType === \"Html\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaRect, { x: props.shapeType === \"Html\" &&\r\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.top ?\r\n                        ((width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth) / 2) - 12 :\r\n                        -16, y: props.shapeType === \"Html\" &&\r\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.top ? -16 : 40, strokeWidth: 0, stroke: \"#808080\", cornerRadius: settings.cornerRadius, width: 24, transformsEnabled: \"position\", height: 24, fill: \"#ff0000\", opacity: 0, perfectDrawEnabled: false, name: \"connectiontionend\", listening: true }))));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/thumbs.tsx?");

/***/ }),

/***/ "./src/components/canvas/shapes/thumbsstart.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThumbsStart\": () => (/* binding */ ThumbsStart)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n/* harmony import */ var _shape_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/shape-measures.ts\");\n/* harmony import */ var _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/helpers/shape-settings.ts\");\n\r\n\r\n\r\n\r\nconst KonvaRect = react_konva__WEBPACK_IMPORTED_MODULE_1__.Rect;\r\nconst KonvaCircle = react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle;\r\n\r\n\r\n\r\n\r\nconst ThumbsStart = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\r\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const settings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _helpers_shape_settings__WEBPACK_IMPORTED_MODULE_4__.ShapeSettings.getShapeSettings(props.taskType, props.node), [props.taskType, props.node]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => ({\r\n        modifyShape: (action, parameters) => {\r\n            switch (+action) {\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetShapeType: {\r\n                    return \"thumbsstart\";\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.GetXY: {\r\n                    if (groupRef && groupRef.current) {\r\n                        return {\r\n                            x: groupRef.current.x(),\r\n                            y: groupRef.current.y(),\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetXY: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.x(parameters.x);\r\n                        groupRef.current.y(parameters.y);\r\n                        if (props.shapeType === \"Html\" && props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom) {\r\n                            let width = undefined;\r\n                            let height = undefined;\r\n                            if (props.getNodeInstance && props.node) {\r\n                                const nodeInstance = props.getNodeInstance(props.node, undefined, undefined, settings);\r\n                                if (nodeInstance && nodeInstance.getWidth) {\r\n                                    width = nodeInstance.getWidth(props.node);\r\n                                    height = nodeInstance.getHeight(props.node);\r\n                                }\r\n                            }\r\n                            let bodyElement = document.querySelector(\"#\" + props.name + \" .html-plugin-node\");\r\n                            let element = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-thumb-startbottom\");\r\n                            if (element && bodyElement) {\r\n                                element.style.top = ((bodyElement.clientHeight + 20) || height || \"400\") + \"px\";\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetOpacity: {\r\n                    if (groupRef && groupRef.current && parameters) {\r\n                        groupRef.current.opacity(parameters.opacity);\r\n                    }\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetPoints: {\r\n                    break;\r\n                }\r\n                case _shape_types__WEBPACK_IMPORTED_MODULE_2__.ModifyShapeEnum.SetState: {\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }));\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\r\n        if (props.getNodeInstance && props.name) {\r\n            const instance = props.getNodeInstance(props.node, undefined, undefined, settings);\r\n            if (instance && instance.getWidth && instance.getHeight) {\r\n                setWidth(instance.getWidth(props.node));\r\n                let bodyElement = document.querySelector(\"#\" + props.name + \" .html-plugin-node\");\r\n                let element = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-thumb-startbottom\");\r\n                if (!bodyElement) {\r\n                    bodyElement = document.querySelector(\"#\" + props.name + \" .canvas__html-shape-body\");\r\n                }\r\n                if (element && bodyElement) {\r\n                    setHeight(bodyElement.clientHeight + 20);\r\n                    if (props.shapeType === \"Html\" && props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom) {\r\n                        element.style.top = ((bodyElement.clientHeight + 20) || height || \"400\") + \"px\";\r\n                    }\r\n                }\r\n                else {\r\n                    setHeight(instance.getHeight(props.node));\r\n                }\r\n            }\r\n        }\r\n    }, [props.isSelected, props.isConnectedToSelectedNode, props.node]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Group, { ref: groupRef, x: props.position.x, y: props.shapeType === \"Html\" &&\r\n                props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom ?\r\n                (props.position.y + height) :\r\n                props.position.y, onMouseOver: props.onMouseConnectionStartOver, onMouseOut: props.onMouseConnectionStartOut, onMouseDown: props.onMouseConnectionStartStart, onMouseMove: props.onMouseConnectionStartMove, onMouseUp: props.onMouseConnectionStartEnd, onTouchStart: props.onMouseConnectionStartStart, onTouchMove: props.onMouseConnectionStartMove, onTouchEnd: props.onMouseConnectionStartEnd, width: 12, height: 12, transformsEnabled: \"position\" },\r\n            (props.shapeType === \"\" || props.shapeType === \"Rect\" || props.shapeType === \"Diamond\") && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: props.shapeType === \"\" ? 0 : _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, y: props.shapeType === \"\" ? 0 : 12, radius: 8, listening: false, transformsEnabled: \"position\", perfectDrawEnabled: false, fill: props.followFlow == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbFollowFlow.happyFlow ? \"#00d300\" :\r\n                        (props.followFlow == _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbFollowFlow.unhappyFlow ? \"#e00000\" : \"#000000\"), opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: props.shapeType === \"\" ? 0 : _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, y: props.shapeType === \"\" ? 0 : 12, radius: 6, listening: false, transformsEnabled: \"position\", perfectDrawEnabled: false, fill: \"#ffffff\", opacity: props.canvasHasSelectedNode && !props.isSelected && !props.isConnectedToSelectedNode ? 1 : 1 }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaCircle, { x: props.shapeType === \"\" ? 0 : _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.rectWidht, y: props.shapeType === \"\" ? 0 : 12, listening: true, transformsEnabled: \"position\", perfectDrawEnabled: false, radius: 12, opacity: 0 })),\r\n            props.shapeType === \"Html\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(KonvaRect, { x: props.shapeType === \"Html\" &&\r\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom ?\r\n                        ((width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth) / 2) - 12 :\r\n                        (width || props.node.width || _helpers_shape_measures__WEBPACK_IMPORTED_MODULE_3__.ShapeMeasures.htmlWidth) - 8, y: props.shapeType === \"Html\" &&\r\n                        props.thumbPositionRelativeToNode === _shape_types__WEBPACK_IMPORTED_MODULE_2__.ThumbPositionRelativeToNode.bottom ? 0 :\r\n                        40, strokeWidth: 0, stroke: \"#808080\", transformsEnabled: \"position\", cornerRadius: settings.cornerRadius, width: 24, height: 24, fill: \"#ff0000\", opacity: 0, order: 1, perfectDrawEnabled: false, listening: true, name: \"connectiontionstart\" }))));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/canvas/shapes/thumbsstart.tsx?");

/***/ }),

/***/ "./src/components/edit-node-settings/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditNodeSettings\": () => (/* binding */ EditNodeSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/react-bootstrap/esm/Modal.js\");\n/* harmony import */ var _html_plugins_form_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/html-plugins/form-node.tsx\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _state_selected_node_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/state/selected-node-state.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst EditNodeSettings = (props) => {\r\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const [orgNodeName, setOrgNodeName] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\r\n    const [orgNodeValues, setOrgNodeValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const [requiredNodeValues, setRequiredNodeValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const flow = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_2__.useFlowStore)();\r\n    const selectedNode = (0,_state_selected_node_state__WEBPACK_IMPORTED_MODULE_3__.useSelectedNodeStore)();\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        if (!props.node) {\r\n            return;\r\n        }\r\n        const node = { ...props.node };\r\n        let newRequiredNodeValues;\r\n        if (node.shapeType !== \"Line\") {\r\n            newRequiredNodeValues = {\r\n                _id: node._id,\r\n                id: node.id,\r\n                x: node.x,\r\n                y: node.y,\r\n                shapeType: node.shapeType\r\n            };\r\n            delete node.x;\r\n            delete node.y;\r\n        }\r\n        else {\r\n            newRequiredNodeValues = {\r\n                _id: node._id,\r\n                id: node.id,\r\n                startshapeid: node.startshapeid,\r\n                endshapeid: node.endshapeid,\r\n                xstart: node.xstart,\r\n                ystart: node.ystart,\r\n                xend: node.xend,\r\n                yend: node.yend,\r\n                shapeType: node.shapeType,\r\n                taskType: node.taskType\r\n            };\r\n            delete node.startshapeid;\r\n            delete node.endshapeid;\r\n            delete node.xstart;\r\n            delete node.ystart;\r\n            delete node.xend;\r\n            delete node.yend;\r\n            delete node.taskType;\r\n        }\r\n        delete node._id;\r\n        delete node.id;\r\n        delete node.shapeType;\r\n        setValue(node);\r\n        setOrgNodeName(props.node.name);\r\n        setOrgNodeValues({ ...props.node });\r\n        setRequiredNodeValues(newRequiredNodeValues);\r\n    }, []);\r\n    const saveNode = (e) => {\r\n        try {\r\n            const changedProperties = value;\r\n            if (changedProperties.id !== undefined) {\r\n                delete changedProperties.id;\r\n            }\r\n            const node = { ...requiredNodeValues, ...changedProperties };\r\n            props.flowrunnerConnector.resetCurrentFlow();\r\n            flow.storeFlowNode(node, orgNodeName);\r\n            selectedNode.selectNode(node.name, node);\r\n            props.onClose(true);\r\n        }\r\n        catch (err) {\r\n            alert(\"The json in the 'Node JSON' field is invalid\");\r\n        }\r\n        e.preventDefault();\r\n        return false;\r\n    };\r\n    const onCloseClick = (event) => {\r\n        event.preventDefault();\r\n        props.onClose();\r\n        return false;\r\n    };\r\n    const onSetValue = (newValue, fieldName) => {\r\n        setValue({ ...value, [fieldName]: newValue });\r\n    };\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"edit-node-settings\", ref: ref => (containerRef.current = ref) },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default, { show: true, centered: true, size: props.modalSize || \"lg\", container: containerRef.current },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Header, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Title, null,\r\n                    \"Edit \",\r\n                    !!props.hasTaskNameAsNodeTitle ? props.node.taskType : props.node.name)),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Body, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"form-group\" },\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(_html_plugins_form_node__WEBPACK_IMPORTED_MODULE_1__.FormNodeHtmlPlugin, { isNodeSettingsUI: true, node: props.node, taskSettings: props.settings, onSetValue: onSetValue, isInFlowEditor: false, flowrunnerConnector: props.flowrunnerConnector }))),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Footer, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"btn btn-secondary\", onClick: onCloseClick }, \"Close\"),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"btn btn-primary\", onClick: saveNode }, \"Save\"))));\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/edit-node-settings/index.tsx?");

/***/ }),

/***/ "./src/components/edit-node/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditNodePopup\": () => (/* binding */ EditNodePopup)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/react-bootstrap/esm/Modal.js\");\n/* harmony import */ var _html_plugins_form_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/html-plugins/form-node.tsx\");\n/* harmony import */ var _state_flow_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/state/flow-state.ts\");\n/* harmony import */ var _state_selected_node_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/state/selected-node-state.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst EditNodePopup = (props) => {\r\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const [orgNodeName, setOrgNodeName] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\r\n    const [orgNodeValues, setOrgNodeValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const [requiredNodeValues, setRequiredNodeValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n    const flow = (0,_state_flow_state__WEBPACK_IMPORTED_MODULE_2__.useFlowStore)();\r\n    const selectedNode = (0,_state_selected_node_state__WEBPACK_IMPORTED_MODULE_3__.useSelectedNodeStore)();\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        if (!props.node) {\r\n            return;\r\n        }\r\n        const node = { ...props.node };\r\n        selectedNode.selectNode(props.node.name, props.node);\r\n        let newRequiredNodeValues;\r\n        if (node.shapeType !== \"Line\") {\r\n            newRequiredNodeValues = {\r\n                _id: node._id,\r\n                id: node.id,\r\n                x: node.x,\r\n                y: node.y,\r\n                shapeType: node.shapeType\r\n            };\r\n            delete node.x;\r\n            delete node.y;\r\n        }\r\n        else {\r\n            newRequiredNodeValues = {\r\n                _id: node._id,\r\n                id: node.id,\r\n                startshapeid: node.startshapeid,\r\n                endshapeid: node.endshapeid,\r\n                xstart: node.xstart,\r\n                ystart: node.ystart,\r\n                xend: node.xend,\r\n                yend: node.yend,\r\n                shapeType: node.shapeType,\r\n                taskType: node.taskType\r\n            };\r\n            delete node.startshapeid;\r\n            delete node.endshapeid;\r\n            delete node.xstart;\r\n            delete node.ystart;\r\n            delete node.xend;\r\n            delete node.yend;\r\n            delete node.taskType;\r\n        }\r\n        delete node._id;\r\n        delete node.id;\r\n        delete node.shapeType;\r\n        setValue(node);\r\n        setOrgNodeName(props.node.name);\r\n        setOrgNodeValues({ ...props.node });\r\n        setRequiredNodeValues(newRequiredNodeValues);\r\n    }, []);\r\n    const saveNode = (e) => {\r\n        try {\r\n            let nodeHelper = flow.flowHashmap.get(props.node.name);\r\n            if (nodeHelper) {\r\n                const nodeFromFlowStore = flow.flow[nodeHelper.index];\r\n                console.log(\"saveFlow\", nodeFromFlowStore);\r\n                if (props.formNodesubject) {\r\n                    props.formNodesubject.next({ \"id\": props.node.name, \"node\": nodeFromFlowStore });\r\n                }\r\n            }\r\n            props.onClose(true);\r\n        }\r\n        catch (err) {\r\n            alert(\"The json in the 'Node JSON' field is invalid\");\r\n        }\r\n        e.preventDefault();\r\n        return false;\r\n    };\r\n    const onCloseClick = (event) => {\r\n        event.preventDefault();\r\n        props.onClose();\r\n        return false;\r\n    };\r\n    const onSetValue = (newValue, fieldName) => {\r\n        console.log(\"editnode onsetvalue\", newValue, fieldName);\r\n        setValue({ ...value, [fieldName]: newValue });\r\n    };\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"edit-node-settings edit-node-popup\", ref: ref => (containerRef.current = ref) },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default, { show: true, centered: true, size: props.modalSize || \"xl\", container: containerRef.current },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Header, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Title, null,\r\n                    \"Edit \",\r\n                    !!props.hasTaskNameAsNodeTitle ? props.node.taskType : props.node.name)),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Body, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"form-group\" },\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(_html_plugins_form_node__WEBPACK_IMPORTED_MODULE_1__.FormNodeHtmlPlugin, { isNodeSettingsUI: false, node: props.node, taskSettings: props.settings, onSetValue: onSetValue, isInFlowEditor: true, flowrunnerConnector: props.flowrunnerConnector }))),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_bootstrap__WEBPACK_IMPORTED_MODULE_4__.default.Footer, null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"btn btn-secondary\", onClick: onCloseClick }, \"Close\"),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"btn btn-primary\", onClick: saveNode }, \"Save\"))));\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/edit-node/index.tsx?");

/***/ }),

/***/ "./src/components/flow/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Flow\": () => (/* binding */ Flow)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n\r\n\r\nconst Flow = (props) => {\r\n    const [internalFlow, setInternalFlow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        console.log(\"FLOW in flow component useEffect\", performance.now());\r\n        if (internalFlow.length != props.flow.length) {\r\n            setInternalFlow(props.flow);\r\n        }\r\n        else {\r\n            let changed = false;\r\n            let changedNode = \"\";\r\n            let changedNodeProperty = \"\";\r\n            let properties = [\"x\", \"y\", \"xstart\", \"ystart\", \"xend\", \"yend\"];\r\n            let perfstart = performance.now();\r\n            props.flow.map((node, index) => {\r\n                if (changed) {\r\n                    return true;\r\n                }\r\n                const internalNode = internalFlow[index];\r\n                {\r\n                    let nodeKeys = Object.keys(node);\r\n                    let internalNodeKeys = Object.keys(internalNode);\r\n                    {\r\n                        nodeKeys.map((nodeProperty) => {\r\n                            if (changed) {\r\n                                return;\r\n                            }\r\n                            if (properties.indexOf(nodeProperty) >= 0) {\r\n                                return;\r\n                            }\r\n                            if (node[nodeProperty] !== internalNode[nodeProperty]) {\r\n                                changed = true;\r\n                                changedNode = node.name;\r\n                                changedNodeProperty = nodeProperty;\r\n                            }\r\n                        });\r\n                        if (!changed) {\r\n                            internalNodeKeys.map((internalNodeProperty) => {\r\n                                if (changed) {\r\n                                    return;\r\n                                }\r\n                                if (properties.indexOf(internalNodeProperty) >= 0) {\r\n                                    return;\r\n                                }\r\n                                if (node[internalNodeProperty] !== internalNode[internalNodeProperty]) {\r\n                                    changed = true;\r\n                                    changedNode = node.name;\r\n                                    changedNodeProperty = internalNodeProperty;\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            console.log(\"flow diffing time\", (performance.now() - perfstart) + \"ms\");\r\n            if (changed || !!props.flowrunnerConnector.forcePushToFlowRunner) {\r\n                console.log(\"flow changed\", changedNode, changedNodeProperty, props.flowrunnerConnector.forcePushToFlowRunner, props.flow);\r\n                props.flowrunnerConnector.forcePushToFlowRunner = false;\r\n                setInternalFlow(props.flow);\r\n            }\r\n        }\r\n    }, [props.flow, props.flowId]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        let perfstart = performance.now();\r\n        if (!internalFlow) {\r\n            return;\r\n        }\r\n        props.flowrunnerConnector.pushFlowToFlowrunner(internalFlow, true, props.flowId);\r\n        console.log(\"flow pushFlowToFlowrunner\", (performance.now() - perfstart) + \"ms\");\r\n    }, [internalFlow]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/flow/index.tsx?");

/***/ }),

/***/ "./src/components/taskbar/draggable.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draggable\": () => (/* binding */ Draggable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/@dnd-kit/core/dist/core.esm.js\");\n\r\n\r\nconst Draggable = (props) => {\r\n    const { isDragging, attributes, listeners, setNodeRef, transform } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({\r\n        id: props.id,\r\n    });\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", Object.assign({ ref: setNodeRef, className: \"taskbar-draggable\" }, listeners, attributes), props.children));\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/taskbar/draggable.tsx?");

/***/ }),

/***/ "./src/components/taskbar/index.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TaskMenuMode\": () => (/* binding */ TaskMenuMode),\n/* harmony export */   \"Taskbar\": () => (/* binding */ Taskbar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var _draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/taskbar/draggable.tsx\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/helpers/flow-to-canvas.ts\");\n/* harmony import */ var _state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/state/canvas-mode-state.ts\");\n/* harmony import */ var _state_modules_menu_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/state/modules-menu-state.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar TaskMenuMode;\r\n(function (TaskMenuMode) {\r\n    TaskMenuMode[TaskMenuMode[\"tasks\"] = 0] = \"tasks\";\r\n    TaskMenuMode[TaskMenuMode[\"modules\"] = 1] = \"modules\";\r\n})(TaskMenuMode || (TaskMenuMode = {}));\r\nconst Taskbar = (props) => {\r\n    const [metaDataInfo, setMetaDataInfo] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\r\n    const [menuMode, setMenuMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(TaskMenuMode.tasks);\r\n    const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\r\n    const [repositoryItems, setRepositoryItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const [customNodes, setCustomNodes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\r\n    const canvasMode = (0,_state_canvas_mode_state__WEBPACK_IMPORTED_MODULE_4__.useCanvasModeStateStore)();\r\n    const modulesMenu = (0,_state_modules_menu_state__WEBPACK_IMPORTED_MODULE_5__.useModulesStateStore)();\r\n    const setupTasks = (metaDataInfo) => {\r\n        const taskPluginsSortedList = metaDataInfo.sort((a, b) => {\r\n            if (a.fullName < b.fullName) {\r\n                return -1;\r\n            }\r\n            if (a.fullName > b.fullName) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n        const tasks = taskPluginsSortedList.filter((task) => {\r\n            return task.flowType == canvasMode.flowType;\r\n        }).map((task) => {\r\n            const taskSettings = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_3__.FlowToCanvas.getTaskSettings(task.className);\r\n            return { ...task,\r\n                icon: taskSettings.icon || task.icon || \"\"\r\n            };\r\n        });\r\n        setMetaDataInfo(tasks);\r\n    };\r\n    const loadTasks = () => {\r\n        var _a;\r\n        if (props.flowrunnerConnector.hasStorageProvider) {\r\n            let tasks = ((_a = props.flowrunnerConnector.storageProvider) === null || _a === void 0 ? void 0 : _a.getTasks()) || [];\r\n            setupTasks([...tasks, ...props.flowrunnerConnector.getTasksFromPluginRegistry()]);\r\n            return;\r\n        }\r\n        cross_fetch__WEBPACK_IMPORTED_MODULE_2___default()('/tasks')\r\n            .then(res => {\r\n            if (res.status >= 400) {\r\n                throw new Error(\"Bad response from server\");\r\n            }\r\n            return res.json();\r\n        })\r\n            .then(metaDataInfo => {\r\n            setupTasks([...metaDataInfo, ...props.flowrunnerConnector.getTasksFromPluginRegistry()]);\r\n        })\r\n            .catch(err => {\r\n            console.error(err);\r\n        });\r\n    };\r\n    const loadModules = () => {\r\n        cross_fetch__WEBPACK_IMPORTED_MODULE_2___default()('/api/modules')\r\n            .then(res => {\r\n            if (res.status >= 400) {\r\n                throw new Error(\"Bad response from server\");\r\n            }\r\n            return res.json();\r\n        })\r\n            .then(modules => {\r\n            console.log(\"modules\", modules);\r\n            setModules(modules);\r\n        })\r\n            .catch(err => {\r\n            console.error(err);\r\n        });\r\n    };\r\n    const loadRepositoryItems = () => {\r\n        cross_fetch__WEBPACK_IMPORTED_MODULE_2___default()('/api/module?codeName=repository')\r\n            .then(res => {\r\n            if (res.status >= 400) {\r\n                throw new Error(\"Bad response from server\");\r\n            }\r\n            return res.json();\r\n        })\r\n            .then(repositoryItems => {\r\n            console.log(\"repositoryItems\", repositoryItems);\r\n            setRepositoryItems(repositoryItems);\r\n        })\r\n            .catch(err => {\r\n            console.error(err);\r\n        });\r\n    };\r\n    const loadCustomNodesItems = () => {\r\n        cross_fetch__WEBPACK_IMPORTED_MODULE_2___default()('/api/module?codeName=customNodes')\r\n            .then(res => {\r\n            if (res.status >= 400) {\r\n                throw new Error(\"Bad response from server\");\r\n            }\r\n            return res.json();\r\n        })\r\n            .then(customNodes => {\r\n            console.log(\"customNodes\", customNodes);\r\n            setCustomNodes(customNodes);\r\n        })\r\n            .catch(err => {\r\n            console.error(err);\r\n        });\r\n    };\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        loadTasks();\r\n        if (props.hasCustomNodesAndRepository) {\r\n            loadRepositoryItems();\r\n            loadCustomNodesItems();\r\n        }\r\n    }, [canvasMode, props.hasCustomNodesAndRepository]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        if (modulesMenu.isOpen) {\r\n            setMenuMode(TaskMenuMode.modules);\r\n            loadModules();\r\n        }\r\n        else {\r\n            setMenuMode(TaskMenuMode.tasks);\r\n        }\r\n    }, [modulesMenu.isOpen]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n        if (metaDataInfo.length > 0) {\r\n            let loadingElement = document.getElementById(\"loading\");\r\n            if (loadingElement && !loadingElement.classList.contains(\"loaded\")) {\r\n                loadingElement.classList.add(\"loaded\");\r\n                setTimeout(() => {\r\n                    let loadingElement = document.getElementById(\"loading\");\r\n                    if (loadingElement) {\r\n                        loadingElement.classList.add(\"hidden\");\r\n                    }\r\n                }, 350);\r\n            }\r\n        }\r\n    }, [metaDataInfo]);\r\n    const onShowTests = (event) => {\r\n        event.preventDefault();\r\n        modulesMenu.showModule(\"tests\");\r\n        return false;\r\n    };\r\n    const onShowModule = (module, event) => {\r\n        event.preventDefault();\r\n        modulesMenu.showModule(module.name, module.id, module.moduleType);\r\n        return false;\r\n    };\r\n    const onDragStart = (event) => {\r\n        event.dataTransfer.setData(\"data-task\", event.target.getAttribute(\"data-task\"));\r\n    };\r\n    const renderRect = (className, taskMetaData) => {\r\n        var _a;\r\n        let html5DragAndDrop = false;\r\n        const shapeType = _helpers_flow_to_canvas__WEBPACK_IMPORTED_MODULE_3__.FlowToCanvas.getShapeType(\"Rect\", className, false);\r\n        if (shapeType == \"Circle\") {\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className));\r\n        }\r\n        if (shapeType == \"Ellipse\") {\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className));\r\n        }\r\n        if (shapeType == \"Diamond\") {\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__task\", title: className, \"data-task\": className, draggable: html5DragAndDrop, onDragStart: onDragStart },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, className),\r\n                taskMetaData.icon ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"taskbar__task-icon fas \" + taskMetaData.icon }) :\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"16\", height: \"16\" },\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"polygon\", { points: \"8,2,14,8,8,14,2,8\", className: \"taskbar__task-circle\" })));\r\n        }\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: `task_${className}`, className: \"taskbar__task\", title: taskMetaData.title || className, \"data-task\": className, \"data-id\": (_a = taskMetaData.id) !== null && _a !== void 0 ? _a : \"\", draggable: html5DragAndDrop, onDragStart: onDragStart },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, taskMetaData.title || className),\r\n            taskMetaData.icon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"taskbar__task-icon fas \" + taskMetaData.icon }));\r\n    };\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar\", style: { pointerEvents: props.isDragging ? \"none\" : \"auto\" } }, menuMode == TaskMenuMode.tasks ?\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__ribbon\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                    metaDataInfo.map((taskMetaData, index) => {\r\n                        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_draggable__WEBPACK_IMPORTED_MODULE_1__.Draggable, { id: taskMetaData.className, key: taskMetaData.className }, renderRect(taskMetaData.className, taskMetaData));\r\n                    }),\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"p-1 tw-mt-4 tw-bg-gray-300\" },\r\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Repository\")),\r\n                        repositoryItems && repositoryItems.items && repositoryItems.items.map((repoItem, index) => {\r\n                            const taskRepoItem = {\r\n                                className: \"repo-item\" + index,\r\n                                id: repoItem.id,\r\n                                title: repoItem.name\r\n                            };\r\n                            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_draggable__WEBPACK_IMPORTED_MODULE_1__.Draggable, { id: taskRepoItem.className, key: taskRepoItem.className }, renderRect(taskRepoItem.className, taskRepoItem));\r\n                        })),\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"p-1 tw-mt-4 tw-bg-gray-300\" },\r\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"CustomNodes\")),\r\n                        customNodes && customNodes.items && customNodes.items.map((customNode, index) => {\r\n                            const taskCustomNode = {\r\n                                className: \"custom-node\" + index,\r\n                                id: customNode.id,\r\n                                title: customNode.name\r\n                            };\r\n                            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_draggable__WEBPACK_IMPORTED_MODULE_1__.Draggable, { id: taskCustomNode.className, key: taskCustomNode.className }, renderRect(taskCustomNode.className, taskCustomNode));\r\n                        })))) :\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n                modules.map((module, index) => {\r\n                    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"module-\" + index, onClick: (event) => onShowModule(module, event), className: \"btn btn-outline-primary w-100 mb-2\" }, module.name);\r\n                }),\r\n                canvasMode.flowType == \"playground\" && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: onShowTests, className: \"btn btn-outline-primary w-100\" }, \"Tests\"))));\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/taskbar/index.tsx?");

/***/ }),

/***/ "./src/dragging-task.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DragginTask\": () => (/* binding */ DragginTask)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n\r\nconst DragginTask = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({}, props, { ref: ref, className: \"taskbar__task\" }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"taskbar__taskname\" }, props.id));\r\n});\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/dragging-task.tsx?");

/***/ }),

/***/ "./src/helpers/line-points.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateLineControlPoints\": () => (/* binding */ calculateLineControlPoints)\n/* harmony export */ });\n/* harmony import */ var victor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/victor/index.js\");\n/* harmony import */ var victor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(victor__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n\r\n\r\nconst calculateLineControlPoints = (xstart, ystart, xend, yend, startPositionRelativeToNode, endPositionRelativeToNode) => {\r\n    let controlPointx1;\r\n    let controlPointy1;\r\n    let controlPointx2;\r\n    let controlPointy2;\r\n    let factor = 0.35;\r\n    var vec1 = new (victor__WEBPACK_IMPORTED_MODULE_0___default())(xstart, ystart);\r\n    var vec2 = new (victor__WEBPACK_IMPORTED_MODULE_0___default())(xend, yend);\r\n    var distance = vec1.distance(vec2) * factor;\r\n    let yadjust = 0;\r\n    let xadjust = 0;\r\n    if (xend < xstart && Math.abs(ystart - yend) < 32) {\r\n        yadjust = Math.abs(xstart - xend) * 0.5;\r\n        xadjust = 200;\r\n    }\r\n    if (startPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.left) {\r\n        controlPointx1 = xstart - distance - xadjust;\r\n        controlPointy1 = ystart + yadjust;\r\n    }\r\n    else if (startPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.top) {\r\n        controlPointx1 = xstart;\r\n        controlPointy1 = ystart - distance;\r\n    }\r\n    else if (startPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.bottom) {\r\n        controlPointx1 = xstart;\r\n        controlPointy1 = ystart + distance;\r\n    }\r\n    else {\r\n        controlPointx1 = xstart + distance + xadjust;\r\n        controlPointy1 = ystart + yadjust;\r\n    }\r\n    if (endPositionRelativeToNode == _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_1__.ThumbPositionRelativeToNode.top) {\r\n        controlPointx2 = xend;\r\n        controlPointy2 = yend - distance;\r\n    }\r\n    else {\r\n        controlPointx2 = xend - distance - xadjust;\r\n        controlPointy2 = yend + yadjust;\r\n    }\r\n    return {\r\n        controlPointx1: controlPointx1,\r\n        controlPointy1: controlPointy1,\r\n        controlPointx2: controlPointx2,\r\n        controlPointy2: controlPointy2,\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/helpers/line-points.ts?");

/***/ }),

/***/ "./src/helpers/shape-settings.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShapeSettings\": () => (/* binding */ ShapeSettings)\n/* harmony export */ });\n/* harmony import */ var _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/components/canvas/shapes/shape-types.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/config.ts\");\n\r\n\r\nclass ShapeSettings {\r\n    static getShapeSettings(taskType, node) {\r\n        let settings = {\r\n            strokeColor: '#000000',\r\n            fillColor: _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_0__.shapeBackgroundColor,\r\n            fillSelectedColor: _components_canvas_shapes_shape_types__WEBPACK_IMPORTED_MODULE_0__.shapeSelectedBackgroundColor,\r\n            textColor: '#000000',\r\n            cornerRadius: 0,\r\n            isSkewed: false,\r\n            hasUI: false,\r\n        };\r\n        const taskTypeConfig = (0,_config__WEBPACK_IMPORTED_MODULE_1__.getTaskConfigForTask)(taskType);\r\n        if (taskTypeConfig) {\r\n            let variableSettings = {};\r\n            if (node && !!node.hasVariableAttached) {\r\n                variableSettings = taskTypeConfig['_variable'];\r\n            }\r\n            if (node && node.objectSchema && taskTypeConfig[node.objectSchema]) {\r\n                settings = {\r\n                    ...settings,\r\n                    ...taskTypeConfig,\r\n                    ...variableSettings,\r\n                    ...taskTypeConfig[node.objectSchema],\r\n                };\r\n            }\r\n            else {\r\n                settings = { ...settings, ...taskTypeConfig, ...variableSettings };\r\n            }\r\n        }\r\n        return settings;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/helpers/shape-settings.ts?");

/***/ }),

/***/ "./src/state/nodes-touched.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useNodesTouchedStateStore\": () => (/* binding */ useNodesTouchedStateStore),\n/* harmony export */   \"useNodesTouchedStateForMultiFormStore\": () => (/* binding */ useNodesTouchedStateForMultiFormStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/zustand/esm/index.js\");\n\r\nlet storeHandler = (set) => {\r\n    return {\r\n        nodesTouched: {},\r\n        setNodesTouched: (nodesTouched) => set(state => {\r\n            return {\r\n                nodesTouched: nodesTouched,\r\n            };\r\n        }),\r\n        clearNodesTouched: () => set(state => {\r\n            return {\r\n                nodesTouched: {},\r\n            };\r\n        }),\r\n    };\r\n};\r\nconst useNodesTouchedStateStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.default)(set => storeHandler(set));\r\nconst useNodesTouchedStateForMultiFormStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.default)(set => storeHandler(set));\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/state/nodes-touched.ts?");

/***/ })

}]);