/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["flowcanvaswebpackJsonpPlugin"] = self["flowcanvaswebpackJsonpPlugin"] || []).push([["src_components_html-plugins_visualizers_xy-canvas_tsx"],{

/***/ "./src/components/html-plugins/visualizers/xy-canvas.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XYCanvas\": () => (/* binding */ XYCanvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n\r\n\r\nconst heightCorrection = 42;\r\nclass XYCanvas extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.state = {};\r\n        this.getCurrentDebugNotifier = () => {\r\n            if (this.props.selectedNode && this.props.selectedNode.node) {\r\n                let selectedNodePayload = this.props.selectedNode.payload;\r\n                if (selectedNodePayload) {\r\n                    if (!selectedNodePayload.nodeExecutionId) {\r\n                        return null;\r\n                    }\r\n                    let nodeExecutions = this.props.flowrunnerConnector.getNodeExecutions();\r\n                    let executionIndex = -1;\r\n                    nodeExecutions.map((nodeExec, index) => {\r\n                        if (nodeExec && nodeExec.payload && nodeExec.payload.nodeExecutionId == selectedNodePayload.nodeExecutionId) {\r\n                            executionIndex = index;\r\n                        }\r\n                    });\r\n                    if (executionIndex >= 0) {\r\n                        let isFound = false;\r\n                        let resultPayloadIndex = -1;\r\n                        let loop = executionIndex;\r\n                        while (loop >= 0) {\r\n                            let index = loop;\r\n                            let nodeExec = nodeExecutions[loop];\r\n                            if (!isFound && index <= executionIndex) {\r\n                                this.props.payloads.map((payload, payloadIndex) => {\r\n                                    if (!isFound && payload && nodeExec.payload && payload.debugId == nodeExec.payload.debugId) {\r\n                                        isFound = true;\r\n                                        resultPayloadIndex = payloadIndex;\r\n                                    }\r\n                                });\r\n                            }\r\n                            loop--;\r\n                        }\r\n                        if (resultPayloadIndex >= 0) {\r\n                            let height = (this.props.node.height || 250) - heightCorrection;\r\n                            let width = (this.props.node.width || 250);\r\n                            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: [resultPayloadIndex, 0,\r\n                                    resultPayloadIndex,\r\n                                    height\r\n                                ], tension: 0, closed: true, stroke: \"#3f51b5\", strokeWidth: 2 });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        this.getMinMax = (payloads, series, height, node) => {\r\n            let result = {\r\n                min: undefined,\r\n                max: undefined,\r\n                ratio: 1,\r\n                correction: 0\r\n            };\r\n            payloads.map((payload) => {\r\n                series.map((serie) => {\r\n                    if (payload[serie.yProperty]) {\r\n                        if (result.min === undefined || payload[serie.yProperty] < result.min) {\r\n                            result.min = payload[serie.yProperty];\r\n                        }\r\n                        if (result.max === undefined || payload[serie.yProperty] > result.max) {\r\n                            result.max = payload[serie.yProperty];\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n            if (node.minValue !== undefined) {\r\n                result.min = result.min !== undefined && node.minValue > result.min ? result.min : node.minValue;\r\n            }\r\n            if (node.maxValue !== undefined) {\r\n                result.max = result.max !== undefined && node.maxValue < result.max ? result.max : node.maxValue;\r\n            }\r\n            if (result.min !== undefined && result.max !== undefined) {\r\n                if (result.max - result.min != 0 && height != 0) {\r\n                    result.ratio = 1 / ((result.max - result.min) / (height - 2));\r\n                }\r\n                if (result.min < 0) {\r\n                    result.correction = -(result.min * result.ratio) + 1;\r\n                }\r\n                else {\r\n                    result.correction = -(result.min * result.ratio) + 1;\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        this.getLineChart = (node, xProperty, yProperty, payload, index, payloads, color, serieIndex, title, fill, minmax) => {\r\n            let circle = null;\r\n            let height = (this.props.node.height || 250) - heightCorrection;\r\n            let xPosition = index;\r\n            if (payloads.length < 250) {\r\n                xPosition = index + (250 - payloads.length);\r\n            }\r\n            if ((xProperty == \"index\" || !isNaN(payload[xProperty])) &&\r\n                !isNaN(payload[yProperty])) {\r\n                let x = 0;\r\n                if (xProperty == \"index\") {\r\n                    x = xPosition;\r\n                }\r\n                else {\r\n                    x = payload[xProperty];\r\n                }\r\n                let y = 2 + ((height - 2) - ((payload[yProperty] * minmax.ratio) + (minmax.correction)));\r\n                let xNext = 0;\r\n                let yNext = 0;\r\n                if (!!node.includeLines && (index < payloads.length - 1)) {\r\n                    if (xProperty == \"index\") {\r\n                        xNext = xPosition + 1;\r\n                    }\r\n                    else {\r\n                        xNext = payloads[index + 1][xProperty];\r\n                    }\r\n                    yNext = 2 + ((height - 2) - ((payloads[index + 1][yProperty] * minmax.ratio) + (minmax.correction)));\r\n                }\r\n                circle = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: \"xycanvas-wrapper-\" + index + \"-\" + serieIndex },\r\n                    !node.includeLines &&\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle, { key: \"xycanvas-\" + index + \"-\" + serieIndex, x: x, y: y, radius: 4, stroke: color, strokeWidth: 2, width: 4, height: 4, fill: color, perfectDrawEnabled: true }),\r\n                    fill !== \"\" && !!node.includeLines && (index < payloads.length - 1) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: [x, y,\r\n                            xNext,\r\n                            yNext,\r\n                            xNext, height,\r\n                            x, height\r\n                        ], tension: 0, closed: true, strokeWidth: 1, fill: fill }),\r\n                    !!node.includeLines && (index < payloads.length - 1) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: [x, y,\r\n                            xNext,\r\n                            yNext\r\n                        ], tension: 0, closed: true, stroke: color, strokeWidth: 1 }),\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Label, { x: 4, y: serieIndex * 24 },\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { text: title, fontSize: 18, align: 'left', height: 24, verticalAlign: \"middle\", listening: false, wrap: \"none\", ellipsis: true, fill: color, perfectDrawEnabled: true })));\r\n            }\r\n            return circle;\r\n        };\r\n        this.getCurved = (node, xProperty, yProperty, payloads, minmax) => {\r\n            let height = (this.props.node.height || 250) - heightCorrection;\r\n            let points = [];\r\n            payloads.map((payload, index) => {\r\n                if (index % (node.sample || 10) == 0) {\r\n                    if ((xProperty == \"index\" || !isNaN(payload[xProperty])) &&\r\n                        !isNaN(payload[yProperty])) {\r\n                        let xPosition = index;\r\n                        if (payloads.length < 250) {\r\n                            xPosition = index + (250 - payloads.length);\r\n                        }\r\n                        let x = 0;\r\n                        if (xProperty == \"index\") {\r\n                            x = xPosition;\r\n                        }\r\n                        else {\r\n                            x = payload[xProperty];\r\n                        }\r\n                        let y = 2 + ((height - 2) - ((payload[yProperty] * minmax.ratio) + (minmax.correction)));\r\n                        points.push(x);\r\n                        points.push(y);\r\n                    }\r\n                }\r\n            });\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: points, stroke: \"#000000\", bezier: true, strokeWidth: 1 });\r\n        };\r\n    }\r\n    componentDidMount() {\r\n    }\r\n    render() {\r\n        var _a, _b;\r\n        let height = (this.props.node.height || 250) - heightCorrection;\r\n        let circles = null;\r\n        const { node, payloads } = this.props;\r\n        let minmax = this.getMinMax(payloads, node.series ? node.series : [{ xProperty: node.xProperty, yProperty: node.yProperty }], height, this.props.node);\r\n        if (!!node.showCurved) {\r\n            circles = this.getCurved(node, node.xProperty, node.yProperty, payloads, minmax);\r\n        }\r\n        else {\r\n            circles = payloads.map((payload, index) => {\r\n                let circle = null;\r\n                if (node.series) {\r\n                    circle = node.series.map((serie, serieIndex) => {\r\n                        if (serie.xProperty && serie.yProperty && serie.color) {\r\n                            return this.getLineChart(node, serie.xProperty, serie.yProperty, payload, index, payloads, serie.color, serieIndex, serie.title || \"\", serie.fill || \"\", minmax);\r\n                        }\r\n                        return null;\r\n                    });\r\n                }\r\n                else if (node.xProperty && node.yProperty) {\r\n                    circle = this.getLineChart(node, node.xProperty, node.yProperty, payload, index, payloads, node.color || \"#000000\", 0, node.lineTitle || \"\", node.fill || \"\", minmax);\r\n                }\r\n                return circle;\r\n            });\r\n        }\r\n        const yAdd = 6;\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Stage, { pixelRatio: 1, width: (this.props.node.width || 250) + 1, height: height },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Layer, null,\r\n                    circles,\r\n                    this.getCurrentDebugNotifier())),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"xy-canvas__legend\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"xy-canvas__text\" },\r\n                    \"min: \", (_a = minmax.min) === null || _a === void 0 ? void 0 :\r\n                    _a.toFixed(2)),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"xy-canvas__text\" },\r\n                    \"max: \", (_b = minmax.max) === null || _b === void 0 ? void 0 :\r\n                    _b.toFixed(2))));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/html-plugins/visualizers/xy-canvas.tsx?");

/***/ })

}]);