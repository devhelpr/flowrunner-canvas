/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["flowcanvaswebpackJsonpPlugin"] = self["flowcanvaswebpackJsonpPlugin"] || []).push([["src_components_html-plugins_visualizers_xy-canvas_tsx"],{

/***/ "./src/components/html-plugins/visualizers/xy-canvas.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XYCanvas\": () => (/* binding */ XYCanvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react-konva/es/ReactKonva.js\");\n\n\nconst heightCorrection = 42;\nclass XYCanvas extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super(...arguments);\n        this.state = {};\n        this.getCurrentDebugNotifier = () => {\n            if (this.props.selectedNode && this.props.selectedNode.node) {\n                let selectedNodePayload = this.props.selectedNode.payload;\n                if (selectedNodePayload) {\n                    if (!selectedNodePayload.nodeExecutionId) {\n                        return null;\n                    }\n                    let nodeExecutions = this.props.flowrunnerConnector.getNodeExecutions();\n                    let executionIndex = -1;\n                    nodeExecutions.map((nodeExec, index) => {\n                        if (nodeExec && nodeExec.payload && nodeExec.payload.nodeExecutionId == selectedNodePayload.nodeExecutionId) {\n                            executionIndex = index;\n                        }\n                    });\n                    if (executionIndex >= 0) {\n                        let isFound = false;\n                        let resultPayloadIndex = -1;\n                        let loop = executionIndex;\n                        while (loop >= 0) {\n                            let index = loop;\n                            let nodeExec = nodeExecutions[loop];\n                            if (!isFound && index <= executionIndex) {\n                                this.props.payloads.map((payload, payloadIndex) => {\n                                    if (!isFound && payload && nodeExec.payload && payload.debugId == nodeExec.payload.debugId) {\n                                        isFound = true;\n                                        resultPayloadIndex = payloadIndex;\n                                    }\n                                });\n                            }\n                            loop--;\n                        }\n                        if (resultPayloadIndex >= 0) {\n                            let height = (this.props.node.height || 250) - heightCorrection;\n                            let width = (this.props.node.width || 250);\n                            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: [resultPayloadIndex, 0,\n                                    resultPayloadIndex,\n                                    height\n                                ], tension: 0, closed: true, stroke: \"#3f51b5\", strokeWidth: 2 });\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n        this.getMinMax = (payloads, series, height, node) => {\n            let result = {\n                min: undefined,\n                max: undefined,\n                ratio: 1,\n                correction: 0\n            };\n            payloads.map((payload) => {\n                series.map((serie) => {\n                    if (payload[serie.yProperty]) {\n                        if (result.min === undefined || payload[serie.yProperty] < result.min) {\n                            result.min = payload[serie.yProperty];\n                        }\n                        if (result.max === undefined || payload[serie.yProperty] > result.max) {\n                            result.max = payload[serie.yProperty];\n                        }\n                    }\n                });\n            });\n            if (node.minValue !== undefined) {\n                result.min = result.min !== undefined && node.minValue > result.min ? result.min : node.minValue;\n            }\n            if (node.maxValue !== undefined) {\n                result.max = result.max !== undefined && node.maxValue < result.max ? result.max : node.maxValue;\n            }\n            if (result.min !== undefined && result.max !== undefined) {\n                if (result.max - result.min != 0 && height != 0) {\n                    result.ratio = 1 / ((result.max - result.min) / (height - 2));\n                }\n                if (result.min < 0) {\n                    result.correction = -(result.min * result.ratio) + 1;\n                }\n                else {\n                    result.correction = -(result.min * result.ratio) + 1;\n                }\n            }\n            return result;\n        };\n        this.getLineChart = (node, xProperty, yProperty, payload, index, payloads, color, serieIndex, title, fill, minmax) => {\n            let circle = null;\n            let height = (this.props.node.height || 250) - heightCorrection;\n            let xPosition = index;\n            if (payloads.length < 250) {\n                xPosition = index + (250 - payloads.length);\n            }\n            if ((xProperty == \"index\" || !isNaN(payload[xProperty])) &&\n                !isNaN(payload[yProperty])) {\n                let x = 0;\n                if (xProperty == \"index\") {\n                    x = xPosition;\n                }\n                else {\n                    x = payload[xProperty];\n                }\n                let y = 2 + ((height - 2) - ((payload[yProperty] * minmax.ratio) + (minmax.correction)));\n                let xNext = 0;\n                let yNext = 0;\n                if (!!node.includeLines && (index < payloads.length - 1)) {\n                    if (xProperty == \"index\") {\n                        xNext = xPosition + 1;\n                    }\n                    else {\n                        xNext = payloads[index + 1][xProperty];\n                    }\n                    yNext = 2 + ((height - 2) - ((payloads[index + 1][yProperty] * minmax.ratio) + (minmax.correction)));\n                }\n                circle = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: \"xycanvas-wrapper-\" + index + \"-\" + serieIndex },\n                    !node.includeLines &&\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle, { key: \"xycanvas-\" + index + \"-\" + serieIndex, x: x, y: y, radius: 4, stroke: color, strokeWidth: 2, width: 4, height: 4, fill: color, perfectDrawEnabled: true }),\n                    fill !== \"\" && !!node.includeLines && (index < payloads.length - 1) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: [x, y,\n                            xNext,\n                            yNext,\n                            xNext, height,\n                            x, height\n                        ], tension: 0, closed: true, strokeWidth: 1, fill: fill }),\n                    !!node.includeLines && (index < payloads.length - 1) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: [x, y,\n                            xNext,\n                            yNext\n                        ], tension: 0, closed: true, stroke: color, strokeWidth: 1 }),\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Label, { x: 4, y: serieIndex * 24 },\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, { text: title, fontSize: 18, align: 'left', height: 24, verticalAlign: \"middle\", listening: false, wrap: \"none\", ellipsis: true, fill: color, perfectDrawEnabled: true })));\n            }\n            return circle;\n        };\n        this.getCurved = (node, xProperty, yProperty, payloads, minmax) => {\n            let height = (this.props.node.height || 250) - heightCorrection;\n            let points = [];\n            payloads.map((payload, index) => {\n                if (index % (node.sample || 10) == 0) {\n                    if ((xProperty == \"index\" || !isNaN(payload[xProperty])) &&\n                        !isNaN(payload[yProperty])) {\n                        let xPosition = index;\n                        if (payloads.length < 250) {\n                            xPosition = index + (250 - payloads.length);\n                        }\n                        let x = 0;\n                        if (xProperty == \"index\") {\n                            x = xPosition;\n                        }\n                        else {\n                            x = payload[xProperty];\n                        }\n                        let y = 2 + ((height - 2) - ((payload[yProperty] * minmax.ratio) + (minmax.correction)));\n                        points.push(x);\n                        points.push(y);\n                    }\n                }\n            });\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, { points: points, stroke: \"#000000\", bezier: true, strokeWidth: 1 });\n        };\n    }\n    componentDidMount() {\n    }\n    render() {\n        var _a, _b;\n        let height = (this.props.node.height || 250) - heightCorrection;\n        let circles = null;\n        const { node, payloads } = this.props;\n        let minmax = this.getMinMax(payloads, node.series ? node.series : [{ xProperty: node.xProperty, yProperty: node.yProperty }], height, this.props.node);\n        if (!!node.showCurved) {\n            circles = this.getCurved(node, node.xProperty, node.yProperty, payloads, minmax);\n        }\n        else {\n            circles = payloads.map((payload, index) => {\n                let circle = null;\n                if (node.series) {\n                    circle = node.series.map((serie, serieIndex) => {\n                        if (serie.xProperty && serie.yProperty && serie.color) {\n                            return this.getLineChart(node, serie.xProperty, serie.yProperty, payload, index, payloads, serie.color, serieIndex, serie.title || \"\", serie.fill || \"\", minmax);\n                        }\n                        return null;\n                    });\n                }\n                else if (node.xProperty && node.yProperty) {\n                    circle = this.getLineChart(node, node.xProperty, node.yProperty, payload, index, payloads, node.color || \"#000000\", 0, node.lineTitle || \"\", node.fill || \"\", minmax);\n                }\n                return circle;\n            });\n        }\n        const yAdd = 6;\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Stage, { pixelRatio: 1, width: (this.props.node.width || 250) + 1, height: height },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Layer, null,\n                    circles,\n                    this.getCurrentDebugNotifier())),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"xy-canvas__legend\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"xy-canvas__text\" },\n                    \"min: \", (_a = minmax.min) === null || _a === void 0 ? void 0 :\n                    _a.toFixed(2)),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"xy-canvas__text\" },\n                    \"max: \", (_b = minmax.max) === null || _b === void 0 ? void 0 :\n                    _b.toFixed(2))));\n    }\n}\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/html-plugins/visualizers/xy-canvas.tsx?");

/***/ })

}]);