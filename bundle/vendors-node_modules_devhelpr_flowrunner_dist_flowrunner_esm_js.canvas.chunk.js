/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["flowcanvaswebpackJsonpPlugin"] = self["flowcanvaswebpackJsonpPlugin"] || []).push([["vendors-node_modules_devhelpr_flowrunner_dist_flowrunner_esm_js"],{

/***/ "./node_modules/@devhelpr/flowrunner/dist/flowrunner.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FlowEventRunner\": () => (/* binding */ FlowEventRunner),\n/* harmony export */   \"FlowTask\": () => (/* binding */ FlowTask),\n/* harmony export */   \"FlowTaskPackageType\": () => (/* binding */ FlowTaskPackageType),\n/* harmony export */   \"HumanFlowToMachineFlow\": () => (/* binding */ HumanFlowToMachineFlow),\n/* harmony export */   \"ObservableTask\": () => (/* binding */ ObservableTask)\n/* harmony export */ });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/observable/interval.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Observable.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/uuid/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/operators/throttle.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/operators/sampleTime.js\");\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar DEFAULT_NODE = 0;\nvar HTTP_ENDPOINT_NODE = 1;\nvar HTTP_OUTPUT_NODE = 2;\nvar HTTP_REDIRECT_NODE = 3;\nvar DEPENDENCY = 4;\nvar FUNCTION_NODE = 5;\nvar FUNCTION_INPUT_NODE = 6;\nvar FUNCTION_OUTPUT_NODE = 7;\nvar MODEL_NODE = 8;\nvar FORWARD_NODE = 9;\nvar PARALLEL_NODE = 10;\nvar PARALLEL_RESOLVE_NODE = 11;\n\nvar FlowTaskPackageType = {\n  __proto__: null,\n  DEFAULT_NODE: DEFAULT_NODE,\n  HTTP_ENDPOINT_NODE: HTTP_ENDPOINT_NODE,\n  HTTP_OUTPUT_NODE: HTTP_OUTPUT_NODE,\n  HTTP_REDIRECT_NODE: HTTP_REDIRECT_NODE,\n  DEPENDENCY: DEPENDENCY,\n  FUNCTION_NODE: FUNCTION_NODE,\n  FUNCTION_INPUT_NODE: FUNCTION_INPUT_NODE,\n  FUNCTION_OUTPUT_NODE: FUNCTION_OUTPUT_NODE,\n  MODEL_NODE: MODEL_NODE,\n  FORWARD_NODE: FORWARD_NODE,\n  PARALLEL_NODE: PARALLEL_NODE,\n  PARALLEL_RESOLVE_NODE: PARALLEL_RESOLVE_NODE\n};\n\nvar FlowEventRunnerHelper = /*#__PURE__*/function () {\n  function FlowEventRunnerHelper() {}\n\n  FlowEventRunnerHelper.registerNode = function registerNode(node, pluginInstance, services, flowNodeRegisterHooks) {\n    services.logMessage('REGISTRATE ' + node.name);\n    var nodeInstance = Object.assign({}, node);\n\n    if (pluginInstance !== undefined) {\n      flowNodeRegisterHooks.map(function (hook) {\n        if (hook(node, pluginInstance)) {\n          return true;\n        }\n\n        return true;\n      });\n      var result = pluginInstance.execute(nodeInstance, services, {});\n\n      if (typeof result === 'object' && typeof result.then === 'function') {\n        result.then(function (payload) {\n          services.registerModel(node.modelname, payload.modelDefinition);\n        });\n      }\n    }\n  };\n\n  return FlowEventRunnerHelper;\n}();\n\nFlowEventRunnerHelper.callMiddleware = function (middleware, result, id, title, nodeType, payload, dateTime) {\n  var cleanPayload = Object.assign({}, payload);\n  cleanPayload.request = undefined;\n  cleanPayload.response = undefined;\n  middleware.map(function (middlewareFunction) {\n    middlewareFunction(result, id, title, nodeType, cleanPayload, dateTime);\n    return true;\n  });\n  return;\n};\n\nFlowEventRunnerHelper.getNodeInjections = function (injections, nodeList) {\n  var nodeInjections = [];\n  injections.map(function (nodeRelation) {\n    nodeList.map(function (node) {\n      if (node.id === nodeRelation.startshapeid) {\n        nodeInjections.push(node);\n      }\n\n      return true;\n    });\n    return true;\n  });\n  return nodeInjections;\n};\n\nFlowEventRunnerHelper.getManuallyToFollowNodes = function (manuallyToFollowNodes, nodeList) {\n  return nodeList.filter(function (node) {\n    return typeof manuallyToFollowNodes.find(function (o) {\n      return o.endshapeid === node.id.toString();\n    }) !== 'undefined';\n  });\n};\n\nFlowEventRunnerHelper.getInjections = function (injectIntoNodeId, nodeList, nodeTypes) {\n  var injections = [];\n  var nodeInjections = nodeList.filter(function (o) {\n    return o.endshapeid === injectIntoNodeId && o.taskType === 'connection' && o.followflow === 'injectConfigIntoPayload';\n  });\n  nodeInjections.map(function (nodeRelation) {\n    nodeList.map(function (node) {\n      if (node.id === nodeRelation.startshapeid) {\n        var nodeType = nodeTypes[node.taskType];\n\n        if (typeof nodeType !== 'undefined') {\n          var nodeInstance = Object.assign({}, node);\n          nodeInstance.payload = {};\n          var pluginInstance = new nodeType.pluginClass();\n          injections.push({\n            pluginInstance: pluginInstance,\n            node: node\n          });\n          /*\r\n                        let result = nodeType.pluginInstance.execute(nodeInstance, _services);\r\n                                       if (typeof result == \"object\" && typeof result.then == \"function\") {\r\n                            result.then((payload) => {\r\n                                \n                                for (var key in payload) {\r\n                                    if (!payload.hasOwnProperty(key)) {\r\n                                        continue;\r\n                                    }\r\n                                    injections[key] = payload[key];\r\n                                }\r\n                            })\r\n                            .catch((err) => {\r\n                                console.log(\"injection promise failed\",err)\r\n                            })\r\n                        } else if (typeof result == \"object\") {\r\n                            for (var key in result) {\r\n                                if (!result.hasOwnProperty(key)) {\r\n                                    continue;\r\n                                }\r\n                                injections[key] = result[key];\r\n                            }\r\n                        }\r\n                        */\n        }\n      }\n\n      return true;\n    });\n    return true;\n  });\n  return injections;\n};\n\nvar BuildNodeInfoHelper = /*#__PURE__*/function () {\n  function BuildNodeInfoHelper() {}\n\n  BuildNodeInfoHelper.build = function build(nodeList, node, nodePluginInfoMap, services) {\n    return {\n      dontAutostart: node.dontAutostart,\n      error: nodeList.filter(function (o) {\n        return o.startshapeid === node.id.toString() && o.taskType === 'connection' && o.followflow === 'onfailure';\n      }),\n      // TODO : hier direct de nodes uitlezen en de variabelen die geinjecteerd moeten\n      // worden toevoegen\n      injections: FlowEventRunnerHelper.getInjections(node.id.toString(), nodeList, nodePluginInfoMap),\n      inputs: nodeList.filter(function (o) {\n        return o.endshapeid === node.id.toString() && o.taskType === 'connection' && o.followflow !== 'followManually' && o.followflow !== 'injectConfigIntoPayload';\n      }),\n      manuallyToFollowNodes: FlowEventRunnerHelper.getManuallyToFollowNodes(nodeList.filter(function (o) {\n        return o.startshapeid === node.id.toString() && o.taskType === 'connection' && o.followflow === 'followManually';\n      }), nodeList),\n      name: node.name,\n      nodeId: node.id,\n      outputs: nodeList.filter(function (o) {\n        return o.startshapeid === node.id.toString() && o.taskType === 'connection' && o.followflow !== 'onfailure' && o.followflow !== 'followManually' && o.followflow !== 'injectConfigIntoPayload';\n      }).map(function (connection) {\n        // todo check activationFunction and attach it here\n        if (connection.activationFunction && services.getActivationFunction) {\n          connection.activationFunction = services.getActivationFunction(connection.activationFunction);\n        }\n\n        return connection;\n      }),\n      pluginInstance: undefined,\n      title: node.title\n    };\n  };\n\n  return BuildNodeInfoHelper;\n}();\n\nvar uuidV4 = uuid__WEBPACK_IMPORTED_MODULE_0__.v4;\nvar parallelSessions = {};\nvar doesConnectionEmit = function doesConnectionEmit(connectionNode, node, payload, eventName) {\n  var result = true;\n\n  if (connectionNode.event !== undefined && connectionNode.event !== '') {\n    if (eventName !== undefined && connectionNode.event === eventName) {\n      return true;\n    }\n\n    return false;\n  } else if (connectionNode.tagPropertyFromPayload && connectionNode.tag) {\n    result = connectionNode.tag === payload[connectionNode.tagPropertyFromPayload];\n  }\n\n  if (connectionNode.tag && payload.tag) {\n    result = result && connectionNode.tag === payload.tag; // dont keep on passing tags via payload.. \"oneshot\"-only\n    // so also dont pass tags on payload to functions\n\n    delete payload.tag;\n  }\n\n  if (connectionNode.tag && node.tag) {\n    result = result && connectionNode.tag === node.tag;\n  } // TODO : check flowPath ... compare also using callstack?\n  // QUESTION : instead of using flowPathPropertyFromPayload .. always use \"flowPath\" as name in payload?\n  // .. why not both .. this allows more flexibility .. see above using tags\n  // REQUIREMENT if a node.payload has a flowPath, then dont follow the\n  //   connections without a flowPath when the payload contains a flowPath\n  //   ... dont pass flowPath to functions (remember it in the callstack)\n\n\n  if (connectionNode.flowPath) {\n    if (!payload.flowPath) {\n      return false;\n    }\n\n    result = result && connectionNode.flowPath === payload.flowPath;\n  }\n\n  if (connectionNode.activationThreshold && !isNaN(connectionNode.activationThreshold)) {\n    if (connectionNode.activationProperty && payload[connectionNode.activationProperty]) {\n      return payload[connectionNode.activationProperty] >= connectionNode.activationThreshold;\n    }\n\n    return false;\n  }\n\n  if (connectionNode.activationFunction) {\n    if (typeof connectionNode.activationFunction !== 'function') {\n      return false;\n    }\n\n    return connectionNode.activationFunction(connectionNode, payload);\n  }\n\n  return result;\n};\nvar EmitOutput = /*#__PURE__*/function () {\n  function EmitOutput() {}\n\n  EmitOutput.emitToOutputs = function emitToOutputs(nodePluginInfo, nodeEmitter, nodeInfo, currentNodeInstance, currentCallStack, flowEventRunner, eventName) {\n    var followFlow = '';\n\n    if (typeof currentNodeInstance.payload.followFlow !== 'undefined' && currentNodeInstance.payload.followFlow) {\n      currentNodeInstance.payload._forwardFollowFlow = currentNodeInstance.payload.followFlow;\n    }\n\n    if (nodePluginInfo.pluginInstance.getPackageType() === FUNCTION_OUTPUT_NODE) {\n      // HANDLE FUNCTION OUTPUT/RESULT\n      var newPayload = Object.assign({}, currentNodeInstance.payload);\n      delete newPayload.followFlow;\n\n      if (currentNodeInstance.resultProperties) {\n        newPayload = {};\n        currentNodeInstance.resultProperties.map(function (resultProperty) {\n          newPayload[resultProperty] = currentNodeInstance.payload[resultProperty];\n          return true;\n        });\n      } else if (currentNodeInstance.resultProperty) {\n        var _newPayload;\n\n        newPayload = (_newPayload = {}, _newPayload[currentNodeInstance.resultProperty] = newPayload[currentNodeInstance.resultProperty], _newPayload);\n      } else {\n        newPayload = {};\n      }\n\n      if (currentCallStack.flowPath) {\n        newPayload.flowPath = currentCallStack.flowPath;\n      }\n\n      if (currentCallStack.tag) {\n        newPayload.tag = currentCallStack.tag;\n      }\n      /*\r\n        DONT FIRE error nodes .. only return with resultProperty\r\n        \n        TODO : think if we need this under some circumstances\r\n              .. it can have a need..\r\n             */\n\n\n      if (!currentNodeInstance.resultProperties && !currentNodeInstance.resultProperty && typeof currentNodeInstance.payload.followFlow !== 'undefined' && currentNodeInstance.payload.followFlow) {\n        followFlow = currentNodeInstance.payload.followFlow;\n\n        if (followFlow === 'isError') {\n          if (typeof currentCallStack.error !== 'undefined') {\n            var upperCallStack = currentCallStack.callStack;\n            currentCallStack.error.map(function (outputNode) {\n              flowEventRunner.touchedNodes[outputNode.name] = true;\n              nodeEmitter.emit(outputNode.endshapeid.toString(), _extends({}, upperCallStack.newPayload, newPayload), upperCallStack);\n              return true;\n            });\n          }\n\n          return;\n        }\n      }\n\n      if (typeof currentCallStack.outputs !== 'undefined') {\n        var _upperCallStack = currentCallStack.callStack;\n        var nodeWasEmitted = false;\n        currentCallStack.outputs.map(function (nodeOutput) {\n          if (doesConnectionEmit(nodeOutput, currentNodeInstance, newPayload, eventName)) {\n            nodeWasEmitted = true;\n            flowEventRunner.touchedNodes[nodeOutput.name] = true;\n            nodeEmitter.emit(nodeOutput.endshapeid.toString(), _extends({}, currentCallStack.payload, newPayload), _upperCallStack);\n          }\n\n          return true;\n        });\n\n        if (!nodeWasEmitted || currentCallStack.outputs.length === 0) {\n          if (_upperCallStack.outputs !== undefined) {\n            _upperCallStack.outputs.map(function (outputNode) {\n              flowEventRunner.touchedNodes[outputNode.name] = true;\n              nodeEmitter.emit(outputNode.endshapeid.toString(), _extends({}, _upperCallStack.payload, newPayload), _upperCallStack.callStack);\n              return true;\n            });\n          }\n        }\n      }\n    } else if (nodePluginInfo.pluginInstance.getPackageType() === FUNCTION_NODE) {\n      // CALL FUNCTION NODE\n      var newCallStack = {\n        callStack: currentCallStack,\n        callStackType: 'FUNCTION',\n        error: nodeInfo.error,\n        flowPath: currentNodeInstance.payload.flowPath,\n        outputs: nodeInfo.outputs,\n        payload: currentNodeInstance.payload,\n        returnNodeId: currentNodeInstance.id,\n        tag: currentNodeInstance.payload.tag\n      };\n\n      if (currentNodeInstance.payload.flowPath) {\n        delete currentNodeInstance.payload.flowPath;\n      }\n\n      if (currentNodeInstance.payload.tag) {\n        delete currentNodeInstance.payload.tag;\n      } // TODO : check if functionnode needs \"doesConnectionFire\"\n\n\n      nodeEmitter.emit(currentNodeInstance.functionnodeid.toString(), currentNodeInstance.payload, newCallStack);\n    } else {\n      if (typeof currentNodeInstance.payload.followFlow !== 'undefined' && currentNodeInstance.payload.followFlow) {\n        // Handle error flow\n        followFlow = currentNodeInstance.payload.followFlow;\n\n        if (followFlow === 'isError') {\n          if (nodePluginInfo.pluginInstance.getPackageType() !== FORWARD_NODE) {\n            currentNodeInstance.payload.followFlow = undefined;\n            delete currentNodeInstance.payload.followFlow;\n          }\n\n          EmitOutput.emitToError(nodePluginInfo, nodeEmitter, nodeInfo, currentNodeInstance, currentCallStack, flowEventRunner);\n          return;\n        }\n      }\n\n      if (nodePluginInfo.pluginInstance.getPackageType() !== FORWARD_NODE) {\n        currentNodeInstance.payload.followFlow = undefined;\n      }\n\n      delete currentNodeInstance.payload.errors; // Handle parallel sessions\n\n      if (nodePluginInfo.pluginInstance.getPackageType() === PARALLEL_NODE && nodeInfo.outputs.length > 0) {\n        currentNodeInstance.payload._parallelSessionId = uuidV4();\n        currentNodeInstance.payload._parallelCount = nodeInfo.outputs.length;\n        parallelSessions[currentNodeInstance.payload._parallelSessionId] = {\n          nodeCount: nodeInfo.outputs.length\n        };\n      }\n\n      if (nodePluginInfo.pluginInstance.getPackageType() === PARALLEL_RESOLVE_NODE) {\n        var parallelSessionId = currentNodeInstance.payload._parallelSessionId;\n        var parallelSessionCount = parallelSessions[parallelSessionId].nodeCount - 1;\n        parallelSessions[parallelSessionId].nodeCount = parallelSessionCount;\n\n        if (parallelSessions[parallelSessionId].payloads === undefined) {\n          parallelSessions[parallelSessionId].payloads = [];\n        }\n\n        delete currentNodeInstance.payload._parallelSessionId;\n        delete currentNodeInstance.payload._parallelCount;\n        parallelSessions[parallelSessionId].payloads.push(Object.assign({}, currentNodeInstance.payload)); // TODO : test merge payloads\n        // TODO : how handle emitError?\n        // TODO : handle multiple parallel session (parallel session within parallel session)\n        //        - use inputs as count instead of outputs?\n\n        if (parallelSessionCount > 0) {\n          return;\n        }\n\n        currentNodeInstance.payload = {}; // currentNodeInstance.payload.payloads = parallelSessions[parallelSessionId].payloads;\n\n        currentNodeInstance.payload = Object.assign.apply(Object, [{}].concat(parallelSessions[parallelSessionId].payloads));\n        delete parallelSessions[parallelSessionId];\n      }\n\n      var _nodeWasEmitted = false; // CALL connected output nodes\n\n      nodeInfo.outputs.map(function (nodeOutput) {\n        if (followFlow === '' || followFlow !== '' && nodeOutput.name === followFlow) {\n          // QUESTION: Does this causes memory issues?\n          var payload = _extends({}, currentNodeInstance.payload);\n\n          if (doesConnectionEmit(nodeOutput, currentNodeInstance, payload, eventName)) {\n            _nodeWasEmitted = true;\n            flowEventRunner.touchedNodes[nodeOutput.name] = true; // check if connection has controller\n            // - controllers are only supported on direct connections from node to node\n            //   ... so not yet on functions (although that would be useful as well)\n            // -\n            //\n\n            if (nodeOutput.controllerName) {\n              nodeEmitter.emitToController(nodeOutput.endshapeid.toString(), nodeOutput.controllerName, payload, currentCallStack);\n            } else {\n              nodeEmitter.emit(nodeOutput.endshapeid.toString(), payload, currentCallStack);\n            }\n          }\n        }\n\n        return true;\n      }); // call output nodes on callstack if node has no outputs\n\n      if (!_nodeWasEmitted || nodeInfo.outputs.length === 0 && typeof currentCallStack.outputs !== 'undefined') {\n        if (currentCallStack && currentCallStack.callStackType === 'FUNCTION') {\n          // DONT call output node if in function... only fire function output node\n          return;\n        }\n\n        if (currentCallStack) {\n          var _upperCallStack2 = currentCallStack.callStack;\n\n          if (_upperCallStack2 === undefined) {\n            _upperCallStack2 = {};\n          }\n\n          if (!!currentCallStack['_executeNode']) {\n            _upperCallStack2['_executeNode'] = true;\n          }\n\n          var _newPayload2 = Object.assign({}, currentNodeInstance.payload);\n\n          delete _newPayload2.followFlow;\n\n          if (currentCallStack.outputs) {\n            currentCallStack.outputs.map(function (outputNode) {\n              flowEventRunner.touchedNodes[outputNode.name] = true; // todo : double check if this needs doesConnectionEmit\n\n              nodeEmitter.emit(outputNode.endshapeid.toString(), _newPayload2, _upperCallStack2);\n              return true;\n            });\n          }\n        }\n      }\n    }\n  };\n\n  EmitOutput.emitToError = function emitToError(nodeType, nodeEmitter, nodeInfo, currentNodeInstance, currentCallStack, flowEventRunner) {\n    if (nodeType.pluginInstance.getPackageType() === FUNCTION_OUTPUT_NODE) {\n      var newPayload = Object.assign({}, currentNodeInstance.payload);\n\n      if (typeof newPayload.followFlow !== 'undefined' && newPayload.followFlow) {\n        newPayload._forwardFollowFlow = newPayload.followFlow;\n      } // delete _payload._functionOutputs;\n      // delete _payload._functionErrorOutputs;\n\n\n      delete newPayload.followFlow;\n      var upperCallStack = currentCallStack.callStack;\n      currentCallStack.error.map(function (currentNode) {\n        nodeEmitter.emit(currentNode.endshapeid.toString(), newPayload, upperCallStack);\n        return true;\n      });\n    } else {\n      if (typeof currentNodeInstance.payload.followFlow !== 'undefined' && currentNodeInstance.payload.followFlow) {\n        currentNodeInstance.payload._forwardFollowFlow = currentNodeInstance.payload.followFlow;\n      }\n\n      nodeInfo.error.map(function (currentNode) {\n        flowEventRunner.touchedNodes[currentNode.name] = true;\n        nodeEmitter.emit(currentNode.endshapeid.toString(), currentNodeInstance.payload, currentCallStack);\n        return true;\n      });\n\n      if (nodeInfo.error.length === 0 && typeof currentCallStack.error !== 'undefined') {\n        var _upperCallStack3 = currentCallStack.callStack;\n\n        if (_upperCallStack3 === undefined) {\n          _upperCallStack3 = {};\n        }\n\n        if (!!currentCallStack['_executeNode']) {\n          _upperCallStack3['_executeNode'] = true;\n        }\n\n        var _newPayload3 = Object.assign({}, currentNodeInstance.payload);\n\n        delete _newPayload3.followFlow;\n        currentCallStack.error.map(function (outputNode) {\n          flowEventRunner.touchedNodes[outputNode.name] = true;\n          nodeEmitter.emit(outputNode.endshapeid.toString(), _newPayload3, _upperCallStack3);\n          return true;\n        });\n      }\n    }\n  };\n\n  return EmitOutput;\n}();\n\nvar InjectionHelper = /*#__PURE__*/function () {\n  function InjectionHelper() {}\n\n  InjectionHelper.executeInjections = function executeInjections(node, nodeInfo, injectionValues, payload, services, callStack, middleware) {\n    var injectionPromises = [];\n    nodeInfo.injections.map(function (nodeInjection) {\n      var nodeInstance = Object.assign({}, nodeInjection.node);\n      nodeInstance.payload = Object.assign({}, payload);\n      var result = nodeInjection.pluginInstance.execute(nodeInstance, services, callStack);\n\n      if (typeof result === 'object' && typeof result.then === 'function') {\n        result.then(function (payloadResult) {\n          payloadResult.response = null;\n          payloadResult.request = null;\n          FlowEventRunnerHelper.callMiddleware(middleware, 'injection', nodeInstance.id, nodeInstance.name, node.taskType, payloadResult, new Date());\n\n          for (var property in payloadResult) {\n            if (typeof payloadResult[property] === 'undefined' || payloadResult[property] === null) {\n              continue;\n            }\n\n            if (!payloadResult.hasOwnProperty(property)) {\n              continue;\n            }\n\n            injectionValues[property] = payloadResult[property];\n          }\n        })[\"catch\"](function (err) {\n          throw new Error(err);\n        });\n      } else if (typeof result === 'object') {\n        FlowEventRunnerHelper.callMiddleware(middleware, 'injection', nodeInstance.id, nodeInstance.name, node.taskType, payload, new Date());\n\n        for (var property in result) {\n          if (!result.hasOwnProperty(property)) {\n            continue;\n          }\n\n          injectionValues[property] = result[property];\n        }\n      }\n\n      injectionPromises.push(result);\n      return true;\n    });\n    return injectionPromises;\n  };\n\n  return InjectionHelper;\n}();\n\n/*\r\n\n  TODO :\r\n    - add support for blocking flow until condition is met\r\n    - only run node's within lock Context\r\n\n    - use special rxjs observable which should be used together with buffer or something similar\r\n          https://www.learnrxjs.io/learn-rxjs/operators/transformation/buffer\r\n\n\n*/\n\nvar ReactiveEventEmitter = /*#__PURE__*/function () {\n  function ReactiveEventEmitter() {\n    var _this = this;\n\n    this.isPaused = false;\n    this.sample = 30;\n    this.throttle = 30;\n    this.nodesListeners = {};\n    this.subjects = {};\n    this.subscriptions = {};\n    this.nodesControllers = {};\n\n    this.suspendUntilLock = function (_lockID) {};\n\n    this.liftLock = function (_lockID) {};\n\n    this.pauseFlowrunner = function () {\n      _this.isPaused = true;\n    };\n\n    this.resumeFlowrunner = function () {\n      _this.isPaused = false;\n    };\n\n    this.on = function (nodeName, listener, options) {\n      if (typeof _this.nodesListeners[nodeName] !== 'object') {\n        _this.nodesListeners[nodeName] = [];\n      }\n\n      _this.nodesListeners[nodeName].push(listener);\n\n      if (typeof _this.subjects[nodeName] !== 'object') {\n        var subject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        _this.subjects[nodeName] = subject;\n        var self = _this;\n        var subjectToSubscribe = _this.subjects[nodeName];\n\n        if (options) {\n          if (options.isThrottling) {\n            subjectToSubscribe = subjectToSubscribe.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.throttle)(function (_val) {\n              return (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.interval)(options.throttleInterval || _this.throttle);\n            }));\n          }\n\n          if (options.isSampling) {\n            subjectToSubscribe = subjectToSubscribe.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.sampleTime)(options.sampleInterval || _this.sample));\n          }\n        }\n\n        _this.subscriptions[nodeName] = subjectToSubscribe.subscribe({\n          next: function next(data) {\n            if (typeof self.nodesListeners[nodeName] === 'object') {\n              var length = self.nodesListeners[nodeName].length; // TODO: fix this... feels hacky and not \"as expected\"\n              //  .. see the emit method with its ...args parameter\n              //  .. make that \"as expected\"\n              // let payload = data.length > 0 && {...data[0]};\n              // let callStack =  data.length > 1 && {...data[1]};\n              // console.log(\"DATA:\" , data, \"PAYLOAD:\", payload, \"CALLSTACK: \" , callStack);\n\n              var payloadInstance = _extends({}, data.payload);\n\n              var callstackInstance = _extends({}, data.callstack);\n\n              for (var i = 0; i < length; i++) {\n                self.nodesListeners[nodeName][i](payloadInstance, callstackInstance);\n              }\n\n              payloadInstance = null;\n              callstackInstance = null;\n            }\n          }\n        });\n      }\n    };\n\n    this.removeListener = function (nodeName) {\n      if (_this.subjects[nodeName] && _this.subscriptions[nodeName]) {\n        _this.subscriptions[nodeName].unsubscribe();\n\n        _this.subscriptions[nodeName] = null;\n        delete _this.subscriptions[nodeName];\n\n        _this.subjects[nodeName].complete();\n\n        _this.subjects[nodeName] = null;\n        delete _this.subjects[nodeName];\n      } // if (typeof this.nodesListeners[nodeName] === 'object') {\n      //  this.nodesListeners[nodeName] = [];\n      // }\n\n\n      _this.nodesListeners[nodeName] = null;\n      delete _this.nodesListeners[nodeName];\n    };\n\n    this.emit = function (nodeName, payload, callstack) {\n      if (!!_this.isPaused && callstack['_executeNode'] === undefined) {\n        // if in executeNode.. then finish that run of the flow before pausing\n        // naive solution to pause the flow\n        // .. should we also pause observables?\n        return;\n      }\n\n      if (typeof _this.subjects[nodeName] === 'object') {\n        var subject$ = _this.subjects[nodeName];\n\n        var payloadInstance = _extends({}, payload);\n\n        var callstackInstance = _extends({}, callstack);\n\n        subject$.next({\n          payload: payloadInstance,\n          callstack: callstackInstance\n        });\n        subject$ = null;\n        payloadInstance = null;\n        callstackInstance = null;\n      }\n    };\n\n    this.emitToController = function (nodeName, controllerName, payload, currentCallstack) {\n      if (_this.nodesControllers[nodeName] && _this.nodesControllers[nodeName][controllerName]) {\n        var value = payload[controllerName];\n\n        var callStack = _extends({}, currentCallstack); // console.log (\"callStack:\", callStack, \"currentCallstack\", currentCallstack);\n\n\n        _this.nodesControllers[nodeName][controllerName].subject.next({\n          currentCallstack: callStack,\n          value: value\n        });\n\n        callStack = null;\n        value = null;\n      }\n    };\n  }\n\n  var _proto = ReactiveEventEmitter.prototype;\n\n  _proto.registerNodeControllers = function registerNodeControllers(node) {\n    var _this2 = this;\n\n    var controllerObservables = {};\n    node.controllers.map(function (controller) {\n      if (controller.name) {\n        var subject = new rxjs__WEBPACK_IMPORTED_MODULE_5__.BehaviorSubject({\n          name: controller.name,\n          value: controller.defaultValue || 0\n        });\n        controllerObservables[controller.name] = {\n          hasValue: false,\n          subject: subject,\n          value: controller.defaultValue || 0\n        };\n        var observerSubscription = {\n          complete: function complete() {// this.services.logMessage('Controller: Completed for ', node.name, controller.name);\n          },\n          error: function error(_err) {// this.services.logMessage('Controller: Error', node.name, controller.name, err);\n          },\n          next: function next(payload) {\n            var payloadInstance = payload;\n            var callstackInstance = payloadInstance.currentCallstack;\n\n            if (payloadInstance.value !== undefined) {\n              controllerObservables[controller.name].value = payloadInstance.value;\n              controllerObservables[controller.name].hasValue = true;\n              /*\r\n                only emit ..\r\n                  - if all controllerObservables have a value\r\n                then emit all value of all controllerObservables at once in a single payload\r\n              */\n\n              var sendPayload = {};\n              var emitToNode = true;\n              Object.keys(controllerObservables).map(function (key) {\n                emitToNode = emitToNode && controllerObservables[key].hasValue;\n                sendPayload[key] = payloadInstance[key];\n                return true;\n              });\n\n              if (!!emitToNode) {\n                _this2.emit(node.id.toString(), sendPayload, callstackInstance);\n              }\n            }\n\n            payloadInstance = null;\n            callstackInstance = null;\n          }\n        };\n        subject.subscribe(observerSubscription);\n      }\n\n      return true;\n    });\n\n    if (node.controllers.length > 0) {\n      this.nodesControllers[node.name] = controllerObservables;\n    }\n  };\n\n  _proto.getNodeControllerValue = function getNodeControllerValue(nodeName, controllerName) {\n    if (this.nodesControllers[nodeName] && this.nodesControllers[nodeName][controllerName]) {\n      return this.nodesControllers[nodeName][controllerName].value;\n    }\n\n    return;\n  };\n\n  return ReactiveEventEmitter;\n}();\n\nvar FlowTask = /*#__PURE__*/function () {\n  function FlowTask() {}\n\n  var _proto = FlowTask.prototype;\n\n  // only called when PackageType is FlowTaskPackageType.HTTP_ENDPOINT_NODE\n  //abstract executeAsHTTPEndpoint?(node: any, request: any, response: any) : any;\n  _proto.getName = function getName() {\n    return 'FlowTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'FlowTask';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return '';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'circle';\n  } // used for filtering\n  ;\n\n  _proto.getTaskType = function getTaskType() {\n    // both/frontend/backend/abstract .. #thought: replace \"both\" by something else\n    return '';\n  } // needed? used for filtering\n  ;\n\n  _proto.getCategory = function getCategory() {\n    return '';\n  } // needed? used for filtering\n  ;\n\n  _proto.getController = function getController() {\n    return 'CanvasController';\n  } // metadata for configurating stuff like url's etc\n  // stored on flowgroup level specific for a controller inheriting from canvascontroller\n  // - specific model is probably needed for this\n  ;\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [];\n  } // ??? needed ?? metadata used when executing a step\n  // it's unique for each step (stored together with the Node's data in database)\n  ;\n\n  _proto.getStepParametersMetaData = function getStepParametersMetaData() {\n    return [];\n  } // Wordt deze al gebruikt??? wellicht tbv \"Register plugin on init flow\"\n  //  - Registreren is nodig in frontendflowrunner voor reducers te registreren\n  //      en in backend voor model definitions tbv database\n  //     .. wordt voor HTTP_ENDPOINT_NODE in (Backend)FlowEventRunner wel gebruikt..\n  ;\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getInfo = function getInfo() {\n    return '';\n  };\n\n  _proto.getDefaultFollowFlow = function getDefaultFollowFlow() {\n    return '';\n  };\n\n  _proto.getDefaultRelationName = function getDefaultRelationName() {\n    return '';\n  };\n\n  _proto.getPayloadContract = function getPayloadContract() {\n    return [];\n  } // \"minimal\" , \"strict\"\n  ;\n\n  _proto.getPayloadContractMode = function getPayloadContractMode() {\n    return 'minimal';\n  };\n\n  _proto.getDefaultColor = function getDefaultColor() {\n    return '#000000';\n  };\n\n  _proto.isAttachedToExternalObservable = function isAttachedToExternalObservable() {\n    return false;\n  };\n\n  _proto.isAttachedToStoreChanges = function isAttachedToStoreChanges() {\n    return false;\n  };\n\n  _proto.isSampling = function isSampling(_node) {\n    return false;\n  };\n\n  _proto.isThrottling = function isThrottling() {\n    return false;\n  };\n\n  _proto.getDescription = function getDescription() {\n    return '{{{title}}}';\n  };\n\n  return FlowTask;\n}();\n\nvar replaceValues = function replaceValues(content, payload, keepUnknownFields) {\n  if (keepUnknownFields === void 0) {\n    keepUnknownFields = false;\n  }\n\n  var resultContent = content;\n  var matches = resultContent.match(/{.+?}/g);\n\n  if (matches) {\n    matches.map(function (match) {\n      var matchValue = match.slice(1, -1);\n      var splittedValues = matchValue.split(':');\n      var variableName = splittedValues[0];\n      var value = payload[variableName];\n\n      if (splittedValues.length > 1) {\n        var format = splittedValues[1];\n\n        if (format === 'currency') {\n          value = parseFloat(value).toFixed(2).replace('.', ',');\n        } else if (format === 'integer') {\n          value = parseFloat(value).toFixed(0);\n        }\n      } else if (!!keepUnknownFields && value === undefined) {\n        value = match;\n      }\n\n      var allOccurancesOfMatchRegex = new RegExp(match, 'g');\n      resultContent = resultContent.replace(allOccurancesOfMatchRegex, value);\n      return true;\n    });\n  }\n\n  return resultContent;\n};\n\nvar uuidV4$1 = uuid__WEBPACK_IMPORTED_MODULE_0__.v4;\nvar AssignTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(AssignTask, _FlowTask);\n\n  function AssignTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = AssignTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING AssignTask: ' + node.id + ' - ' + node.name);\n\n    try {\n      node.payload = Object.assign({}, node.payload);\n\n      if (node.assignAsPropertyFromObject !== undefined && node.assignAsPropertyFromObject !== '') {\n        if (node.payload[node.assignAsPropertyFromObject] === undefined) {\n          node.payload[node.assignAsPropertyFromObject] = {};\n        }\n      }\n\n      if (node.value !== undefined && (node.valueFromProperty === undefined || node.valueFromProperty === '')) {\n        var value = node.value;\n\n        if (value === '[UUID]') {\n          value = uuidV4$1().toString(); //} else if (value === '[NOW]') {\n          //value = moment().toISOString();\n        } else if (!!node.replaceValues) {\n          value = replaceValues(value, node.payload, false);\n        }\n\n        if (node.assignAsPropertyFromObject !== undefined && node.assignAsPropertyFromObject !== '') {\n          node.payload[node.assignAsPropertyFromObject][node.assignToProperty] = value;\n        } else {\n          node.payload[node.assignToProperty] = value;\n        }\n      } else if (node.valueFromProperty !== '') {\n        if (node.readFromObject !== undefined && node.readFromObject !== '') {\n          if (node.assignAsPropertyFromObject !== undefined && node.assignAsPropertyFromObject !== '') {\n            if (node.payload[node.readFromObject]) {\n              node.payload[node.assignAsPropertyFromObject][node.assignToProperty] = node.payload[node.readFromObject][node.valueFromProperty];\n            }\n          } else {\n            if (node.payload[node.readFromObject]) {\n              node.payload[node.assignToProperty] = node.payload[node.readFromObject][node.valueFromProperty];\n            }\n          }\n        } else if (node.assignAsPropertyFromObject !== undefined && node.assignAsPropertyFromObject !== '') {\n          node.payload[node.assignAsPropertyFromObject][node.assignToProperty] = node.payload[node.valueFromProperty];\n        } else {\n          node.payload[node.assignToProperty] = node.payload[node.valueFromProperty];\n        }\n      } else if (node.value === undefined || node.value === null || node.value === '' || !node.value) {\n        if (node.assignAsPropertyFromObject !== undefined && node.assignAsPropertyFromObject !== '') {\n          node.payload[node.assignAsPropertyFromObject][node.assignToProperty] = '';\n        } else {\n          node.payload[node.assignToProperty] = '';\n        }\n      }\n\n      return node.payload;\n    } catch (err) {\n      services.logMessage(err);\n    }\n  };\n\n  _proto.getName = function getName() {\n    return 'AssignTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Assign';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node sets a property in the payload either from a static value or input payload';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'assign';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'rect';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'assignToProperty',\n      defaultValue: '',\n      valueType: 'string',\n      required: true\n    }, {\n      name: 'assignAsPropertyFromObject',\n      defaultValue: '',\n      valueType: 'string',\n      required: false\n    }, {\n      name: 'value',\n      defaultValue: '',\n      valueType: 'string',\n      required: false\n    }, {\n      name: 'valueFromProperty',\n      defaultValue: '',\n      valueType: 'string',\n      required: false\n    }, {\n      name: 'readFromObject',\n      defaultValue: '',\n      valueType: 'string',\n      required: false\n    }];\n  };\n\n  return AssignTask;\n}(FlowTask);\n\nvar ClearTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(ClearTask, _FlowTask);\n\n  function ClearTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = ClearTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING ClearTask: ' + node.id + ' - ' + node.name);\n    var properties = {};\n\n    if (node.keepProperties !== undefined && node.keepProperties !== '') {\n      node.keepProperties.split(',').map(function (propertyItem) {\n        var propertyName = propertyItem.trim();\n\n        if (propertyName !== '') {\n          if (node.payload[propertyName] !== undefined) {\n            properties[propertyName] = node.payload[propertyName];\n          }\n        }\n\n        return true;\n      });\n    }\n\n    return Object.assign({}, properties);\n  };\n\n  _proto.getName = function getName() {\n    return 'ClearTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Clear';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that clears the payload';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'clear';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'rect';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'keepProperties',\n      defaultValue: '',\n      valueType: 'string'\n    }];\n  };\n\n  return ClearTask;\n}(FlowTask);\n\nvar ForwardTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(ForwardTask, _FlowTask);\n\n  function ForwardTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = ForwardTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING ForwardTask: ' + node.id + ' - ' + node.name);\n    return true;\n  };\n\n  _proto.getName = function getName() {\n    return 'ForwardTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Forward';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that forwards the event to the attached nodes';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'forward';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'smallcircle';\n  };\n\n  _proto.getDefaultColor = function getDefaultColor() {\n    return '#eeeeee80';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return FORWARD_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  return ForwardTask;\n}(FlowTask);\n\nvar FunctionCallTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(FunctionCallTask, _FlowTask);\n\n  function FunctionCallTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = FunctionCallTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING FunctionCallTask: ' + node.id + ' - ' + node.name);\n    return new Promise(function (resolve, _reject) {\n      resolve(node.payload);\n    });\n  };\n\n  _proto.getName = function getName() {\n    return 'FunctionCallTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'FunctionCall';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that calls a function node';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'functioncall';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'circle';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return FUNCTION_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'functionnodeid',\n      defaultValue: '',\n      valueType: 'enum',\n      required: true,\n      optionsViaController: true\n    }];\n  };\n\n  return FunctionCallTask;\n}(FlowTask);\n\nvar FunctionInputTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(FunctionInputTask, _FlowTask);\n\n  function FunctionInputTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = FunctionInputTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING FunctionInputTask: ' + node.id + ' - ' + node.name);\n    return new Promise(function (resolve, _reject) {\n      resolve(node.payload);\n    });\n  };\n\n  _proto.getName = function getName() {\n    return 'FunctionInputTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'FunctionInput';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return \"Node that's the startpoint for this function\";\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'FunctionInput';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'circle';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return FUNCTION_INPUT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  return FunctionInputTask;\n}(FlowTask);\n\nvar FunctionOutputTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(FunctionOutputTask, _FlowTask);\n\n  function FunctionOutputTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = FunctionOutputTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING FunctionOutputTask: ' + node.id + ' - ' + node.name);\n    return new Promise(function (resolve, _reject) {\n      resolve(node.payload);\n    });\n  };\n\n  _proto.getName = function getName() {\n    return 'FunctionOutputTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'FunctionOutput';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that is the end for this function';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'FunctionOutput';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'smallcircle';\n  };\n\n  _proto.getDefaultColor = function getDefaultColor() {\n    return '#3d93dd';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return FUNCTION_OUTPUT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  return FunctionOutputTask;\n}(FlowTask);\n\n//import * as moment from 'moment';\nfunction conditionCheck(field1, field2, condition, dataType) {\n  try {\n    var field2Values = [];\n\n    if (typeof field2 !== 'undefined' && field2 !== '' && field2 !== null && !(field2 instanceof Date) && typeof field2 !== 'number' && !(field2 === true) && field2 !== '__ISDATE__') {\n      field2Values = field2.split(',');\n    }\n    /*if (field2 === '__ISISODATE__') {\r\n      const date = moment(field1, 'YYYY-MM-DD', true);\r\n      return date.isValid();\r\n    } else */\n\n\n    if (condition === 'equals') {\n      if (field2 === '') {\n        return field1 === '' || typeof field1 === 'undefined' || field1 === null;\n      } else {\n        if (field2Values.length > 1) {\n          return field2Values.indexOf(field1) >= 0;\n        } else {\n          /*if (dataType === 'date') {\r\n            return moment(field1).isSame(moment(field2));\r\n          } else */\n          if (dataType === 'number') {\n            return parseFloat(field1) === parseFloat(field2);\n          } else {\n            return field1 === field2;\n          }\n        }\n      }\n    }\n\n    if (condition === 'not-equals') {\n      if (field2 === '') {\n        return field1 !== '' && typeof field1 !== 'undefined' && field1 !== null;\n      } else {\n        /*if (dataType === 'date') {\r\n          return !moment(field1).isSame(moment(field2));\r\n        } else */\n        if (dataType === 'number') {\n          return parseFloat(field1) !== parseFloat(field2);\n        } else {\n          return field1 !== field2;\n        }\n      }\n    }\n\n    if (condition === 'smaller') {\n      /*if (dataType === 'date') {\r\n        return moment(field1).isBefore(moment(field2));\r\n      } else */\n      if (dataType === 'number') {\n        return parseFloat(field1) < parseFloat(field2);\n      } else {\n        return field1 < field2;\n      }\n    }\n\n    if (condition === 'bigger') {\n      /*if (dataType === 'date') {\r\n        return moment(field1).isAfter(moment(field2));\r\n      } else */\n      if (dataType === 'number') {\n        return parseFloat(field1) > parseFloat(field2);\n      } else {\n        return field1 > field2;\n      }\n    }\n\n    if (condition === 'smaller-or-equal') {\n      /*if (dataType === 'date') {\r\n        return moment(field1).isSameOrBefore(moment(field2));\r\n      } else */\n      if (dataType === 'number') {\n        return parseFloat(field1) <= parseFloat(field2);\n      } else {\n        return field1 <= field2;\n      }\n    }\n\n    if (condition === 'bigger-or-equal') {\n      /*if (dataType === 'date') {\r\n        return moment(field1).isSameOrAfter(moment(field2));\r\n      } else */\n      if (dataType === 'number') {\n        return parseFloat(field1) >= parseFloat(field2);\n      } else {\n        return field1 >= field2;\n      }\n    }\n\n    return false;\n  } catch (err) {\n    throw new Error(err);\n  }\n}\n\nvar IfConditionTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(IfConditionTask, _FlowTask);\n\n  function IfConditionTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = IfConditionTask.prototype;\n\n  _proto.execute = function execute(node) {\n    // return new Promise((resolve: any, reject: any) => {\n    //const splitField1 = node.compareProperty.split('.');\n    var splitField2 = node.withProperty.split('.');\n    var errors = []; // console.log(\"splitField1\", splitField1);\n    // console.log(\"splitField2\", splitField2);\n\n    var field1 = node.payload[node.compareProperty];\n    /*if (field1 === '[NOW]') {\r\n      field1 = moment().toISOString();\r\n    }\r\n    */\n\n    var field2;\n\n    if (splitField2.length <= 1) {\n      if (node.withValue !== undefined && node.withValue !== '') {\n        field2 = node.withValue;\n      } else if (node.withProperty === '__TRUE__') {\n        field2 = true;\n      } else if (node.withProperty === '__EMPTY__') {\n        field2 = ''; //} else if (node.withProperty === '[NOW]') {\n        //  field2 = moment().toISOString();\n      } else if (node.withProperty === '__ISISODATE__') {\n        field2 = '__ISISODATE__';\n      } else {\n        field2 = node.payload[node.withProperty];\n      }\n    } else {\n      var objectToCheck = null;\n      splitField2.map(function (fieldName) {\n        if (objectToCheck) {\n          objectToCheck = objectToCheck[fieldName];\n        } else {\n          objectToCheck = node.payload[fieldName];\n        }\n\n        return true;\n      });\n      field2 = objectToCheck;\n    }\n\n    if (node.dontTriggerOnEmptyValues && (field1 === '' || field2 === '' || field1 === undefined || field2 === undefined)) {\n      return false;\n    }\n\n    if (node.usingCondition === 'isNonEmptyProperty' && field1 !== undefined && field1 !== '') {\n      return node.payload;\n    } else if (conditionCheck(field1, field2, node.usingCondition, node.dataType)) {\n      // console.log(\"conditionCheck: true\", field1,field2,node.compareProperty,node.withProperty);\n      return node.payload;\n    } else {\n      // console.log(\"conditionCheck: false\", field1,field2,node.compareProperty,node.withProperty);\n      errors.push({\n        error: node.compareProperty + ' is not correct',\n        name: node.compareProperty\n      });\n      var payload = Object.assign({}, node.payload, {\n        errors: errors,\n        followFlow: 'isError'\n      }); // resolve(node.payload);\n\n      return payload;\n    } // });\n\n  };\n\n  _proto.getName = function getName() {\n    return 'IfConditionTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'IfCondition';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that succeeds depending on the condition';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'ifthen';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'diamond';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'compareProperty',\n      defaultValue: '',\n      valueType: 'string',\n      required: true\n    }, {\n      name: 'withProperty',\n      defaultValue: '',\n      valueType: 'string',\n      required: false\n    }, {\n      name: 'withValue',\n      defaultValue: '',\n      valueType: 'string',\n      required: false\n    }, {\n      defaultValue: '',\n      enumText: ['equals', 'not-equals', 'smaller', 'bigger', 'smaller-or-equal', 'bigger-or-equal'],\n      enumValues: ['equals', 'not-equals', 'smaller', 'bigger', 'smaller-or-equal', 'bigger-or-equal'],\n      name: 'usingCondition',\n      valueType: 'enum'\n    }, {\n      defaultValue: '',\n      enumText: ['string', 'number', 'date'],\n      enumValues: ['string', 'number', 'date'],\n      name: 'dataType',\n      valueType: 'enum'\n    }];\n  };\n\n  return IfConditionTask;\n}(FlowTask);\n\nvar InjectIntoPayloadTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(InjectIntoPayloadTask, _FlowTask);\n\n  function InjectIntoPayloadTask() {\n    var _this;\n\n    _this = _FlowTask.apply(this, arguments) || this;\n\n    _this.replaceObjectVariables = function (node, template, data) {\n      var matches = template.match(/\"{.+?}\"/g);\n\n      if (matches) {\n        matches.map(function (match) {\n          var matchValue = match.slice(2, -2);\n          var value = '';\n          var splitted = matchValue.split(':');\n\n          if (splitted.length > 0 && splitted[0] === 'values') {\n            if (splitted.length === 3) {\n              var minRange = splitted[1].split(/(\\d+)/);\n              var maxRange = splitted[2].split(/(\\d+)/);\n              var transformObject;\n\n              if (node.transformObject && node.transformObject.values) {\n                transformObject = node.transformObject.values;\n              }\n\n              if (minRange.length >= 2 && maxRange.length >= 2) {\n                var newValue = '';\n                var loop = parseInt(minRange[1], 10) - 1;\n                var max = parseInt(maxRange[1], 10) - 1;\n\n                while (loop <= max) {\n                  var loopCell = (minRange[0] || 'A').charCodeAt(0) - 65;\n                  var maxCell = (maxRange[0] || 'A').charCodeAt(0) - 65;\n\n                  while (loopCell <= maxCell) {\n                    if (newValue !== '') {\n                      newValue += ',';\n                    }\n\n                    if (loop < data['values'].length && loopCell < data['values'][loop].length) {\n                      var item = void 0;\n                      var cellValue = data['values'][loop][loopCell];\n                      item = Number(cellValue);\n\n                      if (isNaN(item)) {\n                        item = cellValue;\n                      }\n\n                      if (transformObject) {\n                        var parse = _this.replaceObjectVariables(node, JSON.stringify(transformObject), {\n                          name: String.fromCharCode(loopCell % 26 + 65) + (loop + 1),\n                          value: item\n                        });\n\n                        item = JSON.parse(parse);\n                      }\n\n                      if (typeof item === 'object') {\n                        newValue += JSON.stringify(item);\n                      } else if (typeof item === 'string') {\n                        newValue += '\"' + item + '\"';\n                      } else {\n                        newValue += item;\n                      }\n                    }\n\n                    loopCell++;\n                  }\n\n                  loop++;\n                }\n\n                value = '[' + newValue + ']';\n              }\n            }\n          } else if (splitted.length > 0 && splitted[0] === 'value' && splitted.length === 2) {\n            if (splitted.length === 2) {\n              var cellId = splitted[1].split(/(\\d+)/);\n\n              var _transformObject;\n\n              if (node.transformObject && node.transformObject.values) {\n                _transformObject = node.transformObject.values;\n              }\n\n              if (cellId.length >= 2 && cellId.length >= 2) {\n                var _newValue = '';\n                var rowCell = parseInt(cellId[1], 10) - 1;\n                var columnCell = (cellId[0] || 'A').charCodeAt(0) - 65;\n\n                if (_newValue !== '') {\n                  _newValue += ',';\n                }\n\n                if (rowCell < data['values'].length && columnCell < data['values'][rowCell].length) {\n                  var _item;\n\n                  var _cellValue = data['values'][rowCell][columnCell];\n                  _item = Number(_cellValue);\n\n                  if (isNaN(_item)) {\n                    _item = _cellValue;\n                  }\n\n                  if (_transformObject) {\n                    _item = JSON.parse(_this.replaceObjectVariables(node, JSON.stringify(_transformObject), {\n                      name: String.fromCharCode(columnCell % 26 + 65) + (rowCell + 1),\n                      value: _item\n                    }));\n                  }\n\n                  if (typeof _item === 'object') {\n                    _newValue += JSON.stringify(_item);\n                  } else if (typeof _item === 'string') {\n                    _newValue += '\"' + _item + '\"';\n                  } else {\n                    _newValue += _item;\n                  }\n\n                  value = _newValue;\n                }\n              }\n            }\n          } else {\n            value = data[matchValue];\n\n            if (value === undefined) {\n              value = '';\n            }\n\n            if (typeof value === 'string') {\n              value = '\"' + value + '\"';\n            } else if (Array.isArray(value)) {\n              var _newValue2 = '';\n              value.map(function (item) {\n                if (_newValue2 !== '') {\n                  _newValue2 += ',';\n                }\n\n                if (typeof item === 'string') {\n                  _newValue2 += '\"' + item + '\"';\n                } else {\n                  _newValue2 += item;\n                }\n\n                return true;\n              });\n              value = '[' + _newValue2 + ']';\n            }\n          }\n\n          var allOccurancesOfMatchRegex = new RegExp(match, 'g');\n          template = template.replace(allOccurancesOfMatchRegex, value);\n          return true;\n        });\n      }\n\n      return template;\n    };\n\n    return _this;\n  }\n\n  var _proto = InjectIntoPayloadTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING InjectIntoPayloadTask: ' + node.id + ' - ' + node.name);\n\n    try {\n      if (node.object !== undefined) {\n        /*\r\n          TODO : node.object can contain \"{PROPERTYNAME}\" and \"[PROPERTYNAME]\" variables which\r\n            will be searched and replaced by properties from the payload\r\n                        - {PROPERTYNAME} is a single property\r\n              - ?? [PROPERTYNAME] is an array property either as a string \"a\",\"b\",... or as an array [\"a\",\"b\",...]\r\n                       Is the above really necessary ? .. can this be done with only {} and typeof?\r\n                       - {values:A1:B1} .. extract range A1 to B1 from values property and replace as array\r\n        */\n        if (!!node.hasObjectVariables) {\n          try {\n            var data = this.replaceObjectVariables(node, JSON.stringify(node.object), node.payload);\n            node.payload = Object.assign({}, node.payload, JSON.parse(data));\n          } catch (err) {\n            services.logMessage('InjectIntoPayloadTask inner exception', err);\n          }\n        } else {\n          node.payload = Object.assign({}, node.payload, node.object);\n        }\n      }\n\n      return node.payload;\n    } catch (err) {\n      services.logMessage(err);\n    }\n  };\n\n  _proto.getName = function getName() {\n    return 'InjectIntoPayloadTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'InjectIntoPayload';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that adds properties of node.object into payload';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'inject';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'rect';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'object',\n      defaultValue: '',\n      valueType: 'string',\n      required: true\n    }];\n  };\n\n  return InjectIntoPayloadTask;\n}(FlowTask);\n\nvar ObservableTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(ObservableTask, _FlowTask);\n\n  function ObservableTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = ObservableTask.prototype;\n\n  _proto.execute = function execute(node, _services) {\n    if (node.observable) {\n      if (!node.observeProperty || node.observeProperty && node.payload[node.observeProperty]) {\n        if (!!node.sendNodeName) {\n          node.observable.next({\n            nodeName: node.name,\n            payload: Object.assign({}, node.payload)\n          });\n        } else {\n          node.observable.next(Object.assign({}, node.payload));\n        }\n      }\n\n      return node.observable;\n    }\n\n    return false;\n  };\n\n  _proto.getObservable = function getObservable(node) {\n    if (node.observable === undefined) {\n      if (!!node.sendNodeName) {\n        node.observable = new rxjs__WEBPACK_IMPORTED_MODULE_5__.BehaviorSubject({\n          nodeName: node.name,\n          payload: {}\n        });\n      } else {\n        node.observable = new rxjs__WEBPACK_IMPORTED_MODULE_5__.BehaviorSubject({});\n      } // node.observable = new Subject<string>();\n\n    }\n\n    return node.observable;\n  };\n\n  _proto.isAttachedToExternalObservable = function isAttachedToExternalObservable() {\n    return false;\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that creates an observable';\n  };\n\n  _proto.getName = function getName() {\n    return 'ObservableTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Observable';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'observable';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'smallcircle';\n  };\n\n  _proto.getDefaultColor = function getDefaultColor() {\n    return '#00ff80ff';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'observeProperty',\n      defaultValue: '',\n      valueType: 'string',\n      required: true\n    }];\n  };\n\n  return ObservableTask;\n}(FlowTask);\n\nvar ObserverTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(ObserverTask, _FlowTask);\n\n  function ObserverTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = ObserverTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    //const counter = 0;\n    var observable = rxjs__WEBPACK_IMPORTED_MODULE_6__.Observable.create(function (observer) {\n      try {\n        if (node.observe !== undefined && node.observe !== '') {\n          var observableSubscription = services.getObservable(node.observe);\n\n          if (observableSubscription !== undefined && observableSubscription !== false) {\n            var observerSubscription = {\n              complete: function complete() {\n                services.logMessage('ObserverTask: Completed observable for ', node.name);\n              },\n              error: function error(err) {\n                observer.error(err);\n              },\n              next: function next(payload) {\n                if (payload !== undefined && payload.data !== undefined) {\n                  observer.next(payload.data);\n                } else {\n                  observer.next({});\n                }\n              }\n            };\n            observableSubscription.subscribe(observerSubscription);\n          } else {\n            observer.error('ObserverTask: Error - observable not found', node.observe);\n          }\n        } else {\n          observer.error('ObserverTask: Error - nothing to observe');\n        }\n      } catch (err) {\n        observer.error(err);\n      }\n    });\n    return observable;\n  };\n\n  _proto.isAttachedToExternalObservable = function isAttachedToExternalObservable() {\n    return true;\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that is subscribed to a reactive observable: {{{observe}}}';\n  };\n\n  _proto.getName = function getName() {\n    return 'ObserverTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Observer';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'observer';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'smallcircle';\n  };\n\n  _proto.getDefaultColor = function getDefaultColor() {\n    return '#00ff80ff';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return DEFAULT_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'observe',\n      defaultValue: '',\n      valueType: 'string',\n      required: true\n    }];\n  };\n\n  return ObserverTask;\n}(FlowTask);\n\nvar ParallelResolveTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(ParallelResolveTask, _FlowTask);\n\n  function ParallelResolveTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = ParallelResolveTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING ParallelResolveTask: ' + node.id + ' - ' + node.name);\n    return true;\n  };\n\n  _proto.getName = function getName() {\n    return 'ParallelResolveTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'ParallelResolve';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that waits until all parallel outputs resolved';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'clear';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'rect';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return PARALLEL_RESOLVE_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [];\n  };\n\n  return ParallelResolveTask;\n}(FlowTask);\n\nvar ParallelTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(ParallelTask, _FlowTask);\n\n  function ParallelTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = ParallelTask.prototype;\n\n  _proto.execute = function execute(node, services) {\n    services.logMessage('RUNNING ParallelTask: ' + node.id + ' - ' + node.name);\n    return true;\n  };\n\n  _proto.getName = function getName() {\n    return 'ParallelTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Parallel';\n  };\n\n  _proto.getDescription = function getDescription() {\n    return 'Node that sends out parallel outputs';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'clear';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'rect';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    return 'both';\n  };\n\n  _proto.getPackageType = function getPackageType() {\n    return PARALLEL_NODE;\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [];\n  };\n\n  return ParallelTask;\n}(FlowTask);\n\nvar TraceConsoleTask = /*#__PURE__*/function (_FlowTask) {\n  _inheritsLoose(TraceConsoleTask, _FlowTask);\n\n  function TraceConsoleTask() {\n    return _FlowTask.apply(this, arguments) || this;\n  }\n\n  var _proto = TraceConsoleTask.prototype;\n\n  _proto.execute = function execute(node, services, _callStack) {\n    services.logMessage('RUNNING: ' + node.id + ' - ' + node.name);\n\n    if (node.message !== undefined && node.message !== '') {\n      services.logMessage('LOGMESSAGE:', node.message);\n    } else {\n      services.logMessage(node.payload);\n    }\n\n    return new Promise(function (resolve, _reject) {\n      resolve(node.payload);\n    });\n  };\n\n  _proto.getName = function getName() {\n    return 'TraceConsoleTask';\n  };\n\n  _proto.getFullName = function getFullName() {\n    return 'Log to console';\n  };\n\n  _proto.getIcon = function getIcon() {\n    return 'console';\n  };\n\n  _proto.getShape = function getShape() {\n    return 'rect';\n  };\n\n  _proto.getTaskType = function getTaskType() {\n    // both/frontend/backend/mobileapp\n    return 'both';\n  };\n\n  _proto.getCategory = function getCategory() {\n    return 'FlowCanvas';\n  };\n\n  _proto.getController = function getController() {\n    return 'FlowCanvasController';\n  };\n\n  _proto.getConfigMetaData = function getConfigMetaData() {\n    return [{\n      name: 'message',\n      defaultValue: '',\n      valueType: 'string'\n    }];\n  };\n\n  return TraceConsoleTask;\n}(FlowTask);\n\nvar uuidV4$2 = uuid__WEBPACK_IMPORTED_MODULE_0__.v4;\nvar FlowEventRunner = /*#__PURE__*/function () {\n  function FlowEventRunner() {\n    var _this = this;\n\n    this.throttle = 30;\n    this.nodeValues = {};\n    this.nodeNames = [];\n    this.nodeState = {};\n    this.nodeLastPayload = {};\n    this.tasks = {};\n    this.middleware = [];\n    this.functionNodes = [];\n    this.flowNodeTriggers = [];\n    this.flowNodeRegisterHooks = [];\n    this.flowNodeOverrideAttachHooks = []; //private nodePluginInfoMap: any = {};\n\n    this.observables = [];\n    this.touchedNodes = {};\n    this.nodeInfoMap = {}; // TODO : refactor .. this method does too much\n    // - creating events foreach node\n    // - creating http get/post handlers\n    // - instantiate plugins\n    // - emit events to output nodes\n    // - calling plugin execute or executeAsHTTPEndpoint\n    //\n    // split in multiple methods / classes\n\n    this.createNodes = function (nodeList, autoStartNodes, keepOldFlowValues) {\n      if (autoStartNodes === void 0) {\n        autoStartNodes = false;\n      }\n\n      if (keepOldFlowValues === void 0) {\n        keepOldFlowValues = false;\n      }\n\n      _this.flowEventEmitter = new ReactiveEventEmitter();\n      _this.flowEventEmitter.throttle = _this.throttle;\n      var nodeEmitter = _this.flowEventEmitter;\n      nodeEmitter.on('error', _this.errorListener);\n      var nodePluginInfoMap = {};\n      var autostarters = [];\n\n      for (var pluginClassName in _this.services.pluginClasses) {\n        if (_this.services.pluginClasses.hasOwnProperty(pluginClassName)) {\n          var pluginClass = _this.services.pluginClasses[pluginClassName];\n\n          if (pluginClass === undefined) {\n            throw new Error(\"Task \" + pluginClassName + \" doesn't exist\");\n          }\n\n          var pluginInstance = new pluginClass();\n\n          if (!pluginInstance.getName) {\n            throw new Error(\"Task \" + pluginClassName + \" has no getName() method\");\n          }\n\n          var name = pluginInstance.getName() || '';\n\n          if (!name || name === '' || name === 'FlowTask') {\n            throw new Error(\"Task \" + pluginClassName + \" has no valid getName() method\");\n          }\n\n          if (nodePluginInfoMap[name]) {\n            throw new Error(\"Task \" + pluginClassName + \" has getName() conflict with other task\");\n          }\n\n          nodePluginInfoMap[name] = {\n            configMetaData: pluginInstance.getConfigMetaData(),\n            fullName: pluginInstance.getFullName(),\n            name: name,\n            pluginClass: pluginClass,\n            pluginClassName: pluginClassName,\n            pluginInstance: pluginInstance,\n            shape: pluginInstance.getShape()\n          };\n        }\n      } //this.nodePluginInfoMap = nodePluginInfoMap;\n\n\n      _this.nodes = nodeList.filter(function (o) {\n        return o.taskType !== 'connection';\n      }).map(function (node) {\n        if (!keepOldFlowValues || !_this.nodeValues[node.id]) {\n          _this.nodeValues[node.id] = node;\n        } // nodePluginInfo contains info about the the plugin such as the plugInstance, className and config metadata\n\n\n        var nodePluginInfo = nodePluginInfoMap[node.taskType];\n        var pluginClass = _this.services.pluginClasses[node.taskType];\n\n        if (!pluginClass) {\n          _this.services.logMessage('pluginClass not defined', node.id, node);\n\n          return false;\n        }\n\n        var pluginInstance = new pluginClass(); // node is the actual node on flow-level (it contains just the basic properties defined in the flow)\n\n        node.payload = {};\n\n        if (node.subtype === 'registrate' || node.subtype === 'register') {\n          FlowEventRunnerHelper.registerNode(node, pluginInstance, _this.services, _this.flowNodeRegisterHooks);\n          return false;\n        } // nodeInfo contains the info needed to run the plugin on and list of input/output nodes and\n        // which nodes are used for injection on each run of a plugin\n\n\n        var nodeInfo = BuildNodeInfoHelper.build(nodeList, node, nodePluginInfoMap, _this.services);\n        nodeInfo.pluginInstance = pluginInstance;\n        _this.nodeInfoMap[node.id] = nodeInfo;\n        _this.nodeNames[node.name] = node.id;\n\n        if (pluginInstance !== undefined) {\n          _this.flowNodeTriggers.map(function (flowNodeTrigger) {\n            flowNodeTrigger(pluginInstance.getPackageType(), node, function (payload, callStack) {\n              nodeEmitter.emit(node.id.toString(), payload, callStack);\n            });\n            return true;\n          });\n        }\n\n        if (typeof nodePluginInfo !== 'undefined') {\n          _this.flowNodeOverrideAttachHooks.map(function (hook) {\n            if (hook(node, pluginInstance, _this.flowEventEmitter, nodeInfo)) {\n              return false;\n            }\n\n            return true;\n          });\n\n          if (node.subtype === 'autostart') {\n            autostarters.push(node.id.toString());\n          } else if (pluginInstance.isStartingOnInitFlow !== undefined) {\n            if (pluginInstance.isStartingOnInitFlow()) {\n              autostarters.push(node.id.toString());\n            }\n          }\n\n          if (pluginInstance.getObservable !== undefined) {\n            _this.observables.push({\n              name: node.name || node.title.replace(/ /g, ''),\n              nodeId: node.id,\n              observable: pluginInstance.getObservable(node)\n            });\n          }\n\n          if (pluginInstance.getPackageType() === FUNCTION_INPUT_NODE) {\n            _this.functionNodes[node.name] = node.id.toString();\n\n            _this.services.logMessage(_this.functionNodes);\n          }\n\n          if (node.controllers) {\n            nodeEmitter.registerNodeControllers(node);\n          }\n\n          var options = {\n            isSampling: !!node.isSampling || pluginInstance.isSampling && pluginInstance.isSampling(node),\n            isThrottling: !!node.isThrottling || pluginInstance.isThrottling && pluginInstance.isThrottling(node),\n            sampleInterval: node.sampleInterval,\n            throttleInterval: node.throttleInterval\n          };\n\n          if (node.events) {\n            var flowEventRunner = _this;\n            node.events.map(function (event) {\n              nodeEmitter.on(node.id.toString() + '_' + event.eventName, function (payload, callStack) {\n                var currentNode = Object.assign({}, node, _this.nodeValues[node.id]);\n                var nodeInstance = Object.assign({}, currentNode, {\n                  followNodes: nodeInfo.manuallyToFollowNodes\n                }); // copy the current node info but DONT include its outputs...\n\n                var eventNodeInfo = _extends({}, nodeInfo);\n\n                if (eventNodeInfo.outputs) {\n                  delete eventNodeInfo.outputs;\n                }\n\n                if (eventNodeInfo.error) {\n                  delete eventNodeInfo.error;\n                } // only add the connections which are the actual event...\n\n\n                eventNodeInfo.outputs = nodeList.filter(function (o) {\n                  return o.startshapeid === node.id.toString() && o.taskType === 'connection' && o.followflow !== 'onfailure' && o.followflow !== 'followManually' && o.followflow !== 'injectConfigIntoPayload' && o.event === event.eventName;\n                });\n                eventNodeInfo.error = [];\n                nodeInstance.payload = Object.assign({}, payload);\n                EmitOutput.emitToOutputs(nodePluginInfo, nodeEmitter, eventNodeInfo, nodeInstance, callStack, flowEventRunner, event.eventName);\n              }, options);\n              return true;\n            });\n          }\n\n          nodeEmitter.on(node.id.toString(), function (payload, callStack) {\n            var currentNode = Object.assign({}, node, _this.nodeValues[node.id]);\n\n            var payloadInstance = _extends({}, payload);\n\n            if (!!node['_setPerformanceMarker'] && typeof performance !== 'undefined') {\n              payloadInstance['_performance'] = performance.now();\n            }\n\n            if (!!node['_getPerformanceMeasure'] && payloadInstance['_performance'] && typeof performance !== 'undefined') {\n              payloadInstance['_performanceDuration'] = performance.now() - payloadInstance['_performance'];\n            }\n\n            if (!!node['_clearPerformance']) {\n              if (payloadInstance['_performanceDuration']) {\n                delete payloadInstance['_performanceDuration'];\n              }\n\n              if (payloadInstance['_performance']) {\n                delete payloadInstance['_performance'];\n              }\n            }\n\n            if (node.controllers) {\n              node.controllers.map(function (controller) {\n                var value = nodeEmitter.getNodeControllerValue(node.name, controller.name);\n\n                if (value || value === 0) {\n                  payloadInstance[controller.name] = value;\n                }\n\n                return true;\n              });\n            }\n\n            var injectionValues = {};\n            var injectionPromises = InjectionHelper.executeInjections(currentNode, nodeInfo, injectionValues, payloadInstance, _this.services, callStack, _this.middleware);\n            var flowEventRunner = _this;\n            Promise.all(injectionPromises).then(function () {\n              // nodeInstance contains the payload and is the current instance of the node which\n              // is used to execute the plugin on.\n              var tempPayload = _extends({}, payloadInstance);\n\n              var callstackInstance = _extends({}, callStack);\n\n              var nodeInstance = Object.assign({}, currentNode, {\n                followNodes: nodeInfo.manuallyToFollowNodes\n              });\n\n              if (node && node.observable) {\n                nodeInstance.observable = node.observable;\n              }\n\n              nodeInstance.payload = Object.assign({}, tempPayload, injectionValues);\n\n              if (node.subtype === 'start') {\n                callstackInstance.sessionId = uuidV4$2();\n              }\n\n              _this.services.logMessage('EVENT Received for node: ', nodeInfo.name, node.id.toString());\n\n              function emitToOutputs(currentNodeInstance, currentCallStack) {\n                EmitOutput.emitToOutputs(nodePluginInfo, nodeEmitter, nodeInfo, currentNodeInstance, currentCallStack, flowEventRunner);\n              }\n\n              function emitToError(currentNodeInstance, currentCallStack) {\n                EmitOutput.emitToError(nodePluginInfo, nodeEmitter, nodeInfo, currentNodeInstance, currentCallStack, flowEventRunner);\n              }\n\n              try {\n                var newCallStack = callstackInstance;\n\n                if (pluginInstance.getPackageType() === FUNCTION_NODE) {\n                  emitToOutputs(nodeInstance, newCallStack);\n                  newCallStack = null;\n                  tempPayload = null;\n                  callstackInstance = null;\n                  return;\n                }\n\n                if (pluginInstance.getPackageType() !== FORWARD_NODE && pluginInstance.getPackageType() !== FUNCTION_OUTPUT_NODE) {\n                  if (typeof nodeInstance.payload.followFlow !== 'undefined') {\n                    delete nodeInstance.payload.followFlow;\n                  }\n                } else {\n                  // FORWARD_NODE OR FUNCTION_OUTPUT_NODE\n                  //\n                  // _forwardFollowFlow contains the last followFlow\n                  // followFlow is used by IfConditionTask to handle 'else'\n                  if (nodeInstance.payload._forwardFollowFlow !== undefined) {\n                    nodeInstance.payload.followFlow = nodeInstance.payload._forwardFollowFlow;\n                  }\n                }\n\n                nodeInstance.payload._forwardFollowFlow = undefined;\n                _this.nodeState[nodeInstance.name] = {\n                  hasError: false\n                };\n                _this.nodeLastPayload[node.name] = _extends({}, nodeInstance.payload);\n\n                _this.resetTouchedNodesPreExecute(nodeInfo, []);\n\n                _this.touchedNodes[nodeInfo.nodeId] = true;\n                var result = pluginInstance.execute(nodeInstance, _this.services, newCallStack);\n\n                if (result instanceof rxjs__WEBPACK_IMPORTED_MODULE_6__.Observable || result instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject) {\n                  if (pluginInstance.getObservable === undefined) {\n                    _this.observables.push({\n                      name: nodeInstance.name || nodeInstance.title.replace(/ /g, ''),\n                      nodeId: nodeInstance.id,\n                      observable: result\n                    });\n                  }\n\n                  if (node.isNodeObserved) {\n                    newCallStack = null;\n                    tempPayload = null;\n                    callstackInstance = null;\n                    return;\n                  }\n\n                  node.isNodeObserved = true;\n                  var observer = {\n                    complete: function complete() {\n                      _this.services.logMessage('Completed observable for ', nodeInstance.name);\n\n                      tempPayload = null;\n                      callstackInstance = null;\n                    },\n                    error: function error(err) {\n                      _this.nodeState[nodeInstance.name] = {\n                        hasError: true\n                      };\n                      nodeInstance.payload = Object.assign({}, nodeInstance.payload, {\n                        error: err\n                      });\n                      emitToError(nodeInstance, newCallStack);\n                      FlowEventRunnerHelper.callMiddleware(_this.middleware, 'error', nodeInstance.id, nodeInstance.name, node.taskType, tempPayload, new Date());\n                      tempPayload = null;\n                      callstackInstance = null;\n                    },\n                    next: function next(incomingPayload) {\n                      nodeInstance.payload = incomingPayload.payload ? incomingPayload.payload : incomingPayload;\n                      emitToOutputs(nodeInstance, newCallStack);\n                      FlowEventRunnerHelper.callMiddleware(_this.middleware, incomingPayload && incomingPayload.followFlow === 'isError' ? 'error' : 'ok', nodeInstance.id, nodeInstance.name, node.taskType, _extends({}, incomingPayload), new Date());\n                      tempPayload = null;\n                      callstackInstance = null;\n                      newCallStack = null;\n                    }\n                  };\n\n                  if (node.subscription) {\n                    node.subscription.unsubscribe();\n                    node.subscription = null;\n                  }\n\n                  node.subscription = result.subscribe(observer);\n                } else if (typeof result === 'object' && typeof result.then === 'function') {\n                  // Promise\n                  result.then(function (incomingPayload) {\n                    nodeInstance.payload = _extends({}, incomingPayload);\n                    emitToOutputs(nodeInstance, newCallStack);\n                    FlowEventRunnerHelper.callMiddleware(_this.middleware, incomingPayload && incomingPayload.followFlow === 'isError' ? 'error' : 'ok', nodeInstance.id, nodeInstance.name, node.taskType, _extends({}, incomingPayload), new Date());\n                    tempPayload = null;\n                    callstackInstance = null;\n                    newCallStack = null;\n                  })[\"catch\"](function (err) {\n                    _this.services.logMessage(err);\n\n                    _this.nodeState[nodeInstance.name] = {\n                      hasError: true\n                    };\n                    nodeInstance.payload = Object.assign({}, nodeInstance.payload, {\n                      error: err\n                    });\n                    emitToError(nodeInstance, newCallStack);\n                    FlowEventRunnerHelper.callMiddleware(_this.middleware, 'error', nodeInstance.id, nodeInstance.name, node.taskType, nodeInstance.payload, new Date());\n                    tempPayload = null;\n                    callstackInstance = null;\n                    newCallStack = null;\n                  });\n                } else if (typeof result === 'object') {\n                  nodeInstance.payload = _extends({}, result);\n                  emitToOutputs(nodeInstance, newCallStack);\n                  FlowEventRunnerHelper.callMiddleware(_this.middleware, result && result.followFlow === 'isError' ? 'error' : 'ok', nodeInstance.id, nodeInstance.name, node.taskType, result, new Date());\n                  tempPayload = null;\n                  callstackInstance = null;\n                  newCallStack = null;\n                } else if (typeof result === 'boolean' && result === true) {\n                  emitToOutputs(nodeInstance, newCallStack);\n                  FlowEventRunnerHelper.callMiddleware(_this.middleware, 'ok', nodeInstance.id, nodeInstance.name, node.taskType, nodeInstance.payload, new Date());\n                  tempPayload = null;\n                  callstackInstance = null;\n                  newCallStack = null;\n                } else if (typeof result === 'boolean' && result === false) {\n                  console.log('====== RETURN IS FALSE ====', nodeInstance);\n                  _this.nodeState[nodeInstance.name] = {\n                    hasError: true\n                  }; // todo : check and think about if this should not happen here\n                  // emitToError(nodeInstance, newCallStack);\n\n                  FlowEventRunnerHelper.callMiddleware(_this.middleware, 'error', nodeInstance.id, nodeInstance.name, node.taskType, nodeInstance.payload, new Date());\n                  newCallStack = null;\n                  tempPayload = null;\n                  callstackInstance = null;\n                }\n              } catch (err) {\n                _this.services.logMessage(err);\n\n                var payloadForNotification = Object.assign({}, nodeInstance.payload);\n                payloadForNotification.response = undefined;\n                payloadForNotification.request = undefined;\n                emitToError(nodeInstance, callstackInstance);\n                tempPayload = null;\n                callstackInstance = null;\n              }\n\n              payloadInstance = null;\n            });\n          }, options);\n          return nodeInfo;\n        }\n\n        return false;\n      });\n      autostarters.map(function (nodeId) {\n        nodeEmitter.emit(nodeId.toString(), {}, {});\n        return true;\n      });\n\n      if (!!autoStartNodes) {\n        _this.nodes.map(function (nodeInfo) {\n          if (nodeInfo.pluginInstance.getPackageType() !== FUNCTION_INPUT_NODE) {\n            if (nodeInfo.inputs.length === 0 && !nodeInfo.dontAutostart) {\n              nodeEmitter.emit(nodeInfo.nodeId.toString(), {}, {});\n            }\n          }\n\n          return true;\n        });\n      }\n    };\n\n    this.destroyFlow = function () {\n      _this.nodeInfoMap = {};\n\n      if (_this.touchedNodes) {\n        _this.touchedNodes = {};\n      }\n\n      if (_this.flowEventEmitter) {\n        _this.flowEventEmitter.removeListener('error');\n      }\n\n      if (_this.nodeState) {\n        _this.nodeState = {};\n      }\n\n      if (_this.nodeLastPayload) {\n        _this.nodeLastPayload = {};\n      }\n\n      if (_this.nodes) {\n        _this.nodes.map(function (nodeInfo) {\n          if (nodeInfo && nodeInfo.nodeId) {\n            if (_this.flowEventEmitter) {\n              _this.flowEventEmitter.removeListener(nodeInfo.nodeId);\n            }\n          }\n\n          if (nodeInfo && nodeInfo.subscription) {\n            nodeInfo.subscription.unsubscribe();\n            nodeInfo.subscription = undefined;\n          }\n\n          if (nodeInfo && nodeInfo.pluginInstance && nodeInfo.pluginInstance.kill) {\n            nodeInfo.pluginInstance.kill();\n          }\n\n          if (nodeInfo) {\n            nodeInfo.pluginInstance = undefined;\n            nodeInfo.inputs = [];\n            nodeInfo.outputs = [];\n            nodeInfo.error = [];\n          }\n\n          return true;\n        });\n      }\n\n      _this.nodes = [];\n\n      _this.observables.map(function (observableHelper) {\n        if (observableHelper && observableHelper.observable) {\n          observableHelper.observable.complete();\n        }\n\n        return true;\n      });\n\n      _this.observables = []; //this.nodeValues = {};\n\n      _this.nodeNames = [];\n    };\n\n    this.getFunctionNodeId = function (title) {\n      if (typeof _this.functionNodes[title] !== 'undefined' && _this.functionNodes[title] !== '') {\n        return _this.functionNodes[title];\n      }\n\n      return false;\n    };\n\n    this.callNode = function (nodeId, payload) {\n      _this.flowEventEmitter.emit(nodeId.toString(), payload, {});\n    };\n\n    this.triggerEventOnNode = function (nodeName, eventName, payload) {\n      return _this.executeNode(nodeName, payload, undefined, eventName);\n    };\n\n    this.retriggerNode = function (nodeName) {\n      var payload = _this.nodeLastPayload[nodeName] || {};\n      return _this.executeNode(nodeName, payload, undefined);\n    };\n\n    this.executeNode = function (nodeName, payload, callStack, eventName) {\n      // this.touchedNodes = {};\n      if (!_this.nodeNames[nodeName]) {\n        return new Promise(function (_resolve, reject) {\n          reject();\n        });\n      }\n\n      var self = _this;\n\n      var payloadInstance = _extends({}, payload);\n\n      var callstackInstance = callStack ? _extends({}, callStack) : {};\n      var tempNodeId;\n      var tempErrorNodeId;\n      /*\r\n                 problem with pausing the flow is that this can happen during handling of\r\n        executeNode internal emits, and then the executeNode/triggerEventOnNode never finished\r\n        \n        TODO : figure out how to prevent that?\r\n               */\n\n      callstackInstance['_executeNode'] = true;\n\n      if (!!_this.flowEventEmitter.isPaused) {\n        return new Promise(function (resolve, _reject) {\n          resolve({});\n        });\n      }\n\n      tempNodeId = uuidV4$2().toString();\n      tempErrorNodeId = uuidV4$2().toString();\n      return new Promise(function (resolve, reject) {\n        new Promise(function (innerresolve, innerreject) {\n          function onResult(localPayload) {\n            // self.services.logMessage('executeNode result', localPayload);\n            innerresolve(localPayload);\n          }\n\n          function onError() {\n            // self.services.logMessage('executeNode result', localPayload);\n            innerreject();\n          }\n\n          try {\n            var nodeId = self.nodeNames[nodeName];\n            self.flowEventEmitter.on(tempNodeId, onResult);\n            self.flowEventEmitter.on(tempErrorNodeId, onError);\n            var newCallStack = Object.assign({}, {\n              error: [{\n                endshapeid: tempErrorNodeId\n              }],\n              outputs: [{\n                endshapeid: tempNodeId\n              }]\n            }, callstackInstance);\n            self.flowEventEmitter.emit(nodeId.toString() + (eventName !== undefined ? '_' + eventName : ''), payloadInstance, newCallStack);\n            payloadInstance = null;\n            callstackInstance = null;\n          } catch (err) {\n            _this.services.logMessage('executeNode error', err);\n\n            payloadInstance = null;\n            callstackInstance = null;\n            innerreject();\n          }\n        }).then(function (localPayload) {\n          self.flowEventEmitter.removeListener(tempNodeId);\n          self.flowEventEmitter.removeListener(tempErrorNodeId);\n          self = null;\n          tempNodeId = null;\n          tempErrorNodeId = null;\n          resolve(localPayload);\n        })[\"catch\"](function () {\n          self.flowEventEmitter.removeListener(tempNodeId);\n          self.flowEventEmitter.removeListener(tempErrorNodeId);\n          self = null;\n          tempNodeId = null;\n          tempErrorNodeId = null;\n          reject();\n        });\n      });\n    };\n\n    this.getFlowEventEmitter = function () {\n      return _this.flowEventEmitter;\n    };\n\n    this.registerFlowNodeTrigger = function (effect) {\n      _this.flowNodeTriggers.push(effect);\n    };\n\n    this.registerFlowNodeRegisterHook = function (hook) {\n      _this.flowNodeRegisterHooks.push(hook);\n    };\n\n    this.registerFlowNodeOverrideAttachHook = function (hook) {\n      _this.flowNodeOverrideAttachHooks.push(hook);\n    };\n\n    this.registerTask = function (taskName, taskClass) {\n      _this.tasks[taskName] = taskClass;\n      return true;\n    };\n\n    this.registerMiddleware = function (middleware) {\n      _this.middleware.push(middleware);\n    };\n\n    this.getObservableNode = function (nodeName) {\n      var observables = _this.observables.filter(function (observableNode) {\n        return observableNode.name === nodeName;\n      });\n\n      return observables.length > 0 ? observables[0].observable : false;\n    };\n\n    this.executeFlowFunction = function (nodeName) {\n      var self = _this;\n      return new Promise(function (resolve, reject) {\n        var tempNodeId;\n\n        function onFunctionResult(payload) {\n          self.flowEventEmitter.removeListener(tempNodeId, onFunctionResult);\n          resolve(payload);\n        }\n\n        try {\n          if (typeof _this.functionNodes[nodeName] !== 'undefined' && self.functionNodes[nodeName] !== '') {\n            tempNodeId = uuidV4$2().toString();\n            var nodeId = self.functionNodes[nodeName];\n            self.flowEventEmitter.on(tempNodeId, onFunctionResult);\n            var payload = {}; // payload._functionOutputs = [{endshapeid:tempNodeId}];\n            // payload._functionErrorOutputs = [];\n\n            var callStack = {\n              error: [],\n              outputs: [{\n                endshapeid: tempNodeId\n              }]\n            };\n            self.flowEventEmitter.emit(nodeId.toString(), payload, callStack);\n          } else {\n            reject();\n          }\n        } catch (err) {\n          _this.services.logMessage('executeFlowFunction error', err);\n\n          reject();\n        }\n      });\n    };\n\n    this.start = function (flowPackage, customServices, mergeWithDefaultPlugins, autoStartNodes, keepOldFlowValues) {\n      if (mergeWithDefaultPlugins === void 0) {\n        mergeWithDefaultPlugins = true;\n      }\n\n      if (autoStartNodes === void 0) {\n        autoStartNodes = false;\n      }\n\n      if (keepOldFlowValues === void 0) {\n        keepOldFlowValues = false;\n      }\n\n      _this.touchedNodes = {};\n      _this.nodeInfoMap = {};\n\n      if (!keepOldFlowValues) {\n        _this.nodeValues = {};\n      }\n\n      if (customServices !== undefined) {\n        _this.services = customServices;\n        _this.services.flowEventRunner = _this;\n      } else {\n        _this.services = {\n          flowEventRunner: _this,\n          logMessage: function logMessage() {},\n          pluginClasses: {},\n          registerModel: function registerModel(_modelName, _definition) {}\n        };\n      }\n\n      _this.services.getActivationFunction = _this.getActivationFunction;\n\n      if (mergeWithDefaultPlugins === undefined || mergeWithDefaultPlugins === true) {\n        _this.services.pluginClasses['AssignTask'] = AssignTask;\n        _this.services.pluginClasses['ClearTask'] = ClearTask;\n        _this.services.pluginClasses['ForwardTask'] = ForwardTask;\n        _this.services.pluginClasses['InjectIntoPayloadTask'] = InjectIntoPayloadTask;\n        _this.services.pluginClasses['ObserverTask'] = ObserverTask;\n        _this.services.pluginClasses['ObservableTask'] = ObservableTask;\n        _this.services.pluginClasses['TraceConsoleTask'] = TraceConsoleTask;\n        _this.services.pluginClasses['IfConditionTask'] = IfConditionTask;\n        _this.services.pluginClasses['FunctionCallTask'] = FunctionCallTask;\n        _this.services.pluginClasses['FunctionInputTask'] = FunctionInputTask;\n        _this.services.pluginClasses['FunctionOutputTask'] = FunctionOutputTask;\n        _this.services.pluginClasses['ParallelTask'] = ParallelTask;\n        _this.services.pluginClasses['ParallelResolveTask'] = ParallelResolveTask;\n      }\n\n      _this.services.pluginClasses = Object.assign({}, _this.services.pluginClasses, _this.tasks);\n      return new Promise(function (resolve, reject) {\n        try {\n          _this.createNodes(flowPackage.flow, autoStartNodes, keepOldFlowValues);\n\n          resolve(_this.services);\n        } catch (err) {\n          _this.services.logMessage('setup failed! error', err);\n\n          reject();\n        }\n      });\n    };\n\n    this.getTaskMetaData = function () {\n      var metaData = [];\n\n      for (var pluginClassName in _this.services.pluginClasses) {\n        if (_this.services.pluginClasses.hasOwnProperty(pluginClassName)) {\n          var pluginClass = _this.services.pluginClasses[pluginClassName];\n          var pluginInstance = new pluginClass();\n          metaData.push({\n            className: pluginClassName,\n            configMetaData: pluginInstance.getConfigMetaData(),\n            fullName: pluginInstance.getFullName(),\n            name: pluginInstance.getName(),\n            shape: pluginInstance.getShape()\n          });\n        }\n      }\n\n      return metaData;\n    };\n\n    this.setPropertyOnNode = function (nodeName, propertyName, value, additionalValues) {\n      var nodeId = _this.nodeNames[nodeName];\n\n      if (additionalValues) {\n        _this.nodeValues[nodeId] = _extends({}, _this.nodeValues[nodeId], additionalValues);\n      }\n\n      if (nodeId !== undefined && _this.nodeValues[nodeId] !== undefined) {\n        _this.nodeValues[nodeId][propertyName] = value;\n      }\n    };\n\n    this.getPropertyFromNode = function (nodeName, propertyName) {\n      var nodeId = _this.nodeNames[nodeName];\n\n      if (nodeId !== undefined && _this.nodeValues[nodeId] !== undefined) {\n        return _this.nodeValues[nodeId][propertyName];\n      }\n\n      return undefined;\n    };\n\n    this.pauseFlowrunner = function () {\n      _this.flowEventEmitter.pauseFlowrunner();\n    };\n\n    this.registerActivationFuncion = function (name, activationFunction) {\n      _this.activationFunctions[name] = activationFunction;\n    };\n\n    this.resumeFlowrunner = function () {\n      _this.flowEventEmitter.resumeFlowrunner();\n    };\n\n    this.errorListener = function (err) {\n      console.error('error in FlowEventRunner EventEmitter');\n      console.log(err);\n    };\n\n    this.getActivationFunction = function (name) {\n      if (_this.activationFunctions[name]) {\n        return _this.activationFunctions[name];\n      }\n\n      return false;\n    };\n\n    this.resetTouchedNodesPreExecute = function (nodeInfo, updatedNodes) {\n      /*\r\n      - touchednodes bijwerken in de FlowEventRunner:\r\n          \n              - touchednodes wordt alleen gereset bij volledig starten van flow (startFlow)\r\n              - voor node.execute\r\n                  - set output node connections en ouput nodes als touched = false\r\n                           - recursief door output nodes lopen (voorkom circulaire nodes door steeds lijst\r\n                          van nodes die \"geweest\" zijn mee te sturen en als een node behandeld\r\n                              wordt die al geweest is.. dan stoppen\r\n                      )\r\n                               PROBLEEM : de output nodes zijn nog niet uitgevoerd als een parent\r\n              wordt uitgevoerd .. de kinderen worden natuurlijk van zelf uitgevoerd\r\n          - na elke node.execute:\r\n            - set current node als touched\r\n            - emitoutput zet de node-connections die aangeraakt zijn als touched\r\n               */\n      if (!nodeInfo) {\n        return;\n      }\n\n      if (updatedNodes.indexOf(nodeInfo.nodeId) >= 0) {\n        return;\n      }\n\n      var updatedNodesList = [].concat(updatedNodes, [nodeInfo.nodeId]);\n      _this.touchedNodes[nodeInfo.nodeId] = false;\n\n      if (nodeInfo && nodeInfo.outputs) {\n        nodeInfo.outputs.map(function (outputNode) {\n          delete _this.touchedNodes[outputNode.name];\n          return true;\n        });\n        nodeInfo.outputs.map(function (outputNode) {\n          _this.resetTouchedNodesPreExecute(_this.nodeInfoMap[outputNode.endshapeid], updatedNodesList);\n\n          return true;\n        });\n      }\n\n      if (nodeInfo && nodeInfo.error) {\n        nodeInfo.error.map(function (outputNode) {\n          delete _this.touchedNodes[outputNode.name];\n          return true;\n        });\n        nodeInfo.error.map(function (outputNode) {\n          _this.resetTouchedNodesPreExecute(_this.nodeInfoMap[outputNode.endshapeid], updatedNodesList);\n\n          return true;\n        });\n      }\n    };\n\n    this.activationFunctions = [];\n    this.services = {\n      flowEventRunner: this,\n      getActivationFunction: this.getActivationFunction,\n      //logMessage: (...args) => {},\n      logMessage: function logMessage() {},\n      pluginClasses: [],\n      //registerModel: (modelName: string, definition: any) => {},\n      registerModel: function registerModel() {}\n    };\n  }\n\n  var _proto = FlowEventRunner.prototype;\n\n  _proto.getNodeState = function getNodeState(nodeName) {\n    return this.nodeState[nodeName] || {};\n  };\n\n  _proto.getTouchedNodeState = function getTouchedNodeState(nodeName) {\n    return this.touchedNodes[nodeName] || false;\n  };\n\n  _proto.getTouchedNodes = function getTouchedNodes() {\n    return this.touchedNodes || {};\n  };\n\n  return FlowEventRunner;\n}();\n\nvar uuidV4$3 = uuid__WEBPACK_IMPORTED_MODULE_0__.v4;\nvar HumanFlowToMachineFlow = {\n  convert: function convert(humanFlowPackege) {\n    var flowPackage = Object.assign({}, humanFlowPackege);\n    flowPackage.flow.map(function (flowNode) {\n      flowNode.title = flowNode.title || flowNode.name || flowNode.id;\n      flowNode.name = flowNode.name || flowNode.title.replace(/ /g, '');\n      flowNode.shapeType = 'Rect';\n      flowNode.id = flowNode.name;\n      flowNode._id = flowNode.name;\n\n      if (flowNode.task !== undefined) {\n        flowNode.shapeType = flowNode.task;\n        flowNode.taskType = flowNode.task;\n      }\n\n      if (typeof flowNode._outputs !== 'undefined') {\n        flowNode._outputs.map(function (outputNodeName) {\n          var connection = {};\n          connection.id = uuidV4$3();\n          connection._id = connection.id;\n          connection.shapeType = 'line';\n          connection.taskType = 'connection';\n          connection.title = 'connection';\n          connection.name = 'outputsFrom_' + flowNode.name + '_to_' + outputNodeName + '_' + connection.id;\n          connection.startshapeid = flowNode.name;\n          connection.endshapeid = outputNodeName;\n          flowPackage.flow.push(connection);\n          return true;\n        });\n      }\n\n      if (typeof flowNode._errors !== 'undefined') {\n        flowNode._errors.map(function (outputNodeName) {\n          var connection = {};\n          connection.id = uuidV4$3();\n          connection._id = connection.id;\n          connection.shapeType = 'line';\n          connection.taskType = 'connection';\n          connection.title = 'connection';\n          connection.name = 'sendsErrorFrom_' + flowNode.name + '_to_' + outputNodeName + '_' + connection.id;\n          connection.startshapeid = flowNode.id;\n          connection.endshapeid = outputNodeName;\n          connection.followflow = 'onfailure';\n          flowPackage.flow.push(connection);\n          return true;\n        });\n      }\n\n      return true;\n    });\n    return flowPackage;\n  }\n};\n\n\n//# sourceMappingURL=flowrunner.esm.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/@devhelpr/flowrunner/dist/flowrunner.esm.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/BehaviorSubject.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BehaviorSubject\": () => (/* binding */ BehaviorSubject)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subject.js\");\n/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js\");\n/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\n\n\n\nvar BehaviorSubject = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(_Subject__WEBPACK_IMPORTED_MODULE_2__.Subject));\n\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/BehaviorSubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/Observable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observable\": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/canReportError.js\");\n/* harmony import */ var _util_toSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/toSubscriber.js\");\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/observable.js\");\n/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/pipe.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/config.js\");\n/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n\n\n\n\n\nvar Observable = /*@__PURE__*/ (function () {\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = (0,_util_toSubscriber__WEBPACK_IMPORTED_MODULE_0__.toSubscriber)(observerOrNext, error, complete);\n        if (operator) {\n            sink.add(operator.call(sink, this.source));\n        }\n        else {\n            sink.add(this.source || (_config__WEBPACK_IMPORTED_MODULE_1__.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n                this._subscribe(sink) :\n                this._trySubscribe(sink));\n        }\n        if (_config__WEBPACK_IMPORTED_MODULE_1__.config.useDeprecatedSynchronousErrorHandling) {\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            if (_config__WEBPACK_IMPORTED_MODULE_1__.config.useDeprecatedSynchronousErrorHandling) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n            }\n            if ((0,_util_canReportError__WEBPACK_IMPORTED_MODULE_2__.canReportError)(sink)) {\n                sink.error(err);\n            }\n            else {\n                console.warn(err);\n            }\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                try {\n                    next(value);\n                }\n                catch (err) {\n                    reject(err);\n                    if (subscription) {\n                        subscription.unsubscribe();\n                    }\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        return source && source.subscribe(subscriber);\n    };\n    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_3__.observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_4__.pipeFromArray)(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\n\nfunction getPromiseCtor(promiseCtor) {\n    if (!promiseCtor) {\n        promiseCtor = _config__WEBPACK_IMPORTED_MODULE_1__.config.Promise || Promise;\n    }\n    if (!promiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return promiseCtor;\n}\n//# sourceMappingURL=Observable.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/Observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/Observer.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"empty\": () => (/* binding */ empty)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/config.js\");\n/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/hostReportError.js\");\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) {\n        if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {\n            throw err;\n        }\n        else {\n            (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.hostReportError)(err);\n        }\n    },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/Observer.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/Scheduler.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scheduler\": () => (/* binding */ Scheduler)\n/* harmony export */ });\nvar Scheduler = /*@__PURE__*/ (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = function () { return Date.now(); };\n    return Scheduler;\n}());\n\n//# sourceMappingURL=Scheduler.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/Scheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/Subject.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SubjectSubscriber\": () => (/* binding */ SubjectSubscriber),\n/* harmony export */   \"Subject\": () => (/* binding */ Subject),\n/* harmony export */   \"AnonymousSubject\": () => (/* binding */ AnonymousSubject)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Observable.js\");\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscriber.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscription.js\");\n/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js\");\n/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/SubjectSubscription.js\");\n/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js\");\n/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\n\n\n\n\n\n\n\nvar SubjectSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        return _this;\n    }\n    return SubjectSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\n\nvar Subject = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.observers = [];\n        _this.closed = false;\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__.rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_6__.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(_Observable__WEBPACK_IMPORTED_MODULE_6__.Observable));\n\nvar AnonymousSubject = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\n\n//# sourceMappingURL=Subject.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/Subject.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/SubjectSubscription.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SubjectSubscription\": () => (/* binding */ SubjectSubscription)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscription.js\");\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar SubjectSubscription = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        var _this = _super.call(this) || this;\n        _this.subject = subject;\n        _this.subscriber = subscriber;\n        _this.closed = false;\n        return _this;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));\n\n//# sourceMappingURL=SubjectSubscription.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/SubjectSubscription.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/Subscriber.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Subscriber\": () => (/* binding */ Subscriber),\n/* harmony export */   \"SafeSubscriber\": () => (/* binding */ SafeSubscriber)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isFunction.js\");\n/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Observer.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscription.js\");\n/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/config.js\");\n/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/hostReportError.js\");\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n\n\n\n\n\n\n\nvar Subscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(Subscriber, _super);\n    function Subscriber(destinationOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this.syncErrorValue = null;\n        _this.syncErrorThrown = false;\n        _this.syncErrorThrowable = false;\n        _this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n                        _this.destination = destinationOrNext;\n                        destinationOrNext.add(_this);\n                    }\n                    else {\n                        _this.syncErrorThrowable = true;\n                        _this.destination = new SafeSubscriber(_this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                _this.syncErrorThrowable = true;\n                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n                break;\n        }\n        return _this;\n    }\n    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__.rxSubscriber] = function () { return this; };\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _parentOrParents = this._parentOrParents;\n        this._parentOrParents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parentOrParents = _parentOrParents;\n        return this;\n    };\n    return Subscriber;\n}(_Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription));\n\nvar SafeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = _this;\n        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__.isFunction)(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__.empty) {\n                context = Object.create(observerOrNext);\n                if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__.isFunction)(context.unsubscribe)) {\n                    _this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = _this.unsubscribe.bind(_this);\n            }\n        }\n        _this._context = context;\n        _this._next = next;\n        _this._error = error;\n        _this._complete = complete;\n        return _this;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling;\n            if (this._error) {\n                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                if (useDeprecatedSynchronousErrorHandling) {\n                    throw err;\n                }\n                (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);\n            }\n            else {\n                if (useDeprecatedSynchronousErrorHandling) {\n                    _parentSubscriber.syncErrorValue = err;\n                    _parentSubscriber.syncErrorThrown = true;\n                }\n                else {\n                    (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);\n                }\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            if (_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling) {\n                throw err;\n            }\n            else {\n                (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        if (!_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling) {\n            throw new Error('bad call');\n        }\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            if (_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            else {\n                (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);\n                return true;\n            }\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n\n//# sourceMappingURL=Subscriber.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/Subscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/Subscription.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Subscription\": () => (/* binding */ Subscription)\n/* harmony export */ });\n/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isArray.js\");\n/* harmony import */ var _util_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isObject.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js\");\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\n\n\n\n\nvar Subscription = /*@__PURE__*/ (function () {\n    function Subscription(unsubscribe) {\n        this.closed = false;\n        this._parentOrParents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._ctorUnsubscribe = true;\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parentOrParents = null;\n        this._subscriptions = null;\n        if (_parentOrParents instanceof Subscription) {\n            _parentOrParents.remove(this);\n        }\n        else if (_parentOrParents !== null) {\n            for (var index = 0; index < _parentOrParents.length; ++index) {\n                var parent_1 = _parentOrParents[index];\n                parent_1.remove(this);\n            }\n        }\n        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(_unsubscribe)) {\n            if (_ctorUnsubscribe) {\n                this._unsubscribe = undefined;\n            }\n            try {\n                _unsubscribe.call(this);\n            }\n            catch (e) {\n                errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n            }\n        }\n        if ((0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if ((0,_util_isObject__WEBPACK_IMPORTED_MODULE_3__.isObject)(sub)) {\n                    try {\n                        sub.unsubscribe();\n                    }\n                    catch (e) {\n                        errors = errors || [];\n                        if (e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n                        }\n                        else {\n                            errors.push(e);\n                        }\n                    }\n                }\n            }\n        }\n        if (errors) {\n            throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError(errors);\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var subscription = teardown;\n        if (!teardown) {\n            return Subscription.EMPTY;\n        }\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (!(subscription instanceof Subscription)) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default: {\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n        }\n        var _parentOrParents = subscription._parentOrParents;\n        if (_parentOrParents === null) {\n            subscription._parentOrParents = this;\n        }\n        else if (_parentOrParents instanceof Subscription) {\n            if (_parentOrParents === this) {\n                return subscription;\n            }\n            subscription._parentOrParents = [_parentOrParents, this];\n        }\n        else if (_parentOrParents.indexOf(this) === -1) {\n            _parentOrParents.push(this);\n        }\n        else {\n            return subscription;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions === null) {\n            this._subscriptions = [subscription];\n        }\n        else {\n            subscriptions.push(subscription);\n        }\n        return subscription;\n    };\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\n\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/Subscription.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/config.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"config\": () => (/* binding */ config)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nvar config = {\n    Promise: undefined,\n    set useDeprecatedSynchronousErrorHandling(value) {\n        if (value) {\n            var error = /*@__PURE__*/ new Error();\n            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n        }\n        else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');\n        }\n        _enable_super_gross_mode_that_will_cause_bad_things = value;\n    },\n    get useDeprecatedSynchronousErrorHandling() {\n        return _enable_super_gross_mode_that_will_cause_bad_things;\n    },\n};\n//# sourceMappingURL=config.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/config.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/innerSubscribe.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SimpleInnerSubscriber\": () => (/* binding */ SimpleInnerSubscriber),\n/* harmony export */   \"ComplexInnerSubscriber\": () => (/* binding */ ComplexInnerSubscriber),\n/* harmony export */   \"SimpleOuterSubscriber\": () => (/* binding */ SimpleOuterSubscriber),\n/* harmony export */   \"ComplexOuterSubscriber\": () => (/* binding */ ComplexOuterSubscriber),\n/* harmony export */   \"innerSubscribe\": () => (/* binding */ innerSubscribe)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscriber.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Observable.js\");\n/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/subscribeTo.js\");\n/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */\n\n\n\n\nvar SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SimpleInnerSubscriber, _super);\n    function SimpleInnerSubscriber(parent) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        return _this;\n    }\n    SimpleInnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(value);\n    };\n    SimpleInnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error);\n        this.unsubscribe();\n    };\n    SimpleInnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete();\n        this.unsubscribe();\n    };\n    return SimpleInnerSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\n\nvar ComplexInnerSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ComplexInnerSubscriber, _super);\n    function ComplexInnerSubscriber(parent, outerValue, outerIndex) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        _this.outerValue = outerValue;\n        _this.outerIndex = outerIndex;\n        return _this;\n    }\n    ComplexInnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);\n    };\n    ComplexInnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error);\n        this.unsubscribe();\n    };\n    ComplexInnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return ComplexInnerSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\n\nvar SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SimpleOuterSubscriber, _super);\n    function SimpleOuterSubscriber() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {\n        this.destination.next(innerValue);\n    };\n    SimpleOuterSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SimpleOuterSubscriber.prototype.notifyComplete = function () {\n        this.destination.complete();\n    };\n    return SimpleOuterSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\n\nvar ComplexOuterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ComplexOuterSubscriber, _super);\n    function ComplexOuterSubscriber() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {\n        this.destination.next(innerValue);\n    };\n    ComplexOuterSubscriber.prototype.notifyError = function (error) {\n        this.destination.error(error);\n    };\n    ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {\n        this.destination.complete();\n    };\n    return ComplexOuterSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\n\nfunction innerSubscribe(result, innerSubscriber) {\n    if (innerSubscriber.closed) {\n        return undefined;\n    }\n    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable) {\n        return result.subscribe(innerSubscriber);\n    }\n    return (0,_util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__.subscribeTo)(result)(innerSubscriber);\n}\n//# sourceMappingURL=innerSubscribe.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/innerSubscribe.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/observable/interval.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"interval\": () => (/* binding */ interval)\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Observable.js\");\n/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/scheduler/async.js\");\n/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isNumeric.js\");\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\n\n\n\nfunction interval(period, scheduler) {\n    if (period === void 0) {\n        period = 0;\n    }\n    if (scheduler === void 0) {\n        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;\n    }\n    if (!(0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;\n    }\n    return new _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable(function (subscriber) {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\n    subscriber.next(counter);\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\n}\n//# sourceMappingURL=interval.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/observable/interval.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/operators/sampleTime.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sampleTime\": () => (/* binding */ sampleTime)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscriber.js\");\n/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/scheduler/async.js\");\n/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\n\n\n\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;\n    }\n    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n}\nvar SampleTimeOperator = /*@__PURE__*/ (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\nvar SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_1__.__extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.period = period;\n        _this.scheduler = scheduler;\n        _this.hasValue = false;\n        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));\n        return _this;\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/operators/sampleTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/operators/throttle.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultThrottleConfig\": () => (/* binding */ defaultThrottleConfig),\n/* harmony export */   \"throttle\": () => (/* binding */ throttle)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/innerSubscribe.js\");\n/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */\n\n\nvar defaultThrottleConfig = {\n    leading: true,\n    trailing: false\n};\nfunction throttle(durationSelector, config) {\n    if (config === void 0) {\n        config = defaultThrottleConfig;\n    }\n    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };\n}\nvar ThrottleOperator = /*@__PURE__*/ (function () {\n    function ThrottleOperator(durationSelector, leading, trailing) {\n        this.durationSelector = durationSelector;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n    };\n    return ThrottleOperator;\n}());\nvar ThrottleSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ThrottleSubscriber, _super);\n    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.durationSelector = durationSelector;\n        _this._leading = _leading;\n        _this._trailing = _trailing;\n        _this._hasValue = false;\n        return _this;\n    }\n    ThrottleSubscriber.prototype._next = function (value) {\n        this._hasValue = true;\n        this._sendValue = value;\n        if (!this._throttled) {\n            if (this._leading) {\n                this.send();\n            }\n            else {\n                this.throttle(value);\n            }\n        }\n    };\n    ThrottleSubscriber.prototype.send = function () {\n        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;\n        if (_hasValue) {\n            this.destination.next(_sendValue);\n            this.throttle(_sendValue);\n        }\n        this._hasValue = false;\n        this._sendValue = undefined;\n    };\n    ThrottleSubscriber.prototype.throttle = function (value) {\n        var duration = this.tryDurationSelector(value);\n        if (!!duration) {\n            this.add(this._throttled = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(duration, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this)));\n        }\n    };\n    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n        try {\n            return this.durationSelector(value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return null;\n        }\n    };\n    ThrottleSubscriber.prototype.throttlingDone = function () {\n        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;\n        if (_throttled) {\n            _throttled.unsubscribe();\n        }\n        this._throttled = undefined;\n        if (_trailing) {\n            this.send();\n        }\n    };\n    ThrottleSubscriber.prototype.notifyNext = function () {\n        this.throttlingDone();\n    };\n    ThrottleSubscriber.prototype.notifyComplete = function () {\n        this.throttlingDone();\n    };\n    return ThrottleSubscriber;\n}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));\n//# sourceMappingURL=throttle.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/operators/throttle.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/scheduler/Action.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Action\": () => (/* binding */ Action)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscription.js\");\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar Action = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(Action, _super);\n    function Action(scheduler, work) {\n        return _super.call(this) || this;\n    }\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return this;\n    };\n    return Action;\n}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));\n\n//# sourceMappingURL=Action.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/scheduler/Action.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsyncAction\": () => (/* binding */ AsyncAction)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/scheduler/Action.js\");\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n\n\nvar AsyncAction = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.pending = false;\n        return _this;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        clearInterval(id);\n        return undefined;\n    };\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(_Action__WEBPACK_IMPORTED_MODULE_1__.Action));\n\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsyncScheduler\": () => (/* binding */ AsyncScheduler)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Scheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Scheduler.js\");\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n\n\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = _Scheduler__WEBPACK_IMPORTED_MODULE_1__.Scheduler.now;\n        }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        _this.active = false;\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(_Scheduler__WEBPACK_IMPORTED_MODULE_1__.Scheduler));\n\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/scheduler/async.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"asyncScheduler\": () => (/* binding */ asyncScheduler),\n/* harmony export */   \"async\": () => (/* binding */ async)\n/* harmony export */ });\n/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js\");\n/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js\");\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar asyncScheduler = /*@__PURE__*/ new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__.AsyncScheduler(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__.AsyncAction);\nvar async = asyncScheduler;\n//# sourceMappingURL=async.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/scheduler/async.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/symbol/iterator.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getSymbolIterator\": () => (/* binding */ getSymbolIterator),\n/* harmony export */   \"iterator\": () => (/* binding */ iterator),\n/* harmony export */   \"$$iterator\": () => (/* binding */ $$iterator)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nvar iterator = /*@__PURE__*/ getSymbolIterator();\nvar $$iterator = iterator;\n//# sourceMappingURL=iterator.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/symbol/iterator.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/symbol/observable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"observable\": () => (/* binding */ observable)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();\n//# sourceMappingURL=observable.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/symbol/observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"rxSubscriber\": () => (/* binding */ rxSubscriber),\n/* harmony export */   \"$$rxSubscriber\": () => (/* binding */ $$rxSubscriber)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar rxSubscriber = /*@__PURE__*/ (function () {\n    return typeof Symbol === 'function'\n        ? /*@__PURE__*/ Symbol('rxSubscriber')\n        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();\n})();\nvar $$rxSubscriber = rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjectUnsubscribedError\": () => (/* binding */ ObjectUnsubscribedError)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {\n    function ObjectUnsubscribedErrorImpl() {\n        Error.call(this);\n        this.message = 'object unsubscribed';\n        this.name = 'ObjectUnsubscribedError';\n        return this;\n    }\n    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return ObjectUnsubscribedErrorImpl;\n})();\nvar ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnsubscriptionError\": () => (/* binding */ UnsubscriptionError)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {\n    function UnsubscriptionErrorImpl(errors) {\n        Error.call(this);\n        this.message = errors ?\n            errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ') : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n        return this;\n    }\n    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return UnsubscriptionErrorImpl;\n})();\nvar UnsubscriptionError = UnsubscriptionErrorImpl;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/canReportError.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canReportError\": () => (/* binding */ canReportError)\n/* harmony export */ });\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscriber.js\");\n/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\n\nfunction canReportError(observer) {\n    while (observer) {\n        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;\n        if (closed_1 || isStopped) {\n            return false;\n        }\n        else if (destination && destination instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) {\n            observer = destination;\n        }\n        else {\n            observer = null;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=canReportError.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/canReportError.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/hostReportError.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hostReportError\": () => (/* binding */ hostReportError)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction hostReportError(err) {\n    setTimeout(function () { throw err; }, 0);\n}\n//# sourceMappingURL=hostReportError.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/hostReportError.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/identity.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"identity\": () => (/* binding */ identity)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/identity.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/isArray.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isArray\": () => (/* binding */ isArray)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();\n//# sourceMappingURL=isArray.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/isArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/isArrayLike.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isArrayLike\": () => (/* binding */ isArrayLike)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/isFunction.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\n//# sourceMappingURL=isFunction.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/isFunction.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/isNumeric.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isNumeric\": () => (/* binding */ isNumeric)\n/* harmony export */ });\n/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isArray.js\");\n/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\n\nfunction isNumeric(val) {\n    return !(0,_isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(val) && (val - parseFloat(val) + 1) >= 0;\n}\n//# sourceMappingURL=isNumeric.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/isNumeric.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/isObject.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isObject\": () => (/* binding */ isObject)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isObject(x) {\n    return x !== null && typeof x === 'object';\n}\n//# sourceMappingURL=isObject.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/isObject.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/isPromise.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isPromise(value) {\n    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n//# sourceMappingURL=isPromise.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/isPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/pipe.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pipe\": () => (/* binding */ pipe),\n/* harmony export */   \"pipeFromArray\": () => (/* binding */ pipeFromArray)\n/* harmony export */ });\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/identity.js\");\n/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */\n\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nfunction pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/pipe.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/subscribeTo.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeTo\": () => (/* binding */ subscribeTo)\n/* harmony export */ });\n/* harmony import */ var _subscribeToArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js\");\n/* harmony import */ var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js\");\n/* harmony import */ var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js\");\n/* harmony import */ var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js\");\n/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isArrayLike.js\");\n/* harmony import */ var _isPromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isPromise.js\");\n/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/isObject.js\");\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/iterator.js\");\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/observable.js\");\n/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\n\n\n\n\n\n\n\n\n\nvar subscribeTo = function (result) {\n    if (!!result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.observable] === 'function') {\n        return (0,_subscribeToObservable__WEBPACK_IMPORTED_MODULE_1__.subscribeToObservable)(result);\n    }\n    else if ((0,_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(result)) {\n        return (0,_subscribeToArray__WEBPACK_IMPORTED_MODULE_3__.subscribeToArray)(result);\n    }\n    else if ((0,_isPromise__WEBPACK_IMPORTED_MODULE_4__.isPromise)(result)) {\n        return (0,_subscribeToPromise__WEBPACK_IMPORTED_MODULE_5__.subscribeToPromise)(result);\n    }\n    else if (!!result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__.iterator] === 'function') {\n        return (0,_subscribeToIterable__WEBPACK_IMPORTED_MODULE_7__.subscribeToIterable)(result);\n    }\n    else {\n        var value = (0,_isObject__WEBPACK_IMPORTED_MODULE_8__.isObject)(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = \"You provided \" + value + \" where a stream was expected.\"\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        throw new TypeError(msg);\n    }\n};\n//# sourceMappingURL=subscribeTo.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/subscribeTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeToArray\": () => (/* binding */ subscribeToArray)\n/* harmony export */ });\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar subscribeToArray = function (array) {\n    return function (subscriber) {\n        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    };\n};\n//# sourceMappingURL=subscribeToArray.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeToIterable\": () => (/* binding */ subscribeToIterable)\n/* harmony export */ });\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/iterator.js\");\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\nvar subscribeToIterable = function (iterable) {\n    return function (subscriber) {\n        var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.iterator]();\n        do {\n            var item = void 0;\n            try {\n                item = iterator.next();\n            }\n            catch (err) {\n                subscriber.error(err);\n                return subscriber;\n            }\n            if (item.done) {\n                subscriber.complete();\n                break;\n            }\n            subscriber.next(item.value);\n            if (subscriber.closed) {\n                break;\n            }\n        } while (true);\n        if (typeof iterator.return === 'function') {\n            subscriber.add(function () {\n                if (iterator.return) {\n                    iterator.return();\n                }\n            });\n        }\n        return subscriber;\n    };\n};\n//# sourceMappingURL=subscribeToIterable.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeToObservable\": () => (/* binding */ subscribeToObservable)\n/* harmony export */ });\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/observable.js\");\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\nvar subscribeToObservable = function (obj) {\n    return function (subscriber) {\n        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.observable]();\n        if (typeof obs.subscribe !== 'function') {\n            throw new TypeError('Provided object does not correctly implement Symbol.observable');\n        }\n        else {\n            return obs.subscribe(subscriber);\n        }\n    };\n};\n//# sourceMappingURL=subscribeToObservable.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeToPromise\": () => (/* binding */ subscribeToPromise)\n/* harmony export */ });\n/* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/util/hostReportError.js\");\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\n\nvar subscribeToPromise = function (promise) {\n    return function (subscriber) {\n        promise.then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__.hostReportError);\n        return subscriber;\n    };\n};\n//# sourceMappingURL=subscribeToPromise.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/internal/util/toSubscriber.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toSubscriber\": () => (/* binding */ toSubscriber)\n/* harmony export */ });\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Subscriber.js\");\n/* harmony import */ var _symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js\");\n/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/rxjs/_esm5/internal/Observer.js\");\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\n\n\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__.rxSubscriber]) {\n            return nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__.rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber(_Observer__WEBPACK_IMPORTED_MODULE_2__.empty);\n    }\n    return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber(nextOrObserver, error, complete);\n}\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/_esm5/internal/util/toSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/node_modules/tslib/tslib.es6.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__values\": () => (/* binding */ __values),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./node_modules/rxjs/node_modules/tslib/tslib.es6.js?");

/***/ })

}]);