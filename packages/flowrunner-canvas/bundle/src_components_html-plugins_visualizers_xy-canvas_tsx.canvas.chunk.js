/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["flowcanvaswebpackJsonpPlugin"] = self["flowcanvaswebpackJsonpPlugin"] || []).push([["src_components_html-plugins_visualizers_xy-canvas_tsx"],{

/***/ "./src/components/html-plugins/visualizers/xy-canvas.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XYCanvas\": () => (/* binding */ XYCanvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"../../node_modules/react-konva/es/ReactKonva.js\");\n\n\nconst heightCorrection = 42;\nclass XYCanvas extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {};\n    this.getCurrentDebugNotifier = () => {\n      if (this.props.selectedNode && this.props.selectedNode.node) {\n        let selectedNodePayload = this.props.selectedNode.payload;\n        if (selectedNodePayload) {\n          if (!selectedNodePayload.nodeExecutionId) {\n            return null;\n          }\n          let nodeExecutions = this.props.flowrunnerConnector.getNodeExecutions();\n          let executionIndex = -1;\n          nodeExecutions.map((nodeExec, index) => {\n            if (nodeExec && nodeExec.payload && nodeExec.payload.nodeExecutionId == selectedNodePayload.nodeExecutionId) {\n              executionIndex = index;\n            }\n          });\n          if (executionIndex >= 0) {\n            let isFound = false;\n            let resultPayloadIndex = -1;\n            let loop = executionIndex;\n            while (loop >= 0) {\n              let index = loop;\n              let nodeExec = nodeExecutions[loop];\n              if (!isFound && index <= executionIndex) {\n                this.props.payloads.map((payload, payloadIndex) => {\n                  if (!isFound && payload && nodeExec.payload && payload.debugId == nodeExec.payload.debugId) {\n                    isFound = true;\n                    resultPayloadIndex = payloadIndex;\n                  }\n                });\n              }\n              loop--;\n            }\n            if (resultPayloadIndex >= 0) {\n              let height = (this.props.node.height || 250) - heightCorrection;\n              let width = this.props.node.width || 250;\n              return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, {\n                points: [\n                  resultPayloadIndex,\n                  0,\n                  resultPayloadIndex,\n                  height\n                ],\n                tension: 0,\n                closed: true,\n                stroke: \"#3f51b5\",\n                strokeWidth: 2\n              });\n            }\n          }\n        }\n      }\n      return null;\n    };\n    this.getMinMax = (payloads, series, height, node) => {\n      let result = {\n        min: void 0,\n        max: void 0,\n        ratio: 1,\n        correction: 0\n      };\n      payloads.map((payload) => {\n        series.map((serie) => {\n          if (payload[serie.yProperty]) {\n            if (result.min === void 0 || payload[serie.yProperty] < result.min) {\n              result.min = payload[serie.yProperty];\n            }\n            if (result.max === void 0 || payload[serie.yProperty] > result.max) {\n              result.max = payload[serie.yProperty];\n            }\n          }\n        });\n      });\n      if (node.minValue !== void 0) {\n        result.min = result.min !== void 0 && node.minValue > result.min ? result.min : node.minValue;\n      }\n      if (node.maxValue !== void 0) {\n        result.max = result.max !== void 0 && node.maxValue < result.max ? result.max : node.maxValue;\n      }\n      if (result.min !== void 0 && result.max !== void 0) {\n        if (result.max - result.min != 0 && height != 0) {\n          result.ratio = 1 / ((result.max - result.min) / (height - 2));\n        }\n        if (result.min < 0) {\n          result.correction = -(result.min * result.ratio) + 1;\n        } else {\n          result.correction = -(result.min * result.ratio) + 1;\n        }\n      }\n      return result;\n    };\n    this.getLineChart = (node, xProperty, yProperty, payload, index, payloads, color, serieIndex, title, fill, minmax) => {\n      let circle = null;\n      let height = (this.props.node.height || 250) - heightCorrection;\n      let xPosition = index;\n      if (payloads.length < 250) {\n        xPosition = index + (250 - payloads.length);\n      }\n      if ((xProperty == \"index\" || !isNaN(payload[xProperty])) && !isNaN(payload[yProperty])) {\n        let x = 0;\n        if (xProperty == \"index\") {\n          x = xPosition;\n        } else {\n          x = payload[xProperty];\n        }\n        let y = 2 + (height - 2 - (payload[yProperty] * minmax.ratio + minmax.correction));\n        let xNext = 0;\n        let yNext = 0;\n        if (!!node.includeLines && index < payloads.length - 1) {\n          if (xProperty == \"index\") {\n            xNext = xPosition + 1;\n          } else {\n            xNext = payloads[index + 1][xProperty];\n          }\n          yNext = 2 + (height - 2 - (payloads[index + 1][yProperty] * minmax.ratio + minmax.correction));\n        }\n        circle = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n          key: \"xycanvas-wrapper-\" + index + \"-\" + serieIndex\n        }, !node.includeLines && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Circle, {\n          key: \"xycanvas-\" + index + \"-\" + serieIndex,\n          x,\n          y,\n          radius: 4,\n          stroke: color,\n          strokeWidth: 2,\n          width: 4,\n          height: 4,\n          fill: color,\n          perfectDrawEnabled: true\n        }), fill !== \"\" && !!node.includeLines && index < payloads.length - 1 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, {\n          points: [\n            x,\n            y,\n            xNext,\n            yNext,\n            xNext,\n            height,\n            x,\n            height\n          ],\n          tension: 0,\n          closed: true,\n          strokeWidth: 1,\n          fill\n        }), !!node.includeLines && index < payloads.length - 1 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, {\n          points: [\n            x,\n            y,\n            xNext,\n            yNext\n          ],\n          tension: 0,\n          closed: true,\n          stroke: color,\n          strokeWidth: 1\n        }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Label, {\n          x: 4,\n          y: serieIndex * 24\n        }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Text, {\n          text: title,\n          fontSize: 18,\n          align: \"left\",\n          height: 24,\n          verticalAlign: \"middle\",\n          listening: false,\n          wrap: \"none\",\n          ellipsis: true,\n          fill: color,\n          perfectDrawEnabled: true\n        })));\n      }\n      return circle;\n    };\n    this.getCurved = (node, xProperty, yProperty, payloads, minmax) => {\n      let height = (this.props.node.height || 250) - heightCorrection;\n      let points = [];\n      payloads.map((payload, index) => {\n        if (index % (node.sample || 10) == 0) {\n          if ((xProperty == \"index\" || !isNaN(payload[xProperty])) && !isNaN(payload[yProperty])) {\n            let xPosition = index;\n            if (payloads.length < 250) {\n              xPosition = index + (250 - payloads.length);\n            }\n            let x = 0;\n            if (xProperty == \"index\") {\n              x = xPosition;\n            } else {\n              x = payload[xProperty];\n            }\n            let y = 2 + (height - 2 - (payload[yProperty] * minmax.ratio + minmax.correction));\n            points.push(x);\n            points.push(y);\n          }\n        }\n      });\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Line, {\n        points,\n        stroke: \"#000000\",\n        bezier: true,\n        strokeWidth: 1\n      });\n    };\n  }\n  componentDidMount() {\n  }\n  render() {\n    let height = (this.props.node.height || 250) - heightCorrection;\n    let circles = null;\n    const {node, payloads} = this.props;\n    let minmax = this.getMinMax(payloads, node.series ? node.series : [{xProperty: node.xProperty, yProperty: node.yProperty}], height, this.props.node);\n    if (!!node.showCurved) {\n      circles = this.getCurved(node, node.xProperty, node.yProperty, payloads, minmax);\n    } else {\n      circles = payloads.map((payload, index) => {\n        let circle = null;\n        if (node.series) {\n          circle = node.series.map((serie, serieIndex) => {\n            if (serie.xProperty && serie.yProperty && serie.color) {\n              return this.getLineChart(node, serie.xProperty, serie.yProperty, payload, index, payloads, serie.color, serieIndex, serie.title || \"\", serie.fill || \"\", minmax);\n            }\n            return null;\n          });\n        } else if (node.xProperty && node.yProperty) {\n          circle = this.getLineChart(node, node.xProperty, node.yProperty, payload, index, payloads, node.color || \"#000000\", 0, node.lineTitle || \"\", node.fill || \"\", minmax);\n        }\n        return circle;\n      });\n    }\n    const yAdd = 6;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Stage, {\n      pixelRatio: 1,\n      width: (this.props.node.width || 250) + 1,\n      height\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_konva__WEBPACK_IMPORTED_MODULE_1__.Layer, null, circles, this.getCurrentDebugNotifier())), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"xy-canvas__legend\"\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"xy-canvas__text\"\n    }, \"min: \", minmax.min?.toFixed(2)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"xy-canvas__text\"\n    }, \"max: \", minmax.max?.toFixed(2))));\n  }\n}\n\n\n//# sourceURL=webpack://@devhelpr/flowrunner-canvas/./src/components/html-plugins/visualizers/xy-canvas.tsx?");

/***/ })

}]);